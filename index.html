<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Analytics Map</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.30/esri/themes/light/main.css">

    <!-- jQuery and jQuery UI for Autocomplete -->
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>
    <script src="https://js.arcgis.com/4.30/"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            background: #f5f5f5;
        }

        #header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            background-color: #ffffff;
            border-bottom: 1px solid #ccc;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #main-content {
            display: flex;
            flex: 1 1 auto;
            flex-direction: column;
            overflow: hidden;
        }

        #viewDiv {
            flex: 2 1 60%;
            position: relative;
        }

        #featuresDiv {
            flex: 2 1 40%;
            background-color: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .features-inner {
            flex: 1 1 auto;
            overflow: auto;
        }

        #featuresContentDiv {
            padding: 10px;
            box-sizing: border-box;
            height: 100%;
            overflow: auto;
            background: #ffffff;
        }

        .attribute-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            table-layout: fixed;
            background-color: #ffffff;
            border: 1px solid #ddd;
        }

        .attribute-table thead th {
            position: sticky;
            top: 0;
            background-color: #4b8fcf;
            color: #fff;
            text-align: left;
            font-weight: bold;
            border: 1px solid #ccc;
            padding: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            z-index: 10;
        }

        .attribute-table th,
        .attribute-table td {
            border: 1px solid #ddd;
            padding: 8px;
            box-sizing: border-box;
            vertical-align: middle;
            background: #fff;
        }

        .attribute-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .attribute-table tbody tr:hover {
            background-color: #e8f0fe;
        }

        #filterDiv {
            position: absolute;
            top: 100px;
            right: 20px;
            z-index: 20;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            width: 250px;
            font-size: 14px;
            border: 1px solid #ccc;
        }

        #filterDiv label {
            font-weight: bold;
            margin-bottom: 5px;
            display: inline-block;
        }

        #filterDiv select,
        #filterDiv input {
            width: 100%;
            margin-top: 5px;
            margin-bottom: 10px;
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }

        #reportingDiv {
            position: absolute;
            top: 68px;
            left: 70px;
            z-index: 20;
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            border: 1px solid #ccc;
        }

        #reportingDiv button {
            padding: 8px 15px;
            margin-right: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f7f7f7, #e2e2e2);
            transition: background 0.3s, border-color 0.3s;
        }

        #reportingDiv button:hover {
            background: linear-gradient(to bottom, #f0f0f0, #d9d9d9);
            border-color: #999;
        }

        #reportingDiv button:active {
            background: linear-gradient(to bottom, #d9d9d9, #c2c2c2);
            border-color: #777;
        }

        #loadingSpinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            display: none;
        }

        #filterStatus {
            margin-top: 10px;
            color: #555;
            font-size: 12px;
        }

        .print-title,
        .print-legend {
            display: none;
            position: absolute;
            background: #fff;
            padding: 10px;
            border: 1px solid #ccc;
        }

        .print-title {
            top: 10px;
            left: 10px;
            font-size: 18px;
            font-weight: bold;
        }

        .print-legend {
            top: 60px;
            left: 10px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <header id="header">
            <div>City of Walnut Creek</div>
            <div>Traffic Analytics Map</div>
        </header>
        <div id="main-content">
            <div id="viewDiv">
                <div class="print-title">City of Walnut Creek - Traffic Map</div>
                <div class="print-legend">
                    <strong>Legend:</strong><br>
                    Cyan highlight = Selected feature(s)<br>
                    Blue symbols = Other features
                </div>
            </div>
            <div id="featuresDiv">
                <div class="features-inner" id="featuresInnerDiv">
                    <div class="features-content" id="featuresContentDiv">
                        <table class="attribute-table" id="attributeTable">
                            <thead></thead>
                            <tbody>
                                <tr>
                                    <td colspan="28">No features match the selected filters.</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div id="filterDiv">
            <div id="filterControls"></div>
            <div id="filterStatus">If features are selected, filters apply only to them; otherwise globally. Clicking
                empty space unselects all. All filters remove non-matching features.</div>
        </div>
        <div id="reportingDiv">
            <select id="reportFormat">
                <option value="pdf">PDF</option>
                <option value="csv">CSV</option>
            </select>
            <button id="generateReportBtn" aria-label="Generate Report">Generate Report</button>
            <button id="printMapBtn" aria-label="Export Map">Export Map</button>
        </div>
        <div id="loadingSpinner">
            <img src="spinner.gif" alt="Loading..." />
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const DATA_TYPE_FIELD = "Data_Type";
            const YEAR_FIELD = "Year";
            const PERIOD_FIELD = "Period";
            const MAJOR_STREETS_FIELD = "Major_Streets";
            const MINOR_STREETS_FIELD = "Minor_Streets";

            let map, view;
            let allLayers = [];
            let highlightHandle = null;
            let allYears = new Set();

            let currentDataType = "All";
            let currentYears = [];
            let currentPeriod = "All";
            let currentStreet = "";

            let selectedFeatures = [];
            let filteredFeatures = [];

            let currentHeadersToDisplay = [];
            let currentTableData = [];

            let originalViewpoint = null;
            let streetList = [];

            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/Graphic",
                "esri/rest/support/Query",
                "esri/rest/support/RelationshipQuery",
                "esri/layers/support/FeatureFilter"
            ], function (Map, MapView, FeatureLayer, Graphic, Query, RelationshipQuery, FeatureFilter) {

                init();

                async function init() {
                    showLoadingSpinner();
                    map = new Map({ basemap: "streets-navigation-vector" });

                    view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-122.063686, 37.901657],
                        zoom: 13
                    });

                    const baseUrl = "https://services2.arcgis.com/AhHMUmDoudKVXiUl/arcgis/rest/services/Aggregated_PEAK_Locations_WFL1/FeatureServer";
                    const layerIds = Array.from({ length: 104 }, (_, i) => i);

                    await Promise.all(layerIds.map(async (id) => {
                        const layerUrl = `${baseUrl}/${id}`;
                        const isSpatial = await isSpatialLayer(layerUrl);
                        if (isSpatial) {
                            try {
                                const layer = new FeatureLayer({
                                    url: layerUrl,
                                    outFields: ["*"],
                                    id: `layer-${id}`
                                });
                                await layer.load();
                                allLayers.push(layer);
                                map.add(layer);
                            } catch (error) {
                                console.error(`Error adding layer ID ${id}:`, error);
                            }
                        }
                    }));

                    if (allLayers.length === 0) {
                        console.error("No spatial layers found.");
                        hideLoadingSpinner();
                        return;
                    }

                    view.when(() => {
                        originalViewpoint = view.viewpoint.clone();
                        zoomToAllLayers(allLayers);

                        // Populate street list first
                        populateStreetList(allLayers).then(() => {
                            // Then initialize the year filter
                            initializeYearFilter(allLayers).then(() => {
                                // Create filter elements (this creates #streetFilter)
                                createFilterElements();

                                // Now that #streetFilter is created, initialize autocomplete
                                $("#streetFilter").autocomplete({
                                    source: streetList,
                                    minLength: 0
                                }).focus(function () {
                                    $(this).autocomplete("search", "");
                                });

                                // Finally, apply filters
                                applyFilters();
                            });

                            view.on("click", handleMapClick);

                            document.getElementById("generateReportBtn").addEventListener("click", generateReport);
                            document.getElementById("printMapBtn").addEventListener("click", exportMapAsPDF);
                        });
                    }).catch((error) => {
                        console.error("Error loading the map:", error);
                    }).finally(() => {
                        hideLoadingSpinner();
                    });
                }

                function showLoadingSpinner() {
                    document.getElementById("loadingSpinner").style.display = "block";
                }

                function hideLoadingSpinner() {
                    document.getElementById("loadingSpinner").style.display = "none";
                }

                async function isSpatialLayer(layerUrl) {
                    try {
                        const response = await fetch(layerUrl + "?f=json");
                        const data = await response.json();
                        return data.geometryType !== undefined && data.geometryType !== null;
                    } catch (error) {
                        console.error("Error checking if layer is spatial:", error);
                        return false;
                    }
                }

                function zoomToAllLayers(layers) {
                    const extents = layers.map(layer => layer.fullExtent).filter(extent => extent);
                    if (extents.length > 0) {
                        view.goTo(extents).catch((error) => {
                            console.error("Error zooming:", error);
                        });
                    }
                }

                async function populateStreetList(spatialLayers) {
                    const streetSet = new Set();
                    const layerPromises = spatialLayers.map(layer => {
                        const query = layer.createQuery();
                        query.where = "1=1";
                        query.returnDistinctValues = true;
                        query.outFields = [MAJOR_STREETS_FIELD, MINOR_STREETS_FIELD].filter(Boolean);

                        return layer.queryFeatures(query).then(result => {
                            result.features.forEach(feature => {
                                [MAJOR_STREETS_FIELD, MINOR_STREETS_FIELD].forEach(fld => {
                                    if (feature.attributes[fld]) {
                                        const streetName = feature.attributes[fld];
                                        if (streetName) {
                                            streetSet.add(streetName);
                                        }
                                    }
                                });
                            });
                        }).catch(error => {
                            console.error("Error querying streets:", error);
                        });
                    });

                    await Promise.all(layerPromises);
                    streetList = Array.from(streetSet).sort();
                }

                async function initializeYearFilter(spatialLayers) {
                    const yearPromises = spatialLayers.map(layer => {
                        const getYearsFromSource = async (source, fields) => {
                            const yearField = fields.find(f => f.name.toLowerCase() === YEAR_FIELD.toLowerCase());
                            if (yearField) {
                                const query = source.createQuery();
                                query.where = "1=1";
                                query.outFields = [yearField.name];
                                query.returnDistinctValues = true;
                                query.returnGeometry = false;
                                try {
                                    const result = await source.queryFeatures(query);
                                    result.features.forEach(feature => {
                                        const year = feature.attributes[yearField.name];
                                        if (year) {
                                            allYears.add(year);
                                        }
                                    });
                                } catch (error) {
                                    console.error("Error querying years:", error);
                                }
                            }
                        };

                        const layerPromises = [
                            getYearsFromSource(layer, layer.fields)
                        ];

                        (layer.relationships || []).forEach(rel => {
                            const relatedTableUrl = `${layer.url.replace(/\/\d+$/, "")}/${rel.relatedTableId}`;
                            const relatedTable = new FeatureLayer({
                                url: relatedTableUrl,
                                outFields: ["*"]
                            });
                            layerPromises.push(
                                relatedTable.load().then(() => getYearsFromSource(relatedTable, relatedTable.fields)).catch(() => { })
                            );
                        });

                        return Promise.all(layerPromises);
                    });

                    await Promise.all(yearPromises.flat());
                }

                function createFilterElements() {
                    const filterControlsDiv = document.getElementById("filterControls");

                    // Data Type Filter
                    const dataTypeLabel = document.createElement("label");
                    dataTypeLabel.textContent = "Filter by Data Type:";
                    dataTypeLabel.setAttribute("for", "dataTypeFilter");
                    const dataTypeSelect = document.createElement('select');
                    dataTypeSelect.id = 'dataTypeFilter';
                    const dataTypes = ["All", "Bikes", "Intersection Info", "PHF", "Pedestrian", "Heavy Vehicles", "Turning Movement"];
                    dataTypes.forEach((type) => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.text = type;
                        dataTypeSelect.add(option);
                    });
                    filterControlsDiv.appendChild(dataTypeLabel);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(dataTypeSelect);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(document.createElement("br"));

                    // Year Filter
                    const yearLabel = document.createElement("label");
                    yearLabel.textContent = "Filter by Year:";
                    yearLabel.setAttribute("for", "yearFilter");
                    const yearSelect = document.createElement('select');
                    yearSelect.id = "yearFilter";
                    yearSelect.multiple = true;
                    yearSelect.size = 5;

                    const allYearsOption = document.createElement("option");
                    allYearsOption.value = "All";
                    allYearsOption.textContent = "All";
                    yearSelect.appendChild(allYearsOption);

                    const sortedYears = Array.from(allYears).sort();
                    sortedYears.forEach(year => {
                        const option = document.createElement("option");
                        option.value = year;
                        option.textContent = year;
                        yearSelect.appendChild(option);
                    });

                    filterControlsDiv.appendChild(yearLabel);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(yearSelect);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(document.createElement("br"));

                    // Period Filter
                    const periodLabel = document.createElement("label");
                    periodLabel.textContent = "Filter by Period:";
                    periodLabel.setAttribute("for", "periodFilter");
                    const periodSelect = document.createElement("select");
                    periodSelect.id = "periodFilter";
                    const periods = ["All", "AM", "MID", "PM"];
                    periods.forEach((period) => {
                        const option = document.createElement("option");
                        option.value = period;
                        option.textContent = period;
                        periodSelect.appendChild(option);
                    });
                    filterControlsDiv.appendChild(periodLabel);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(periodSelect);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(document.createElement("br"));

                    // Street Filter
                    const streetLabel = document.createElement("label");
                    streetLabel.textContent = "Filter by Street:";
                    streetLabel.setAttribute("for", "streetFilter");
                    const streetInput = document.createElement("input");
                    streetInput.id = "streetFilter";
                    streetInput.placeholder = "Enter street name";
                    filterControlsDiv.appendChild(streetLabel);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(streetInput);
                    filterControlsDiv.appendChild(document.createElement("br"));
                    filterControlsDiv.appendChild(document.createElement("br"));

                    streetInput.addEventListener('input', applyFilters);
                    streetInput.addEventListener('change', applyFilters);

                    document.getElementById("dataTypeFilter").addEventListener('change', applyFilters);
                    document.getElementById("yearFilter").addEventListener('change', applyFilters);
                    document.getElementById("periodFilter").addEventListener('change', applyFilters);
                }

                async function applyFilters() {
                    const dataType = document.getElementById("dataTypeFilter").value;
                    const yearSelect = document.getElementById("yearFilter");
                    const selectedYearOptions = Array.from(yearSelect.selectedOptions);
                    const years = selectedYearOptions.map(option => option.value);
                    const period = document.getElementById('periodFilter').value;
                    const street = document.getElementById('streetFilter').value.trim();

                    currentDataType = dataType;
                    currentYears = years;
                    currentPeriod = period;
                    currentStreet = street;

                    let mainWhereClauses = [];
                    if (street) {
                        mainWhereClauses.push(`(${MAJOR_STREETS_FIELD} LIKE '%${street}%' OR ${MINOR_STREETS_FIELD} LIKE '%${street}%')`);
                    }

                    const mainWhere = mainWhereClauses.length > 0 ? mainWhereClauses.join(' AND ') : "1=1";
                    allLayers.forEach(layer => {
                        layer.definitionExpression = mainWhere;
                    });

                    let matchedFeatures = [];
                    if (selectedFeatures.length === 0) {
                        for (const layer of allLayers) {
                            const visibleFeatures = await queryAllVisibleFeatures(layer);
                            const filtered = await clientSideRelatedDataFilter(layer, visibleFeatures, dataType, years, period);
                            matchedFeatures = matchedFeatures.concat(filtered);
                        }

                        for (const layer of allLayers) {
                            const layerView = await view.whenLayerView(layer);
                            const layerOIDs = matchedFeatures.filter(f => f.layer.id === layer.id)
                                .map(f => f.attributes[layer.objectIdField]);
                            const filter = new FeatureFilter({
                                objectIds: layerOIDs
                            });
                            layerView.filter = filter;
                        }
                    } else {
                        const featsByLayer = {};
                        selectedFeatures.forEach(f => {
                            if (!featsByLayer[f.layer.id]) featsByLayer[f.layer.id] = [];
                            featsByLayer[f.layer.id].push(f);
                        });

                        let selectionMatched = [];
                        for (const layerId in featsByLayer) {
                            const layer = allLayers.find(l => l.id === layerId);
                            const baseFeats = featsByLayer[layerId];
                            const filtered = await clientSideRelatedDataFilter(layer, baseFeats, dataType, years, period);
                            selectionMatched = selectionMatched.concat(filtered);
                        }
                        matchedFeatures = selectionMatched;

                        for (const layer of allLayers) {
                            const layerView = await view.whenLayerView(layer);
                            layerView.filter = null;
                        }
                    }

                    filteredFeatures = matchedFeatures;

                    if (highlightHandle) {
                        highlightHandle.remove();
                        highlightHandle = null;
                    }
                    if (selectedFeatures.length > 0) {
                        const matchedOIDs = new Set(filteredFeatures.map(f => f.attributes[f.layer.objectIdField]));
                        const byLayer = {};
                        const actuallySelectedMatched = selectedFeatures.filter(f => matchedOIDs.has(f.attributes[f.layer.objectIdField]));
                        actuallySelectedMatched.forEach(f => {
                            if (!byLayer[f.layer.id]) byLayer[f.layer.id] = [];
                            byLayer[f.layer.id].push(f.attributes[f.layer.objectIdField]);
                        });

                        for (const layerId in byLayer) {
                            const layer = allLayers.find(l => l.id === layerId);
                            const layerView = await view.whenLayerView(layer);
                            highlightHandle = layerView.highlight(byLayer[layerId]);
                        }
                    }

                    displayAttributes(filteredFeatures);
                }

                async function queryAllVisibleFeatures(layer) {
                    const query = layer.createQuery();
                    query.where = layer.definitionExpression || "1=1";
                    query.outFields = ["*"];
                    query.returnGeometry = true;
                    const featureSet = await layer.queryFeatures(query);
                    return featureSet.features;
                }

                async function clientSideRelatedDataFilter(layer, features, dataType, years, period) {
                    const objectIds = features.map(f => f.attributes[layer.objectIdField]);
                    const relatedDataForAllFeatures = await fetchRelatedData(layer, objectIds);

                    const matched = [];
                    features.forEach(feature => {
                        const relatedDataArray = relatedDataForAllFeatures[feature.attributes[layer.objectIdField]] || [];
                        const allRecords = [feature.attributes, ...relatedDataArray];
                        const anyMatch = allRecords.some(rec => doesFeatureMatchFilters(rec, dataType, years, period));
                        if (anyMatch) matched.push(feature);
                    });
                    return matched;
                }

                function doesFeatureMatchFilters(attributes, dataType, years, period) {
                    let match = true;

                    if (dataType !== "All") {
                        const val = attributes[DATA_TYPE_FIELD];
                        if (!val || val !== dataType) match = false;
                    }

                    if (match && years.length > 0 && !years.includes("All")) {
                        const val = attributes[YEAR_FIELD];
                        if (!val || !years.includes(val.toString())) match = false;
                    }

                    if (match && period !== "All") {
                        const val = attributes[PERIOD_FIELD];
                        if (!val || val !== period) match = false;
                    }

                    return match;
                }

                async function fetchRelatedData(layer, objectIds) {
                    const relatedDataMap = {};
                    if (!layer.relationships || layer.relationships.length === 0) {
                        return relatedDataMap;
                    }

                    const relationshipPromises = layer.relationships.map(async relationship => {
                        const relationshipQuery = new RelationshipQuery();
                        relationshipQuery.relationshipId = relationship.id;
                        relationshipQuery.objectIds = objectIds;
                        relationshipQuery.outFields = ["*"];
                        relationshipQuery.returnGeometry = false;

                        try {
                            const result = await layer.queryRelatedFeatures(relationshipQuery);
                            for (const objectId in result) {
                                if (!relatedDataMap[objectId]) relatedDataMap[objectId] = [];
                                relatedDataMap[objectId].push(...result[objectId].features.map(f => f.attributes));
                            }
                        } catch (error) {
                            console.error(`Error querying related features:`, error);
                        }
                    });

                    await Promise.all(relationshipPromises);
                    return relatedDataMap;
                }

                function displayAttributes(features) {
                    const attributeTable = document.getElementById("attributeTable");
                    const thead = attributeTable.querySelector("thead");
                    const tbody = attributeTable.querySelector("tbody");

                    thead.innerHTML = "";
                    tbody.innerHTML = "";

                    if (features.length === 0) {
                        const noDataRow = document.createElement("tr");
                        const noDataCell = document.createElement("td");
                        noDataCell.colSpan = 28;
                        noDataCell.textContent = "No features match the selected filters.";
                        noDataRow.appendChild(noDataCell);
                        tbody.appendChild(noDataRow);
                        currentHeadersToDisplay = [];
                        currentTableData = [];
                        return;
                    }

                    (async () => {
                        const layerObjectIdsMap = {};
                        features.forEach(feature => {
                            if (!layerObjectIdsMap[feature.layer.id]) {
                                layerObjectIdsMap[feature.layer.id] = [];
                            }
                            layerObjectIdsMap[feature.layer.id].push(feature.attributes[feature.layer.objectIdField]);
                        });

                        const allRelatedDataPromises = Object.keys(layerObjectIdsMap).map(async layerId => {
                            const layer = allLayers.find(l => l.id === layerId);
                            const objectIds = layerObjectIdsMap[layerId];
                            const relatedData = await fetchRelatedData(layer, objectIds);
                            return { layer, relatedData };
                        });

                        const allRelatedData = await Promise.all(allRelatedDataPromises);

                        const relatedDataMap = {};
                        allRelatedData.forEach(({ relatedData }) => {
                            for (const objectId in relatedData) {
                                if (!relatedDataMap[objectId]) {
                                    relatedDataMap[objectId] = [];
                                }
                                relatedDataMap[objectId].push(...relatedData[objectId]);
                            }
                        });

                        const headersSet = new Set();
                        const tableData = [];
                        const columnValues = {};

                        features.forEach(feature => {
                            const objectId = feature.attributes[feature.layer.objectIdField];
                            const relatedDataArray = relatedDataMap[objectId] || [];

                            const mainRecordMatches = doesFeatureMatchFilters(feature.attributes, currentDataType, currentYears, currentPeriod);
                            const matchingRelated = relatedDataArray.filter(r => doesFeatureMatchFilters(r, currentDataType, currentYears, currentPeriod));

                            if (matchingRelated.length === 0 && mainRecordMatches) {
                                const rowData = {};
                                for (const attr in feature.attributes) {
                                    headersSet.add(attr);
                                    rowData[attr] = feature.attributes[attr] ?? "N/A";
                                    if (!columnValues[attr]) columnValues[attr] = new Set();
                                    columnValues[attr].add(rowData[attr]);
                                }
                                tableData.push(rowData);
                            } else if (matchingRelated.length > 0) {
                                matchingRelated.forEach(relAttributes => {
                                    const rowData = {};
                                    for (const attr in feature.attributes) {
                                        headersSet.add(attr);
                                        rowData[attr] = feature.attributes[attr] ?? "N/A";
                                        if (!columnValues[attr]) columnValues[attr] = new Set();
                                        columnValues[attr].add(rowData[attr]);
                                    }
                                    for (const attr in relAttributes) {
                                        headersSet.add(attr);
                                        rowData[attr] = relAttributes[attr] ?? "N/A";
                                        if (!columnValues[attr]) columnValues[attr] = new Set();
                                        columnValues[attr].add(rowData[attr]);
                                    }
                                    tableData.push(rowData);
                                });
                            }
                        });

                        const allHeaders = Array.from(headersSet);

                        const fieldsToExclude = [
                            "OBJECTID", "Shape", "SHAPE_Length", "SHAPE_Area", "Intersection_IDs", "LocationID", "Intersection_ID",
                            "Longitude", "Latitude", "PopupInfo", "Names", "Traffic_DataCollection_Date", "Major_Streets", "Minor_Streets",
                            "City", "State", "Intersection_Type", "Leg_Type"
                        ];

                        let headersToDisplay = allHeaders.filter(attr => {
                            if (fieldsToExclude.includes(attr)) {
                                return false;
                            }
                            const values = columnValues[attr];
                            const allValuesNull = values.size === 1 && (values.has("N/A") || values.has(null) || values.has(undefined));
                            return !allValuesNull;
                        });

                        // Reorder columns so E, W, N, S appear just before EBL
                        const directionCols = ["E", "W", "N", "S"];
                        const eblIndex = headersToDisplay.indexOf("EBL");
                        if (eblIndex !== -1) {
                            const extractedDirections = directionCols.filter(d => headersToDisplay.includes(d));
                            extractedDirections.forEach(d => {
                                const idx = headersToDisplay.indexOf(d);
                                if (idx !== -1) {
                                    headersToDisplay.splice(idx, 1);
                                }
                            });
                            headersToDisplay.splice(eblIndex, 0, ...extractedDirections);
                        }

                        const headerRow = document.createElement("tr");
                        headersToDisplay.forEach((headerText, index) => {
                            const headerCell = document.createElement('th');
                            headerCell.innerHTML = `${headerText} <span class="sort-indicator">⇅</span>`;
                            headerCell.addEventListener("click", function () {
                                sortTable(attributeTable, index, this);
                            });
                            headerRow.appendChild(headerCell);
                        });
                        thead.appendChild(headerRow);

                        tableData.forEach(rowData => {
                            const row = document.createElement("tr");
                            headersToDisplay.forEach(header => {
                                const cell = document.createElement("td");
                                cell.textContent = rowData[header] || 'N/A';
                                row.appendChild(cell);
                            });
                            tbody.appendChild(row);
                        });

                        currentHeadersToDisplay = headersToDisplay;
                        currentTableData = tableData;
                    })();
                }

                function sortTable(table, columnIndex, header) {
                    const tbody = table.tBodies[0];
                    const rows = Array.from(tbody.rows);
                    const currentSort = header.dataset.sort === "asc" ? { asc: false } : { asc: true };
                    header.dataset.sort = currentSort.asc ? "asc" : "desc";

                    rows.sort((a, b) => {
                        const aText = a.cells[columnIndex].textContent.trim();
                        const bText = b.cells[columnIndex].textContent.trim();
                        const aNum = parseFloat(aText);
                        const bNum = parseFloat(bText);

                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return currentSort.asc ? aNum - bNum : bNum - aNum;
                        } else {
                            return currentSort.asc ? aText.localeCompare(bText) : bText.localeCompare(aText);
                        }
                    });

                    while (tbody.firstChild) {
                        tbody.removeChild(tbody.firstChild);
                    }

                    rows.forEach(row => tbody.appendChild(row));
                    updateSortIndicators(table, columnIndex, currentSort.asc);
                }

                function updateSortIndicators(table, sortedColumn, asc) {
                    const headers = table.tHead.rows[0].cells;
                    for (let i = 0; i < headers.length; i++) {
                        const indicator = headers[i].querySelector(".sort-indicator");
                        if (i === sortedColumn) {
                            indicator.textContent = asc ? "↑" : "↓";
                        } else {
                            indicator.textContent = "⇅";
                        }
                    }
                }

                function handleMapClick(event) {
                    view.hitTest(event).then(response => {
                        const result = response.results.find(r => r.graphic && r.graphic.layer && r.graphic.layer.type === "feature");
                        if (result) {
                            toggleFeatureSelection(result.graphic);
                        } else {
                            // Empty space: unselect all
                            selectedFeatures = [];
                            applyFilters();
                        }
                    });
                }

                function toggleFeatureSelection(feature) {
                    const objectIdField = feature.layer.objectIdField;
                    const objectId = feature.attributes[objectIdField];
                    const existingIndex = selectedFeatures.findIndex(f => f.attributes[objectIdField] === objectId);

                    if (existingIndex > -1) {
                        selectedFeatures.splice(existingIndex, 1);
                    } else {
                        selectedFeatures.push(feature);
                    }

                    applyFilters();
                }

                function generateReport() {
                    if (currentTableData.length === 0) {
                        alert("No features to report.");
                        return;
                    }

                    const format = document.getElementById("reportFormat").value;
                    if (format === "pdf") {
                        generatePDFReport();
                    } else {
                        generateCSVReport();
                    }
                }

                function generatePDFReport() {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'landscape'
                    });

                    doc.setFontSize(18);
                    doc.text("Traffic Analytics Report", 14, 20);

                    doc.setFontSize(12);
                    doc.text(`Generated on: ${new Date().toLocaleString()}`, 14, 30);

                    const headers = [currentHeadersToDisplay];
                    const body = currentTableData.map(row => currentHeadersToDisplay.map(h => row[h] || 'N/A'));

                    doc.autoTable({
                        head: headers,
                        body: body,
                        startY: 40,
                        theme: 'striped',
                        styles: { fontSize: 7, cellPadding: 1, overflow: 'linebreak' },
                        margin: 5,
                        tableWidth: 'auto'
                    });

                    doc.save("traffic_analytics_report.pdf");
                }

                function generateCSVReport() {
                    let csvContent = currentHeadersToDisplay.join(",") + "\n";
                    currentTableData.forEach(rowData => {
                        const row = currentHeadersToDisplay.map(h => {
                            let val = rowData[h];
                            if (val == null) val = 'N/A';
                            val = String(val);
                            const safeVal = val.replace(/"/g, '""');
                            return `"${safeVal}"`;
                        }).join(",");
                        csvContent += row + "\n";
                    });

                    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = url;
                    link.setAttribute("download", "traffic_analytics_report.csv");
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

                function waitForViewStable(view) {
                    return new Promise(resolve => {
                        if (!view.updating) {
                            resolve();
                            return;
                        }
                        const handle = view.watch("updating", (updating) => {
                            if (!updating) {
                                handle.remove();
                                resolve();
                            }
                        });
                    });
                }

                async function exportMapAsPDF() {
                    // If selected features exist, try to get their combined extent
                    let combinedExtent = null;
                    for (const f of selectedFeatures) {
                        if (f.geometry && f.geometry.extent) {
                            if (!combinedExtent) {
                                combinedExtent = f.geometry.extent.clone();
                            } else {
                                combinedExtent = combinedExtent.union(f.geometry.extent);
                            }
                        }
                    }

                    if (combinedExtent) {
                        await view.goTo(combinedExtent.expand(1.2));
                    }

                    await waitForViewStable(view);

                    const screenshot = await view.takeScreenshot({ width: 1400, height: 990 });

                    // Restore original viewpoint
                    if (originalViewpoint) {
                        await view.goTo(originalViewpoint);
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({
                        orientation: 'landscape'
                    });

                    doc.setFontSize(18);
                    doc.text("City of Walnut Creek - Traffic Map", 14, 10);

                    doc.setFontSize(12);
                    doc.text(`Exported on: ${new Date().toLocaleString()}`, 14, 18);

                    // Legend
                    doc.setFontSize(10);
                    doc.text("Legend:", 14, 23);

                    // Cyan highlight for selected features
                    doc.setFillColor(0, 255, 255);
                    doc.circle(16, 26, 2, 'F');
                    doc.text("Selected feature(s)", 22, 28);

                    // Brown symbol for intersections
                    doc.setFillColor(150, 75, 0);
                    doc.circle(16, 31, 2, 'F');
                    doc.text("Intersection", 22, 33);

                    // Add the screenshot image
                    doc.addImage(screenshot.data, "PNG", 9, 40, 224, 158.4);

                    doc.save("traffic_map.pdf");
                }
            });
        });
    </script>
</body>

</html>