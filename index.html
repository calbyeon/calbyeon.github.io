<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArcGIS Map with Filtered Layer Attribute Table and Reporting</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>
    <script src="https://js.arcgis.com/4.28/"></script>
    
    <style>
        html, body, #app-container {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #f8f8f8;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
        }
        #viewDiv {
            flex: 1;
            min-height: 0;
        }
        #featuresDiv {
            height: 40%;
            width: 100%;
            background-color: white;
            z-index: 10;
            box-sizing: border-box;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
            top: calc(100% - 40%); 
        }
        .features-inner {
            overflow: auto;
            height: 100%;
        }

        #filterDiv {
            position: absolute;
            top: 50px;
            right: 20px;
            z-index: 20;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 250px;
        }
        .attribute-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            table-layout: fixed; /* Ensures columns are evenly spaced */
        }

        .attribute-table th {
            position: sticky;
            top: 0; /* Stick to the top of the features-inner div */
            background-color: #f2f2f2;
            z-index: 2;
            text-align: left;
            font-weight: bold;
            border: 1px solid #ddd; /* Add border to headers */
            padding: 8px;          /* Add padding to headers */
            white-space: nowrap; /* Prevents header text wrapping */
            overflow: hidden;     /* Hides overflowing header text */
            text-overflow: ellipsis; /* Adds ellipsis to overflowing text */
            box-sizing: border-box; /* Ensure consistent sizing with borders and padding */
            cursor: pointer; /* Indicate that headers are clickable for sorting */
        }

        .attribute-table th, .attribute-table td {
            border: 1px solid #ddd;
            padding: 8px;
            box-sizing: border-box;
        }

        .attribute-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        #reportingDiv {
            position: absolute;
            top: 55px;
            left: 60px;
            z-index: 20;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #yearFilter {
            width: 100%;
            max-height: 100px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px;
            background-color: white;
        }
        #yearFilter option {
            padding: 5px;
        }
        #yearFilter option:checked {
            background-color: #e0e0e0;
            color: #000;
        }
        #yearFilter::-webkit-scrollbar {
            width: 8px;
        }
        #yearFilter::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #yearFilter::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #yearFilter::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Style for validation feedback */
        input:invalid {
            border-color: red;
        }
        input:valid {
            border-color: green;
        }
        /* Style for the street error message */
        #streetError {
            color: red;
            display: none;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header id="header">
            <div>City of Walnut Creek</div>
            <div>Traffic Analytics Map</div>
        </header>
        <div id="viewDiv"></div>
        <div id="featuresDiv">
            <div class="features-inner" id="featuresInnerDiv">
                <div class="features-content" id="featuresContentDiv">
                    <!-- The table will be inserted here dynamically -->
                </div>
            </div>
        </div>
    <div id="filterDiv">
        <label for="dataTypeFilter">Filter by Data Type:</label>
        <select id="dataTypeFilter">
            <option value="All">All</option>
            <option value="Bikes">Bikes</option>
            <option value="Intersection Info">Intersection Info</option>
            <option value="PHF">PHF</option>
            <option value="Pedestrian">Pedestrian</option>
            <option value="Heavy Vehicles">Heavy Vehicles</option>
            <option value="Turning Movement">Turning Movement</option>
        </select>
        <br><br>
        <label for="yearFilter">Filter by Year:</label>
        <select id="yearFilter" multiple size="5">
            <option value="All">All</option>
            <!-- Options populated dynamically -->
        </select>
        <br><br>
        <label for="periodFilter">Filter by Period:</label>
        <select id="periodFilter">
            <option value="All">All</option>
            <option value="AM">AM</option>
            <option value="MID">MID</option>
            <option value="PM">PM</option>
        </select>
        <br><br>
        <label for="streetFilter">Filter by Street:</label>
        <input list="streetNames" id="streetFilter" placeholder="Enter street name" required>
        <datalist id="streetNames">
            <!-- Street options will be populated dynamically -->
        </datalist>
        <span id="streetError">Please select a valid street from the suggestions.</span>
    </div>
    <div id="reportingDiv">
        <button id="generateReportBtn">Generate Report</button>
        <button id="printMapBtn">Print Map</button>
    </div>
    
    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener("DOMContentLoaded", function() {
            // Load the ArcGIS modules
            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/rest/support/Query",
                "esri/Graphic",
                "esri/geometry/Extent",
                "esri/geometry/support/webMercatorUtils"
            ], function(Map, MapView, FeatureLayer, Query, Graphic, Extent, webMercatorUtils) {
                let map, view, selectedFeatures = [];
                let selectedLocations = [];

                // Function to populate the street datalist with unique street names
                function populateStreetDatalist() {
                    const streetSet = new Set(); // To store unique normalized street names
                    const streetList = []; // To store street names with original casing

                    // Iterate through each layer to extract street names
                    map.layers.forEach(function(layer) {
                        if (layer instanceof FeatureLayer) {
                            // Query distinct Major_Street and Minor_Street values
                            const query = layer.createQuery();
                            query.where = "1=1"; // Adjust if necessary
                            query.outFields = ["Major_Street", "Minor_Street"];
                            query.returnDistinctValues = true;
                            query.returnGeometry = false;

                            layer.queryFeatures(query)
                                .then(function(result) {
                                    result.features.forEach(function(feature) {
                                        const majorStreet = feature.attributes.Major_Street;
                                        const minorStreet = feature.attributes.Minor_Street;

                                        // Process Major_Street
                                        if (majorStreet && majorStreet.trim() !== "") {
                                            const normalizedMajor = normalizeStreetName(majorStreet);
                                            if (!streetSet.has(normalizedMajor)) {
                                                streetSet.add(normalizedMajor);
                                                streetList.push(majorStreet.trim());
                                            }
                                        }

                                        // Process Minor_Street
                                        if (minorStreet && minorStreet.trim() !== "") {
                                            const normalizedMinor = normalizeStreetName(minorStreet);
                                            if (!streetSet.has(normalizedMinor)) {
                                                streetSet.add(normalizedMinor);
                                                streetList.push(minorStreet.trim());
                                            }
                                        }
                                    });

                                    // After collecting all unique street names, populate the datalist
                                    const datalist = document.getElementById("streetNames");
                                    datalist.innerHTML = ""; // Clear existing options
                                    streetList.sort(); // Sort alphabetically
                                    streetList.forEach(function(street) {
                                        const option = document.createElement("option");
                                        option.value = street;
                                        datalist.appendChild(option);
                                    });
                                })
                                .catch(function(error) {
                                    console.error("Error fetching street names from layer:", layer.title, error);
                                });
                        }
                    });
                }

                // Initialize the map
                function initMap() {
                    map = new Map({
                        basemap: "streets-navigation-vector"
                    });

                    view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-122.063686, 37.901657],
                        zoom: 13
                    });

                    const baseUrl = "https://services2.arcgis.com/AhHMUmDoudKVXiUl/arcgis/rest/services/Traffic_Analysis_PEAK_WFL1/FeatureServer";
                    const layerIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101];

                    layerIds.forEach(function(id) {
                        const layer = new FeatureLayer({
                            url: `${baseUrl}/${id}`,
                            outFields: ["*"]
                        });
                        map.add(layer);
                    });

                    // Add event listener for map click
                    view.on("click", function(event) {
                        view.hitTest(event).then(function(response) {
                            const layerResult = response.results.filter(function(result) {
                                return result.graphic && result.graphic.layer && result.graphic.layer.type === "feature";
                            })[0];

                            if (layerResult) {
                                toggleLocationSelection(layerResult.graphic.layer);
                            } else {
                                // No features clicked; clear selections
                                selectedLocations = [];
                                view.graphics.removeAll();
                                displayAttributes([]);
                                updateLocationSelectionUI();
                            }
                        });
                    });

                    // Add event listener for map load
                    view.when(function() {
                        console.log("Map loaded successfully. Click on a point to begin.");
                        populateStreetDatalist(); // Populate streets after map is ready
                    }).catch(function(error) {
                        console.error("Error loading the map:", error);
                    });
                }

                initMap();

                // Function to validate and provide visual feedback for street input
                function validateStreetInput() {
                    const streetInput = document.getElementById("streetFilter");
                    const datalist = document.getElementById("streetNames");
                    const options = datalist.options;
                    const enteredValue = streetInput.value.trim().toLowerCase();
                    let isValid = false;

                    for (let i = 0; i < options.length; i++) {
                        if (normalizeStreetName(options[i].value) === normalizeStreetName(enteredValue)) {
                            isValid = true;
                            break;
                        }
                    }

                    const streetError = document.getElementById("streetError");

                    if (isValid || enteredValue === "") {
                        streetInput.style.borderColor = "green";
                        streetError.style.display = "none";
                        streetInput.setCustomValidity("");
                    } else {
                        streetInput.style.borderColor = "red";
                        streetError.style.display = "block";
                        streetInput.setCustomValidity("Please select a valid street from the suggestions.");
                    }
                }

                // Function to handle Enter key press for selecting the top autocomplete option
                function handleEnterKey(event) {
                    if (event.key === "Enter") {
                        const streetInput = event.target;
                        const datalist = document.getElementById("streetNames");
                        const options = Array.from(datalist.options).map(option => normalizeStreetName(option.value));
                        const enteredValue = normalizeStreetName(streetInput.value);

                        // Check if entered value matches any option
                        if (!options.includes(enteredValue) && options.length > 0) {
                            // Prevent default action
                            event.preventDefault();

                            // Set the input value to the first suggestion
                            streetInput.value = datalist.options[0].value;
                            validateStreetInput(); // Update validation visuals
                            applyFilters(); // Apply filters after setting the value
                        }
                    }
                }

                // Function to toggle location selection
                function toggleLocationSelection(layer) {
                    const index = selectedLocations.findIndex(l => l.id === layer.id);
                    if (index > -1) {
                        selectedLocations.splice(index, 1);
                    } else {
                        selectedLocations.push(layer);
                    }
                    updateLocationSelectionUI();
                    querySelectedLocations();
                }

                // Function to update location selection UI
                function updateLocationSelectionUI() {
                    console.log("Selected locations:", selectedLocations.length);
                    // You can add more UI updates here, like updating a list of selected locations
                }

                // Function to query selected locations
                function querySelectedLocations() {
                    const promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        const allFeatures = results.flat();
                        displayAttributes(allFeatures);
                        highlightFeatures(allFeatures);
                    }).catch(function(error) {
                        console.error("Error querying selected locations:", error);
                    });
                }

                // Function to build where clause based on filters
                function buildWhereClause(layer) {
                    const whereClause = [];
                    const dataType = document.getElementById("dataTypeFilter").value;
                    const years = getSelectedYears();
                    const period = document.getElementById("periodFilter").value;
                    const street = document.getElementById("streetFilter").value.trim();

                    let hasAllRequiredFields = true;

                    // Check for Data_Type field
                    if (dataType !== "All") {
                        const dataTypeField = layer.fields.find(f => f.name === "Data_Type");
                        if (dataTypeField) {
                            whereClause.push(`Data_Type = '${dataType}'`);
                        } else {
                            hasAllRequiredFields = false;
                        }
                    }

                    // Check for Year field
                    if (years.length > 0 && !years.includes("All")) {
                        const yearField = layer.fields.find(f => f.name === "Year");
                        if (yearField) {
                            let yearValuesExpression = "";
                            if (yearField.type === "small-integer" || yearField.type === "integer") {
                                // Year is numeric, do not use quotes
                                yearValuesExpression = `Year IN (${years.join(",")})`;
                            } else {
                                // Year is string, wrap values in single quotes
                                yearValuesExpression = `Year IN (${years.map(year => `'${year}'`).join(",")})`;
                            }
                            whereClause.push(yearValuesExpression);
                        } else {
                            hasAllRequiredFields = false;
                        }
                    }

                    // Check for Period field
                    if (period !== "All") {
                        const periodField = layer.fields.find(f => f.name === "Period");
                        if (periodField) {
                            whereClause.push(`Period = '${period}'`);
                        } else {
                            hasAllRequiredFields = false;
                        }
                    }

                    // Check for Major_Street and Minor_Street fields
                    if (street && street !== "All") {
                        const majorStreetField = layer.fields.find(f => f.name === "Major_Street");
                        const minorStreetField = layer.fields.find(f => f.name === "Minor_Street");
                        if (majorStreetField || minorStreetField) {
                            const streetConditions = [];
                            if (majorStreetField) {
                                streetConditions.push(`Major_Street LIKE '%${street}%'`);
                            }
                            if (minorStreetField) {
                                streetConditions.push(`Minor_Street LIKE '%${street}%'`);
                            }
                            // Add parentheses around street conditions
                            whereClause.push(`(${streetConditions.join(" OR ")})`);
                        } else {
                            hasAllRequiredFields = false;
                        }
                    }

                    if (!hasAllRequiredFields) {
                        // Exclude this layer if it doesn't have required fields
                        console.warn(`Excluding layer '${layer.title}' due to missing required fields.`);
                        return ['1=0'];
                    }

                    return whereClause;
                }

                // Function to get selected years
                function getSelectedYears() {
                    const yearFilter = document.getElementById("yearFilter");
                    const selectedYears = Array.from(yearFilter.selectedOptions).map(option => option.value);
                    return selectedYears.includes("All") ? ["All"] : selectedYears;
                }

                // Function to query features from a layer based on filters
                function queryFeatures(layer) {
                    const query = new Query();
                    const whereClause = buildWhereClause(layer);

                    query.where = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";
                    query.outFields = ["*"];
                    query.returnGeometry = true;

                    return layer.queryFeatures(query).then(function(result) {
                        return result.features;
                    }).catch(function(error) {
                        console.error(`Error querying features from layer '${layer.title}':`, error);
                        return [];
                    });
                }

                // Function to display attributes in the featuresDiv
                function displayAttributes(features) {
                    const featuresContentDiv = document.getElementById("featuresContentDiv");
                    featuresContentDiv.innerHTML = ""; // Clear previous content

                    if (features.length === 0) {
                        featuresContentDiv.innerHTML = "No features found in this layer.";
                        return;
                    }

                    const table = document.createElement("table");
                    table.className = "attribute-table";

                    // Determine which columns have non-null values and are not excluded
                    const columnsWithValues = {};
                    const excludedFields = ["PopupInfo", "ObjectID", "PEAK_ID", "Latitude", "Longitude", "Intersection_ID", "Intersection_Type", "Leg_Type","Traffic_DataCollection_Date", "City","State", "Intersection_Value","E","N","S","W"];
                    features.forEach(function(feature) {
                        for (let attr in feature.attributes) {
                            if (feature.attributes.hasOwnProperty(attr) && 
                                feature.attributes[attr] !== null && 
                                !excludedFields.includes(attr)) {
                                columnsWithValues[attr] = true;
                            }
                        }
                    });

                    // Create header row
                    const headerRow = table.createTHead().insertRow();
                    const headers = [];
                    for (let attr in features[0].attributes) {
                        if (features[0].attributes.hasOwnProperty(attr) && 
                            columnsWithValues[attr] && 
                            !excludedFields.includes(attr)) {
                            headers.push(attr);
                            const headerCell = document.createElement("th");
                            headerCell.innerHTML = `${attr} <span class="sort-indicator">⇅</span>`;
                            
                            // Use let to capture the current value of attr
                            headerCell.addEventListener("click", function() {
                                const columnIndex = headers.indexOf(attr);
                                sortTable(table, columnIndex, this);
                            });
                            headerRow.appendChild(headerCell);
                        }
                    }

                    // Create tbody
                    const tbody = table.createTBody();
                    features.forEach(function(feature) {
                        const dataRow = tbody.insertRow();
                        headers.forEach(function(attr) {
                            const dataCell = dataRow.insertCell();
                            dataCell.innerHTML = feature.attributes[attr] !== null ? feature.attributes[attr] : "N/A";
                        });
                    });

                    featuresContentDiv.appendChild(table); // Append the table to the content div
                }

                let currentSort = { index: -1, asc: true };

                // Function to sort the table based on column index
                function sortTable(table, columnIndex, headerCell) {
                    if (columnIndex === -1) {
                        console.error("Invalid column index:", columnIndex);
                        return;
                    }

                    const tbody = table.tBodies[0];
                    const rows = Array.from(tbody.rows);

                    if (currentSort.index === columnIndex) {
                        currentSort.asc = !currentSort.asc;
                    } else {
                        currentSort.index = columnIndex;
                        currentSort.asc = true;
                    }

                    rows.sort(function(a, b) {
                        const aCell = a.cells[columnIndex];
                        const bCell = b.cells[columnIndex];

                        // Safety check
                        if (!aCell || !bCell) {
                            console.warn("One of the cells is undefined:", aCell, bCell);
                            return 0;
                        }

                        const aText = aCell.textContent.trim();
                        const bText = bCell.textContent.trim();

                        // Attempt to parse as numbers
                        const aNum = parseFloat(aText.replace(/[^0-9.-]+/g,""));
                        const bNum = parseFloat(bText.replace(/[^0-9.-]+/g,""));

                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return currentSort.asc ? aNum - bNum : bNum - aNum;
                        } else {
                            return currentSort.asc ? aText.localeCompare(bText) : bText.localeCompare(aText);
                        }
                    });

                    // Remove existing rows
                    while (tbody.firstChild) {
                        tbody.removeChild(tbody.firstChild);
                    }

                    // Re-add sorted rows
                    rows.forEach(function(row) {
                        tbody.appendChild(row);
                    });

                    // Update sort indicators
                    updateSortIndicators(table, columnIndex, currentSort.asc);
                }

                // Function to update sort indicators in the table headers
                function updateSortIndicators(table, sortedColumn, asc) {
                    const headers = table.tHead.rows[0].cells;
                    for (let i = 0; i < headers.length; i++) {
                        const indicator = headers[i].querySelector(".sort-indicator");
                        if (i === sortedColumn) {
                            indicator.textContent = asc ? "↑" : "↓";
                        } else {
                            indicator.textContent = "⇅";
                        }
                    }
                }

                // Function to highlight features on the map
                function highlightFeatures(features) {
                    view.graphics.removeAll();
                    features.forEach(function(feature) {
                        const graphic = new Graphic({
                            geometry: feature.geometry,
                            symbol: {
                                type: "simple-marker",
                                style: "circle",
                                color: [255, 255, 0, 0.8],
                                size: "12px",
                                outline: {
                                    color: [255, 255, 0, 0.8],
                                    width: "2px"
                                }
                            }
                        });
                        view.graphics.add(graphic);
                    });
                }

                // Function to initially load all unique years into the year filter
                function initializeYearFilter() {
                    const yearFilter = document.getElementById("yearFilter");
                    yearFilter.innerHTML = ""; // Clear existing options

                    const allOption = document.createElement("option");
                    allOption.value = "All";
                    allOption.text = "All";
                    yearFilter.appendChild(allOption);

                    const uniqueYears = new Set();

                    // Query each layer to collect all unique years without applying filters
                    const yearPromises = map.layers.map(layer => {
                        if (layer instanceof FeatureLayer) {
                            const query = layer.createQuery();
                            query.where = "1=1"; // No filter initially
                            query.outFields = ["Year"];
                            query.returnDistinctValues = true;

                            return layer.queryFeatures(query).then(result => {
                                result.features.forEach(feature => {
                                    const year = feature.attributes["Year"];
                                    if (year) uniqueYears.add(year);
                                });
                            }).catch(error => console.error("Error querying layer for unique years:", error));
                        }
                    });

                    // Populate the year filter dropdown with all unique years
                    Promise.all(yearPromises).then(() => {
                        Array.from(uniqueYears).sort().forEach(year => {
                            const option = document.createElement("option");
                            option.value = year;
                            option.text = year;
                            yearFilter.appendChild(option);
                        });
                    });
                }

                // Function to dynamically update year filter options based on active filters
                function updateYearFilterOptions() {
                    const selectedYears = new Set();
                    const yearFilter = document.getElementById("yearFilter");
                    const previousSelections = Array.from(yearFilter.selectedOptions).map(option => option.value);

                    yearFilter.innerHTML = ""; // Clear existing options

                    const allOption = document.createElement("option");
                    allOption.value = "All";
                    allOption.text = "All";
                    yearFilter.appendChild(allOption);

                    // Build where clause from current active filters (street and data type)
                    const dataType = document.getElementById("dataTypeFilter").value;
                    const street = document.getElementById("streetFilter").value.trim();
                    const whereClause = [];

                    if (dataType !== "All") {
                        whereClause.push(`Data_Type = '${dataType}'`);
                    }
                    if (street && street !== "All") {
                        whereClause.push(`Major_Street LIKE '%${street}%' OR Minor_Street LIKE '%${street}%'`);
                    }
                    const filterExpression = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";

                    // Query each layer to collect unique years based on current filter expression
                    const yearPromises = map.layers.map(layer => {
                        if (layer instanceof FeatureLayer) {
                            const query = layer.createQuery();
                            query.where = filterExpression;
                            query.outFields = ["Year"];
                            query.returnDistinctValues = true;

                            return layer.queryFeatures(query).then(result => {
                                result.features.forEach(feature => {
                                    const year = feature.attributes["Year"];
                                    if (year) selectedYears.add(year);
                                });
                            }).catch(error => console.error("Error querying layer for unique years:", error));
                        }
                    });

                    // Populate year filter based on filter-specific unique years
                    Promise.all(yearPromises).then(() => {
                        Array.from(selectedYears).sort().forEach(year => {
                            const option = document.createElement("option");
                            option.value = year;
                            option.text = year;
                            yearFilter.appendChild(option);
                        });

                        // Restore previous selections if they are still valid
                        Array.from(yearFilter.options).forEach(option => {
                            if (previousSelections.includes(option.value)) {
                                option.selected = true;
                            }
                        });
                    });
                }

                // Initialize all years in the year filter on page load
                initializeYearFilter();

                // Consolidated event listener for the streetFilter
                document.getElementById("streetFilter").addEventListener("input", function() {
                    validateStreetInput();
                    updateYearFilterOptions();
                    applyFilters();
                });

                document.getElementById("streetFilter").addEventListener("change", validateStreetInput);
                document.getElementById("streetFilter").addEventListener("keydown", handleEnterKey);

                document.getElementById("dataTypeFilter").addEventListener("change", function() {
                    updateYearFilterOptions();
                    applyFilters();
                });

                // Add event listeners for other filters
                document.getElementById("dataTypeFilter").addEventListener("change", applyFilters);
                document.getElementById("yearFilter").addEventListener("change", applyFilters);
                document.getElementById("periodFilter").addEventListener("change", applyFilters);

                // Function to apply filters and update layer visibility
                function applyFilters() {
                    // For each layer, build and apply definitionExpression
                    map.layers.forEach(function(layer) {
                        if (layer instanceof FeatureLayer) {
                            const whereClause = buildWhereClause(layer);
                            const definitionExpression = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";
                            console.log(`Applying filters to layer '${layer.title}' with definitionExpression: ${definitionExpression}`);
                            layer.definitionExpression = definitionExpression;
                        }
                    });

                    // Re-query selected locations with updated filters
                    let filteredFeatures = [];

                    selectedLocations.forEach(function(layer) {
                        if (!(layer instanceof FeatureLayer)) return; // Skip non-feature layers

                        const whereClause = buildWhereClause(layer);
                        const definitionExpression = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";

                        const query = new Query();
                        query.where = definitionExpression; // Apply the updated filter criteria
                        query.returnGeometry = true;
                        query.outFields = ["*"];

                        layer.queryFeatures(query).then(function(result) {
                            filteredFeatures = filteredFeatures.concat(result.features);

                            if (filteredFeatures.length === 0) {
                                selectedLocations = [];
                                displayAttributes([]); // Clear the attribute display if no matches
                                view.graphics.removeAll(); // Remove any highlighted graphics
                            } else {
                                displayAttributes(filteredFeatures);
                                highlightFeatures(filteredFeatures);
                            }
                        }).catch(function(error) {
                            console.error("Query failed: ", error);
                        });
                    });
                }

                // Function to print the map as PDF
                function printMap(features) {
                    if (features.length === 0) {
                        alert("No features selected. Please select features first.");
                        return;
                    }

                    let extent = null;
                    const validFeatures = features.filter(function(feature) {
                        return feature.geometry;
                    });

                    if (validFeatures.length === 0) {
                        alert("No valid geometries found in the selected features. Unable to print map.");
                        return;
                    }

                    validFeatures.forEach(function(feature) {
                        if (feature.geometry.type === "point") {
                            const point = feature.geometry;
                            const buffer = 1;
                            const pointExtent = new Extent({
                                xmin: point.x - buffer,
                                ymin: point.y - buffer,
                                xmax: point.x + buffer,
                                ymax: point.y + buffer,
                                spatialReference: view.spatialReference
                            });
                            
                            if (extent) {
                                extent = extent.union(pointExtent);
                            } else {
                                extent = pointExtent;
                            }
                        } else if (feature.geometry.extent) {
                            if (extent) {
                                extent = extent.union(feature.geometry.extent);
                            } else {
                                extent = feature.geometry.extent.clone();
                            }
                        }
                    });

                    if (!extent) {
                        alert("Unable to determine map extent. Please try again.");
                        return;
                    }

                    // Adjust the zoom level more precisely
                    view.goTo(extent.expand(999)).then(function() {
                        // Add a delay before taking the screenshot
                        setTimeout(function() {
                            view.takeScreenshot({ 
                                format: "jpg",
                                width: 900,
                                height: 1200
                            }).then(function(screenshot) {
                                const image = new Image();
                                image.src = screenshot.dataUrl;

                                image.onload = function() {
                                    const doc = new jspdf.jsPDF({
                                        orientation: "portrait",
                                        unit: "mm",
                                        format: "a4"
                                    });

                                    doc.setFontSize(18);
                                    doc.text("Traffic Analytics Map", 105, 15, { align: "center" });

                                    const pageWidth = doc.internal.pageSize.getWidth();
                                    const pageHeight = doc.internal.pageSize.getHeight();
                                    const margin = 10;
                                    const bottomY = pageHeight - 20; // Start 20mm from bottom
                                    const maxWidth = pageWidth - (2 * margin);
                                    const maxHeight = pageHeight - 50;

                                    const imgRatio = image.height / image.width;
                                    const pageRatio = maxHeight / maxWidth;

                                    let imgWidth, imgHeight;

                                    if (imgRatio > pageRatio) {
                                        imgHeight = maxHeight;
                                        imgWidth = imgHeight / imgRatio;
                                    } else {
                                        imgWidth = maxWidth;
                                        imgHeight = imgWidth * imgRatio;
                                    }

                                    const xOffset = (pageWidth - imgWidth) / 2;

                                    doc.addImage(image, "JPEG", xOffset, 25, imgWidth, imgHeight);
                                    // Scalebar
                                    doc.setLineWidth(0.5);
                                    doc.line(margin, bottomY, margin + 50, bottomY);
                                    doc.setFontSize(8);
                                    doc.text("0", margin, bottomY + 5);
                                    doc.text("500 m", margin + 40, bottomY + 5);
                                    // Legend
                                    doc.setFontSize(10);
                                    doc.text("Legend", pageWidth - margin - 40, bottomY);
                                    doc.setFillColor(255, 255, 0);
                                    doc.circle(pageWidth - margin - 35, bottomY + 7, 2, "F");
                                    doc.setFontSize(8);
                                    doc.text("Selected Location", pageWidth - margin - 30, bottomY + 8);
                                    // Date and filters
                                    doc.setFontSize(8);
                                    const dateText = `Date: ${new Date().toLocaleDateString()}`;
                                    const filterText = `Filters: ${document.getElementById("dataTypeFilter").value}, ${document.getElementById("yearFilter").value}, ${document.getElementById("periodFilter").value}`;
                                    
                                    doc.text(dateText, margin, pageHeight - 10);
                                    doc.text(filterText, margin, pageHeight - 5);

                                    doc.save("traffic_analytics_map.pdf");
                                };
                            }).catch(function(error) {
                                console.error("Error taking screenshot:", error);
                                alert("An error occurred while taking the screenshot. Please try again.");
                            });
                        }, 2000); // 2 second delay to ensure map is fully rendered
                    }).catch(function(error) {
                        console.error("Error while zooming to extent:", error);
                        alert("An error occurred while preparing the map for print. Please try again.");
                    });
                }

                // Function to normalize street names
                function normalizeStreetName(street) {
                    return street.trim().toLowerCase()
                                 .replace(/\./g, "")
                                 .replace(/\bstreet\b/g, "st")
                                 .replace(/\bavenue\b/g, "ave")
                                 .replace(/\broad\b/g, "rd")
                                 .replace(/\bdrive\b/g, "dr")
                                 .replace(/\bsuite\b/g, "ste");
                }

                // Function to display attributes in the featuresDiv (already defined above)
                // ... (No changes needed)

                // Function to generate PDF report
                function generatePDF(features) {
                    if (features.length === 0) {
                        alert("No data available to generate report.");
                        return;
                    }

                    // Access jsPDF from the global namespace
                    const { jsPDF } = window.jspdf;

                    const doc = new jsPDF({
                        orientation: "portrait",
                        unit: "mm",
                        format: "a4"
                    });

                    doc.setFontSize(18);
                    doc.text("Traffic Analytics Report", 105, 15, { align: "center" });

                    doc.setFontSize(12);
                    doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 14, 25);

                    // Fields to potentially include
                    const potentialFields = [
                        // Existing fields
                        "Data_Type", "Year", "Period", "Major_Street", "Minor_Street",
                        // Additional fields you specified
                        "EBL", "EBT", "EBR",
                        "WBL", "WBT", "WBR",
                        "NBL", "NBT", "NBR",
                        "SBL", "SBT",
                        "EB", "WB", "NB", "SB"
                    ];

                    // Determine which fields have at least one non-"N/A" value
                    const includedFields = potentialFields.filter(function(field) {
                        return features.some(function(feature) {
                            const value = feature.attributes[field];
                            return value !== null && value !== undefined && value !== "N/A" && value !== "";
                        });
                    });

                    if (includedFields.length === 0) {
                        alert("No valid data available to generate report with the specified fields.");
                        return;
                    }

                    // Prepare the table data
                    const tableData = features.map(function(feature) {
                        const rowData = {};
                        includedFields.forEach(function(field) {
                            const value = feature.attributes[field];
                            rowData[field] = (value !== null && value !== undefined && value !== "") ? value : "N/A";
                        });
                        return rowData;
                    });

                    // Add the table to the PDF
                    doc.autoTable({
                        head: [includedFields],
                        body: tableData.map(row => includedFields.map(field => row[field])),
                        startY: 35,
                        theme: 'striped',
                        styles: { fontSize: 10 }
                    });

                    // Save the PDF
                    doc.save("traffic_analytics_report.pdf");
                }

                // Generate Report Button
                document.getElementById("generateReportBtn").addEventListener("click", function() {
                    if (selectedLocations.length === 0) {
                        alert("No locations selected. Please select locations for the report.");
                        return;
                    }

                    const promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        const allFeatures = results.flat();
                        generatePDF(allFeatures);
                    }).catch(function(error) {
                        console.error("Error generating report:", error);
                        alert("An error occurred while generating the report. Please try again.");
                    });
                });

                // Print Map Button
                document.getElementById("printMapBtn").addEventListener("click", function() {
                    if (selectedLocations.length === 0) {
                        alert("No locations selected. Please select locations first.");
                        return;
                    }

                    const promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        const allFeatures = results.flat();
                        printMap(allFeatures);
                    }).catch(function(error) {
                        console.error("Error printing map:", error);
                        alert("An error occurred while printing the map. Please try again.");
                    });
                });
            });
        });
    </script>
</body>
</html>
