<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArcGIS Map with Filtered Layer Attribute Table and Reporting</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>
    <script src="https://js.arcgis.com/4.28/"></script>
    
    <style>
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            background-color: #f8f8f8;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
        }
        #viewDiv {
            flex: 1;
            min-height: 0;
        }
        #featuresDiv {
            height: 40%;
            width: 100%;
            background-color: white;
            z-index: 10;
            overflow: auto;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
        }
        #filterDiv {
            position: absolute;
            top: 50px;
            right: 20px;
            z-index: 20;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 250px;
        }
        .attribute-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .attribute-table th, .attribute-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .attribute-table th {
            background-color: #f2f2f2;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 1;
            cursor: pointer;
        }
        .attribute-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        #reportingDiv {
            position: absolute;
            top: 50px;
            left: 20px;
            z-index: 20;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #yearFilter {
            width: 100%;
            max-height: 100px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 5px;
            background-color: white;
        }
        #yearFilter option {
            padding: 5px;
        }
        #yearFilter option:checked {
            background-color: #e0e0e0;
            color: #000;
        }
        #yearFilter::-webkit-scrollbar {
            width: 8px;
        }
        #yearFilter::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        #yearFilter::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        #yearFilter::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Autocomplete container */
        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 1000;
            /* Position the autocomplete items to be the same width as the container: */
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background-color: white;
        }
        /* Style each autocomplete item */
        .autocomplete-item {
            padding: 10px;
            cursor: pointer;
        }
        /* When hovering an item: */
        .autocomplete-item:hover {
            background-color: #e9e9e9;
        }
        /* Style for validation feedback */
        input:invalid {
            border-color: red;
        }
        input:valid {
            border-color: green;
        }
        /* Style for the street error message */
        #streetError {
            color: red;
            display: none;
            font-size: 12px;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header id="header">
            <div>City of Walnut Creek</div>
            <div>Traffic Analytics Map</div>
        </header>
        <div id="viewDiv"></div>
        <div id="featuresDiv"></div>
    </div>
    <div id="filterDiv">
        <label for="dataTypeFilter">Filter by Data Type:</label>
        <select id="dataTypeFilter">
            <option value="All">All</option>
            <option value="Bikes">Bikes</option>
            <option value="Intersection Info">Intersection Info</option>
            <option value="PHF">PHF</option>
            <option value="Pedestrian">Pedestrian</option>
            <option value="Heavy Vehicles">Heavy Vehicles</option>
            <option value="Turning Movement">Turning Movement</option>
        </select>
        <br><br>
        <label for="yearFilter">Filter by Year:</label>
        <select id="yearFilter" multiple size="5">
            <option value="All">All</option>
            <!-- Options populated dynamically -->
        </select>
        <br><br>
        <label for="periodFilter">Filter by Period:</label>
        <select id="periodFilter">
            <option value="All">All</option>
            <option value="AM">AM</option>
            <option value="MID">MID</option>
            <option value="PM">PM</option>
        </select>
        <br><br>
        <label for="streetFilter">Filter by Street:</label>
        <div style="position: relative;">
            <input type="text" id="streetFilter" placeholder="Enter street name" autocomplete="off" required>
            <div id="autocomplete-list" class="autocomplete-items"></div>
        </div>
        <span id="streetError">Please select a valid street from the suggestions.</span>
    </div>
    <div id="reportingDiv">
        <button id="generateReportBtn">Generate Report</button>
        <button id="printMapBtn">Print Map</button>
    </div>
    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener("DOMContentLoaded", function() {
            // Load the ArcGIS modules
            var jsPDF;
            require(["esri/config"], function(esriConfig) {
                esriConfig.apiKey = "AAPTxy8BH1VEsoebNVZXo8HurLui_STsjJZwVQToLsCDPQx7ohZyuOoGMcsvIkId4vJlUZcHaijwA7et5cSa91cib9PykJP7_7MR99iFaH6AtJvyDH8XA2oGolZnnzZIkb-fN-7tTH3l2KZwKC_cca_VYZIR3e-pdkpV-xypBdv6E5haJpp0jj0mrm1OJRdzE_EGT4wQBEPYKhS5xvKcAT9NmnBCaaDcaaShUVMyqk87XOxm2ICjG0KPrzdlFl1prtcrAT1_Npd6rvJT";
            });
            require([
                "esri/Map",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/rest/support/Query",
                "esri/Graphic",
                "esri/geometry/Extent",
                "esri/rest/locator",
                "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
            ], function(Map, MapView, FeatureLayer, Query, Graphic, Extent, jspdf, locator) {

                var map, view, currentLayer, selectedFeatures = [];
                jsPDF = jspdf.jsPDF;

                let selectedLocations = [];

                // Function to normalize street names
                function normalizeStreetName(street) {
                    return street.trim().toLowerCase()
                                 .replace(/\./g, "")
                                 .replace(/\bstreet\b/g, "st")
                                 .replace(/\bavenue\b/g, "ave")
                                 .replace(/\broad\b/g, "rd")
                                 .replace(/\bdrive\b/g, "dr")
                                 .replace(/\bsuite\b/g, "ste");
                }

                // Function to populate the street datalist with unique street names using Locator service
                function setupAutocomplete() {
                        const streetInput = document.getElementById("streetFilter");
                        const autocompleteList = document.getElementById("autocomplete-list");
                        const locator = new Locator({
                            url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer"
                        });

                        streetInput.addEventListener("input", function() {
                            const query = streetInput.value.trim();
                            if (!query) {
                                autocompleteList.innerHTML = "";
                                return;
                            }

                            locator.suggestLocations({
                                url: serviceUrl,
                                text: query,
                                maxSuggestions: 5,
                                location: view.center,
                                maxDistance: 50000, // Search within 50 km
                                categories: ["Address", "Street Name"]
                            }).then(function(suggestions) {
                                autocompleteList.innerHTML = "";
                                suggestions.forEach(function(suggestion) {
                                    const item = document.createElement("div");
                                    item.classList.add("autocomplete-item");
                                    item.textContent = suggestion.text;
                                    item.addEventListener("click", function() {
                                        streetInput.value = suggestion.text;
                                        autocompleteList.innerHTML = "";
                                        validateStreetInput();
                                        applyFilters();
                                    });
                                    autocompleteList.appendChild(item);
                                });
                            }).catch(function(error) {
                                console.error("Error fetching suggestions:", error);
                            });
                        });

                        // Close the autocomplete list when clicking outside
                        document.addEventListener("click", function(e) {
                            if (e.target !== streetInput) {
                                autocompleteList.innerHTML = "";
                            }
                        });
                    
                }

                // Function to initialize the map
                function initMap() {
                    map = new Map({
                        basemap: "streets-navigation-vector"
                    });

                    view = new MapView({
                        container: "viewDiv",
                        map: map,
                        center: [-122.063686, 37.901657],
                        zoom: 13
                    });

                    var baseUrl = "https://services2.arcgis.com/AhHMUmDoudKVXiUl/arcgis/rest/services/PEAK_Hour_Traffic_Analytics_WFL7/FeatureServer/";
                    var layerIds = [207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 0];

                    layerIds.forEach(function(id) {
                        var layer = new FeatureLayer({
                            url: baseUrl + id,
                            outFields: ["*"]
                        });
                        map.add(layer);
                    });

                    // Add event listener for map click
                    view.on("click", function(event) {
                        view.hitTest(event).then(function(response) {
                            var layerResult = response.results.filter(function(result) {
                                return result.graphic && result.graphic.layer && result.graphic.layer.type === "feature";
                            })[0];

                            if (layerResult) {
                                toggleLocationSelection(layerResult.graphic.layer);
                            }
                        });
                    });

                    // Add event listener for map load
                    view.when(function() {
                        console.log("Map loaded successfully. Click on a point to begin.");
                        setupAutocomplete(); // Setup autocomplete after map is ready
                        populateYearFilter(); // Populate year filter
                    });
                }

                initMap();

                // Function to validate and provide visual feedback for street input
                function validateStreetInput() {
                    const streetInput = document.getElementById("streetFilter");
                    const enteredValue = streetInput.value.trim();
                    const streetError = document.getElementById("streetError");

                    if (enteredValue) {
                        // Assume valid if input is not empty (since suggestions are handled by Locator)
                        streetInput.style.borderColor = "green";
                        streetError.style.display = "none";
                        streetInput.setCustomValidity("");
                    } else {
                        streetInput.style.borderColor = "";
                        streetError.style.display = "none";
                        streetInput.setCustomValidity("");
                    }
                }

                // Function to toggle location selection
                function toggleLocationSelection(layer) {
                    const index = selectedLocations.findIndex(l => l.id === layer.id);
                    if (index > -1) {
                        selectedLocations.splice(index, 1);
                    } else {
                        selectedLocations.push(layer);
                    }
                    updateLocationSelectionUI();
                    querySelectedLocations();
                }

                // Function to update location selection UI
                function updateLocationSelectionUI() {
                    console.log("Selected locations:", selectedLocations.length);
                    // You can add more UI updates here, like updating a list of selected locations
                }

                // Function to query selected locations
                function querySelectedLocations() {
                    var promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        var allFeatures = results.flat();
                        displayAttributes(allFeatures);
                        highlightFeatures(allFeatures);
                    });
                }

                // Function to build where clause based on filters
                function buildWhereClause(layer) {
                    const whereClause = [];
                    const dataType = document.getElementById("dataTypeFilter").value;
                    const years = getSelectedYears();
                    const period = document.getElementById("periodFilter").value;
                    const street = document.getElementById("streetFilter").value;

                    if (dataType !== "All") {
                        whereClause.push("Data_Type = '" + dataType + "'");
                    }
                    if (years.length > 0 && !years.includes("All")) {
                        whereClause.push("Year IN (" + years.join(",") + ")");
                    }
                    if (period !== "All") {
                        whereClause.push("Period = '" + period + "'");
                    }
                    if (street) {
                        whereClause.push("Major_Street LIKE '%" + street + "%' OR Minor_Street LIKE '%" + street + "%'");
                    }

                    return whereClause;
                }

                // Function to get selected years
                function getSelectedYears() {
                    const yearFilter = document.getElementById("yearFilter");
                    const selectedYears = Array.from(yearFilter.selectedOptions).map(option => option.value);
                    return selectedYears.includes("All") ? ["All"] : selectedYears;
                }

                // Function to query features from a layer based on filters
                function queryFeatures(layer, streetGeometry) {
                    const whereClause = buildWhereClause(layer);
                    const query = layer.createQuery();
                    query.where = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";
                    query.outFields = ["*"];
                    query.returnGeometry = true;

                    if (streetGeometry) {
                        query.geometry = streetGeometry;
                        query.spatialRelationship = "intersects";
                    }

                    return layer.queryFeatures(query).then(function(result) {
                        return result.features;
                    });
                }


                // Function to display attributes in the featuresDiv
                function displayAttributes(features) {
                    var featuresDiv = document.getElementById("featuresDiv");
                    featuresDiv.innerHTML = "";

                    if (features.length === 0) {
                        featuresDiv.innerHTML = "No features found in this layer.";
                        featuresDiv.style.display = "block";
                        return;
                    }

                    var table = document.createElement("table");
                    table.className = "attribute-table";

                    // Determine which columns have non-null values and are not excluded
                    var columnsWithValues = {};
                    var excludedFields = ["PopupInfo", "ObjectID", "PEAK_ID", "Latitude", "Longitude", "Intersection_ID", "Intersection_Type", "Leg_Type","Traffic_DataCollection_Date", "City","State", "Intersection_Value","E","N","S","W"];
                    features.forEach(function(feature) {
                        for (let attr in feature.attributes) { // Changed var to let
                            if (feature.attributes.hasOwnProperty(attr) && 
                                feature.attributes[attr] !== null && 
                                !excludedFields.includes(attr)) {
                                columnsWithValues[attr] = true;
                            }
                        }
                    });

                    // Create header row
                    var headerRow = table.createTHead().insertRow();
                    var headers = [];
                    for (let attr in features[0].attributes) { // Changed var to let
                        if (features[0].attributes.hasOwnProperty(attr) && 
                            columnsWithValues[attr] && 
                            !excludedFields.includes(attr)) {
                            headers.push(attr);
                            var headerCell = document.createElement("th");
                            headerCell.innerHTML = attr + ' <span class="sort-indicator">⇅</span>';
                            
                            // Use let to capture the current value of attr
                            headerCell.addEventListener("click", function() {
                                const columnIndex = headers.indexOf(attr);
                                sortTable(table, columnIndex, this);
                            });
                            headerRow.appendChild(headerCell);
                        }
                    }

                    // Create tbody
                    var tbody = table.createTBody();
                    features.forEach(function(feature) {
                        var dataRow = tbody.insertRow();
                        headers.forEach(function(attr) {
                            var dataCell = dataRow.insertCell();
                            dataCell.innerHTML = feature.attributes[attr] !== null ? feature.attributes[attr] : "N/A";
                        });
                    });

                    featuresDiv.appendChild(table);
                    featuresDiv.style.display = "block";
                }

                let currentSort = { index: -1, asc: true };

                // Function to sort the table based on column index
                function sortTable(table, columnIndex, headerCell) {
                    if (columnIndex === -1) {
                        console.error("Invalid column index:", columnIndex);
                        return;
                    }

                    var tbody = table.tBodies[0];
                    var rows = Array.from(tbody.rows);

                    if (currentSort.index === columnIndex) {
                        currentSort.asc = !currentSort.asc;
                    } else {
                        currentSort.index = columnIndex;
                        currentSort.asc = true;
                    }

                    rows.sort(function(a, b) {
                        var aCell = a.cells[columnIndex];
                        var bCell = b.cells[columnIndex];

                        // Safety check
                        if (!aCell || !bCell) {
                            console.warn("One of the cells is undefined:", aCell, bCell);
                            return 0;
                        }

                        var aText = aCell.textContent.trim();
                        var bText = bCell.textContent.trim();

                        // Attempt to parse as numbers
                        var aNum = parseFloat(aText.replace(/[^0-9.-]+/g,""));
                        var bNum = parseFloat(bText.replace(/[^0-9.-]+/g,""));

                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return currentSort.asc ? aNum - bNum : bNum - aNum;
                        } else {
                            return currentSort.asc ? aText.localeCompare(bText) : bText.localeCompare(aText);
                        }
                    });

                    // Remove existing rows
                    while (tbody.firstChild) {
                        tbody.removeChild(tbody.firstChild);
                    }

                    // Re-add sorted rows
                    rows.forEach(function(row) {
                        tbody.appendChild(row);
                    });

                    // Update sort indicators
                    updateSortIndicators(table, columnIndex, currentSort.asc);
                }

                // Function to update sort indicators in the table headers
                function updateSortIndicators(table, sortedColumn, asc) {
                    var headers = table.tHead.rows[0].cells;
                    for (var i = 0; i < headers.length; i++) {
                        var indicator = headers[i].querySelector(".sort-indicator");
                        if (i === sortedColumn) {
                            indicator.textContent = asc ? "↑" : "↓";
                        } else {
                            indicator.textContent = "⇅";
                        }
                    }
                }

                // Function to highlight features on the map
                function highlightFeatures(features) {
                    view.graphics.removeAll();
                    features.forEach(function(feature) {
                        var graphic = new Graphic({
                            geometry: feature.geometry,
                            symbol: {
                                type: "simple-marker",
                                style: "circle",
                                color: [255, 255, 0, 0.8],
                                size: "12px",
                                outline: {
                                    color: [255, 255, 0, 0.8],
                                    width: "2px"
                                }
                            }
                        });
                        view.graphics.add(graphic);
                    });
                }

                // Function to apply filters and update layer visibility
                function applyFilters() {
                    const street = document.getElementById("streetFilter").value;
                    if (street) {
                        locator.addressToLocations({
                            url: serviceUrl,
                            address: { SingleLine: street },
                            maxLocations: 1,
                            outFields: ["*"]
                        }).then(function(candidates) {
                            if (candidates.length > 0) {
                                const streetGeometry = candidates[0].extent || candidates[0].location;
                                performFiltering(streetGeometry);
                            } else {
                                console.error("No geometry found for the selected street.");
                                performFiltering(null);
                            }
                        }).catch(function(error) {
                            console.error("Error retrieving street geometry:", error);
                            performFiltering(null);
                        });
                    } else {
                        performFiltering(null);
                    }
                }

                function performFiltering(streetGeometry) {
                    map.layers.forEach(function(layer) {
                        if (!(layer instanceof FeatureLayer)) return;
                        const whereClause = buildWhereClause(layer);
                        const query = layer.createQuery();
                        query.where = whereClause.length > 0 ? whereClause.join(" AND ") : "1=1";
                        query.returnGeometry = false;
                        query.outFields = ["*"];
                        if (streetGeometry) {
                            query.geometry = streetGeometry;
                            query.spatialRelationship = "intersects";
                        }

                        layer.queryFeatureCount(query).then(function(count) {
                            layer.visible = count > 0;
                        }).catch(function(error) {
                            console.error("Query count failed: ", error);
                            layer.visible = false;
                        });
                    });
                }


                // Function to generate PDF report
                function generatePDF(features) {
                    const doc = new jsPDF({
                        orientation: 'landscape',
                        unit: 'mm',
                        format: 'a4'
                    });
                    
                    let yPos = 15;

                    // Set font styles
                    const titleFont = 'helvetica';
                    const bodyFont = 'helvetica';
                    doc.setFont(titleFont, 'bold');
                    doc.setFontSize(16);
                    doc.text("Traffic Analytics Report", 105, yPos, { align: 'center' });
                    yPos += 10;

                    doc.setFont(bodyFont, 'normal');
                    doc.setFontSize(8);
                    
                    const excludedFields = ["PopupInfo", "ObjectID", "PEAK_ID", "Latitude", "Longitude", "Intersection_ID", "Intersection_Type", "Leg_Type","Traffic_DataCollection_Date", "City","State", "Intersection_Value","E","N","S","W", "Intersection_Traffic_Volumes"];
                    const attributes = Object.keys(features[0].attributes)
                        .filter(attr => !excludedFields.includes(attr));

                    // Calculate column widths
                    const pageWidth = doc.internal.pageSize.width;
                    const margins = 5;
                    const tableWidth = pageWidth - (margins * 2);
                    const minColumnWidth = 30; // Set minimum column width in mm
                    const maxColumnWidth = 50; // Set maximum column width in mm

                    const columnWidths = attributes.map(attr => {
                        const maxWidth = Math.max(
                            doc.getStringUnitWidth(attr) * 2.5,
                            ...features.map(f => doc.getStringUnitWidth(f.attributes[attr]?.toString() || "") * 2.5)
                        );
                        return Math.min(Math.max(maxWidth, minColumnWidth), maxColumnWidth);
                    });

                    const totalWidth = columnWidths.reduce((a, b) => a + b, 0);
                    const scaleFactor = tableWidth / totalWidth;
                    const finalColumnWidths = columnWidths.map(w => w * scaleFactor);

                    // Create table header
                    doc.setFillColor(220, 220, 220);
                    doc.rect(margins, yPos, tableWidth, 16, 'F');
                    doc.setFont(bodyFont, 'bold');
                    doc.setTextColor(0);
                    let xPos = margins;
                    attributes.forEach((attr, index) => {
                        doc.text(attr, xPos + 1, yPos + 5.5, { maxWidth: finalColumnWidths[index] - 2, align: 'left' });
                        xPos += finalColumnWidths[index];
                    });
                    yPos += 16;

                    // Create table rows
                    doc.setFont(bodyFont, 'normal');
                    features.forEach((feature, featureIndex) => {
                        xPos = margins;
                        let maxRowHeight = 0;

                        // Calculate row height based on content
                        attributes.forEach((attr, attrIndex) => {
                            const value = feature.attributes[attr]?.toString() || "N/A";
                            const textHeight = doc.getTextDimensions(value, { maxWidth: finalColumnWidths[attrIndex] - 2 }).h;
                            maxRowHeight = Math.max(maxRowHeight, textHeight);
                        });

                        maxRowHeight += 2; // Add some padding

                        // Alternate row colors
                        doc.setFillColor(featureIndex % 2 === 0 ? 255 : 245);
                        doc.rect(margins, yPos, tableWidth, maxRowHeight, 'F');

                        attributes.forEach((attr, attrIndex) => {
                            const value = feature.attributes[attr]?.toString() || "N/A";
                            doc.text(value, xPos + 1, yPos + 4, { 
                                maxWidth: finalColumnWidths[attrIndex] - 2,
                                align: 'left'
                            });
                            xPos += finalColumnWidths[attrIndex];
                        });
                        yPos += maxRowHeight;

                        // Add a new page if we're near the bottom
                        if (yPos > doc.internal.pageSize.height - 20) {
                            doc.addPage();
                            yPos = margins;
                            
                            // Repeat the header on the new page
                            doc.setFillColor(220, 220, 220);
                            doc.rect(margins, yPos, tableWidth, 8, 'F');
                            doc.setFont(bodyFont, 'bold');
                            xPos = margins;
                            attributes.forEach((attr, index) => {
                                doc.text(attr, xPos + 1, yPos + 5.5, { maxWidth: finalColumnWidths[index] - 2, align: 'left' });
                                xPos += finalColumnWidths[index];
                            });
                            yPos += 8;
                            doc.setFont(bodyFont, 'normal');
                        }
                    });

                    // Add filters applied
                    yPos += 10;
                    doc.setFont(bodyFont, 'bold');
                    doc.setFontSize(10);
                    doc.text("Filters Applied:", margins, yPos);
                    yPos += 7;
                    doc.setFont(bodyFont, 'normal');
                    doc.setFontSize(9);
                    const filters = [
                        `Data Type: ${document.getElementById("dataTypeFilter").value}`,
                        `Year: ${getSelectedYears().join(", ")}`,
                        `Period: ${document.getElementById("periodFilter").value}`,
                        `Street: ${document.getElementById("streetFilter").value || "None"}`
                    ];
                    filters.forEach(filter => {
                        doc.text(filter, margins + 5, yPos);
                        yPos += 5;
                    });

                    doc.save("traffic_analytics_report.pdf");
                }

                // Function to print the map as PDF
                function printMap(features) {
                    if (features.length === 0) {
                        alert("No features selected. Please select features first.");
                        return;
                    }

                    var extent = null;
                    var validFeatures = features.filter(function(feature) {
                        return feature.geometry;
                    });

                    if (validFeatures.length === 0) {
                        alert("No valid geometries found in the selected features. Unable to print map.");
                        return;
                    }

                    validFeatures.forEach(function(feature) {
                        if (feature.geometry.type === "point") {
                            var point = feature.geometry;
                            var buffer = 0.001;
                            var pointExtent = new Extent({
                                xmin: point.x - buffer,
                                ymin: point.y - buffer,
                                xmax: point.x + buffer,
                                ymax: point.y + buffer,
                                spatialReference: view.spatialReference
                            });
                            
                            if (extent) {
                                extent = extent.union(pointExtent);
                            } else {
                                extent = pointExtent;
                            }
                        } else if (feature.geometry.extent) {
                            if (extent) {
                                extent = extent.union(feature.geometry.extent);
                            } else {
                                extent = feature.geometry.extent.clone();
                            }
                        }
                    });

                    if (!extent) {
                        alert("Unable to determine map extent. Please try again.");
                        return;
                    }

                    // Adjust the zoom level more precisely
                    view.goTo(extent.expand(0.5,1)).then(function() {
                        // Add a delay before taking the screenshot
                        setTimeout(function() {
                            view.takeScreenshot({ 
                                format: "jpg",
                                width: 900,
                                height: 1200
                            }).then(function(screenshot) {
                                var image = new Image();
                                image.src = screenshot.dataUrl;

                                image.onload = function() {
                                    var doc = new jsPDF({
                                        orientation: "portrait",
                                        unit: "mm",
                                        format: "a4"
                                    });

                                    doc.setFontSize(18);
                                    doc.text("Traffic Analytics Map", 105, 15, { align: "center" });

                                    var pageWidth = doc.internal.pageSize.getWidth();
                                    var pageHeight = doc.internal.pageSize.getHeight();
                                    var margin = 10;
                                    var bottomY = pageHeight - 20; // Start 20mm from bottom
                                    var maxWidth = pageWidth - (2 * margin);
                                    var maxHeight = pageHeight - 50;

                                    var imgRatio = image.height / image.width;
                                    var pageRatio = maxHeight / maxWidth;

                                    var imgWidth, imgHeight;

                                    if (imgRatio > pageRatio) {
                                        imgHeight = maxHeight;
                                        imgWidth = imgHeight / imgRatio;
                                    } else {
                                        imgWidth = maxWidth;
                                        imgHeight = imgWidth * imgRatio;
                                    }

                                    var xOffset = (pageWidth - imgWidth) / 2;

                                    doc.addImage(image, "JPEG", xOffset, 25, imgWidth, imgHeight);
                                    // Scalebar
                                    doc.setLineWidth(0.5);
                                    doc.line(margin, bottomY, margin + 50, bottomY);
                                    doc.setFontSize(8);
                                    doc.text("0", margin, bottomY + 5);
                                    doc.text("500 m", margin + 40, bottomY + 5);
                                    // Legend
                                    doc.setFontSize(10);
                                    doc.text("Legend", pageWidth - margin - 40, bottomY);
                                    doc.circle(pageWidth - margin - 35, bottomY + 7, 2, "F");
                                    doc.setFontSize(8);
                                    doc.text("Selected Location", pageWidth - margin - 30, bottomY + 8);
                                    // Date and filters
                                    doc.setFontSize(8);
                                    var dateText = `Date: ${new Date().toLocaleDateString()}`;
                                    var filterText = `Filters: ${document.getElementById("dataTypeFilter").value}, ${document.getElementById("yearFilter").value}, ${document.getElementById("periodFilter").value}`;
                                    
                                    doc.text(dateText, margin, pageHeight - 10);
                                    doc.text(filterText, margin, pageHeight - 5);

                                    doc.save("traffic_analytics_map.pdf");
                                };
                            });
                        }, 2000); // 2 second delay to ensure map is fully rendered
                    }).catch(function(error) {
                        console.error("Error while zooming to extent:", error);
                        alert("An error occurred while preparing the map for print. Please try again.");
                    });
                }

                // Function to handle Enter key press for selecting the top autocomplete option
                function handleEnterKey(event) {
                    if (event.key === "Enter") {
                        const streetInput = event.target;
                        const autocompleteList = document.getElementById("autocomplete-list");
                        const firstItem = autocompleteList.querySelector(".autocomplete-item");
                        if (firstItem) {
                            event.preventDefault();
                            firstItem.click();
                        }
                    }
                }

                // Function to populate year filter options
                function populateYearFilter() {
                    const yearFilter = document.getElementById("yearFilter");
                    const currentYear = new Date().getFullYear();
                    for (let year = 2000; year <= currentYear; year++) {
                        const option = document.createElement("option");
                        option.value = year;
                        option.text = year;
                        yearFilter.add(option);
                    }
                }

                // Function to display attributes in the featuresDiv
                // (Already defined above)

                // Function to highlight features on the map
                // (Already defined above)

                // Add event listeners for other filters
                document.getElementById("dataTypeFilter").addEventListener("change", applyFilters);
                document.getElementById("yearFilter").addEventListener("change", applyFilters);
                document.getElementById("periodFilter").addEventListener("change", applyFilters);

                // Add event listeners for street filter
                // Street Filter Input
                const streetInputElement = document.getElementById("streetFilter");
                streetInputElement.addEventListener("input", function() {
                    validateStreetInput();
                    // No need to call applyFilters here, as it's handled after selection
                });
                streetInputElement.addEventListener("change", validateStreetInput);
                streetInputElement.addEventListener("keydown", handleEnterKey);

                // Generate Report Button
                document.getElementById("generateReportBtn").addEventListener("click", function() {
                    if (selectedLocations.length === 0) {
                        alert("No locations selected. Please select locations for the report.");
                        return;
                    }

                    var promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        var allFeatures = results.flat();
                        generatePDF(allFeatures);
                    });
                });

                // Print Map Button
                document.getElementById("printMapBtn").addEventListener("click", function() {
                    if (selectedLocations.length === 0) {
                        alert("No locations selected. Please select locations first.");
                        return;
                    }

                    var promises = selectedLocations.map(function(layer) {
                        return queryFeatures(layer);
                    });

                    Promise.all(promises).then(function(results) {
                        var allFeatures = results.flat();
                        printMap(allFeatures);
                    });
                });
            });
        });
    </script>
</body>
</html>