<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Analytics Map</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.30/esri/themes/light/main.css">

    <script>
        window.PEAK_APP_CONFIG = {
            portalUrl: "https://calbyeon.github.io/",
            oauthAppId: "mz86rbSUbYtreYS9",
            oauthRedirectUri: "https://calbyeon.github.io/",
            oauthClientSecret: "a3a12cf73a55476c975358572dbb1c8f"
        };
    </script>
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>
    <script src="https://js.arcgis.com/4.30/"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
            overflow: hidden;
            /* Prevent body scrollbars */
        }

        /* Main container uses flex column layout */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            background: #f5f5f5;
        }

        /* Header remains fixed height */
        #header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px;
            background-color: #ffffff;
            border-bottom: 1px solid #ccc;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 1;
        }

        #header .header-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .header-link-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background-color: #1f7a8c;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            text-decoration: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .header-link-button:hover {
            background-color: #155d6a;
        }

        /* Map View takes up remaining flexible space */
        #viewDiv {
            flex: 1 1 auto;
            position: relative;
            /* Set a minimum height to ensure the map has enough space for UI elements like the filter panel, preventing overlap on short browser windows. */
            min-height: 320px;
            width: 100%;
        }

        /* Features Div (Table Container) at the bottom */
        #featuresDiv {
            /* Changed flex-shrink from 0 to 1. This allows the table panel to shrink if the browser window becomes too short, yielding space to the map view above. */
            flex: 0 1 45%;
            background-color: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Important for child scroll container */
            border-top: 1px solid #ccc;
            width: 100%;
        }

        /* Table content area scrolls if needed */
        #featuresContentDiv {
            flex: 1 1 auto;
            box-sizing: border-box;
            overflow: auto;
            /* THIS IS THE SCROLL CONTAINER FOR THE TABLE */
            background: #ffffff;
            /* Tells the scroll container to leave space at the top for the sticky header */
            /* Adjust this value based on the actual height of your header row */
            scroll-padding-top: 40px;
        }

        /* Use separate border model for better sticky compatibility */
        .attribute-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            table-layout: fixed;
            background-color: #ffffff;
            border: 1px solid #ddd;
            /* Border on table itself */
        }


        /* --- Sticky Header CSS (Applied to TH) --- */
        .attribute-table thead th {
            /* Positioning */
            position: sticky;
            top: 0;
            /* Stick to the top of the scroll container (#featuresContentDiv) */
            z-index: 2;
            /* Needs to be above tbody rows (default 0/auto) */

            /* Appearance */
            background-color: #4b8fcf;
            /* Crucial for opacity */
            color: #fff;
            text-align: left;
            font-weight: bold;
            padding: 8px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            box-sizing: border-box;
            vertical-align: middle;

            /* Borders */
            border-top: 1px solid #ccc;
            border-left: 1px solid #ccc;
            border-bottom: 2px solid #ccc;
            /* Distinct bottom border */
        }

        /* Adjust border overrides as needed */
        .attribute-table thead tr:first-child th {
            border-top: none;
            /* Remove top border on the very first row of headers */
        }

        .attribute-table thead th:first-child {
            border-left: none;
            /* Remove left border on the first header cell */
            padding-left: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th:last-child {
            padding-right: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            color: #eee;
        }

        /* --- End Sticky Header CSS --- */


        /* --- Table Body Cells --- */
        .attribute-table tbody td {
            padding: 8px 8px;
            box-sizing: border-box;
            vertical-align: middle;
            word-wrap: break-word;

            /* Borders */
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
            z-index: 1;
            /* Lower z-index than sticky headers */
        }

        .attribute-table tbody td:first-child {
            border-left: none;
            /* Remove left border on first body cell */
            padding-left: 10px;
        }

        .attribute-table tbody td:last-child {
            padding-right: 10px;
        }

        /* --- End Table Body Cells --- */


        /* Background styles */
        .attribute-table tbody tr:nth-child(even) td {
            background-color: #f9f9f9;
        }

        .attribute-table tbody tr:nth-child(odd) td {
            background-color: #ffffff;
        }

        .attribute-table tbody tr:hover td {
            background-color: #e8f0fe;
        }

        /* 'No features' row styling */
        .attribute-table .no-features-row td {
            text-align: center;
            font-style: italic;
            color: #666;
            background-color: #fff !important;
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
        }

        .attribute-table .no-features-row td:first-child:last-child {
            border-left: none;
        }

        #filterDiv,
        #reportingDiv {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            border: 1px solid #ccc;
            margin: 10px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            z-index: 50;
            /* Ensure they are above sticky headers */
        }

        #filterDiv {
            width: 270px;
        }

        #filterControls label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        #filterControls select,
        #filterControls input {
            width: 100%;
            margin-top: 3px;
            margin-bottom: 12px;
            padding: 6px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }

        #filterControls select[multiple] {
            height: auto;
        }

        #reportingDiv button {
            padding: 8px 15px;
            margin-left: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f7f7f7, #e2e2e2);
            transition: background 0.2s, border-color 0.2s;
        }

        #reportingDiv select {
            padding: 8px 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
        }

        #reportingDiv button:hover {
            background: linear-gradient(to bottom, #f0f0f0, #d9d9d9);
            border-color: #999;
        }

        #reportingDiv button:active {
            background: linear-gradient(to bottom, #d9d9d9, #c2c2c2);
            border-color: #777;
        }

        #loadingSpinner {
            position: absolute;
            top: 50%;
            left: 50%;
            z-index: 1000;
            display: none;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        #filterStatus {
            margin-top: 10px;
            color: #555;
            font-size: 12px;
            line-height: 1.4;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #filterStatus strong {
            display: block;
            margin-bottom: 4px;
        }
        #filterStatusSummary {
            margin-top: 6px;
            font-size: 12px;
            color: #333;
        }

        #tableToolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            border-bottom: 1px solid #d4d4d4;
            background-color: #fafafa;
            gap: 12px;
        }

        #tableToolbar .toolbar-left {
            flex: 1 1 auto;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        #tableTabs {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .table-tab {
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #b5b5b5;
            border-radius: 4px;
            background: linear-gradient(to bottom, #ffffff, #e8e8e8);
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, box-shadow 0.2s, color 0.2s;
        }

        .table-tab:hover:not(.active) {
            background: linear-gradient(to bottom, #fdfdfd, #dddddd);
            border-color: #999;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        .table-tab.active {
            background: linear-gradient(to bottom, #4b8fcf, #3f7bb4);
            color: #ffffff;
            border-color: #3a6fa6;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .table-tab:focus-visible {
            outline: 2px solid #4b8fcf;
            outline-offset: 2px;
        }

        #tableSummaryText {
            flex: 1 1 auto;
            font-size: 13px;
            color: #3a3a3a;
            line-height: 1.4;
        }

        #tableToolbar .toolbar-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
        }

        #tableToolbar button {
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #b5b5b5;
            border-radius: 4px;
            background: linear-gradient(to bottom, #ffffff, #e8e8e8);
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, box-shadow 0.2s;
        }

        #tableToolbar button:hover {
            background: linear-gradient(to bottom, #fdfdfd, #dddddd);
            border-color: #999;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        #tableToolbar button:active {
            background: linear-gradient(to bottom, #dcdcdc, #c4c4c4);
            border-color: #7a7a7a;
        }

        #tableToolbar button:focus-visible {
            outline: 2px solid #4b8fcf;
            outline-offset: 2px;
        }

        #tableToolbar button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: linear-gradient(to bottom, #f2f2f2, #d8d8d8);
            border-color: #c0c0c0;
            box-shadow: none;
        }

        #adminPanel {
            flex: 0 0 auto;
            background: #ffffff;
            border-top: 1px solid #dcdcdc;
            padding: 20px;
            display: none;
            gap: 20px;
            flex-wrap: wrap;
        }

        #adminPanel.active {
            display: flex;
        }

        .admin-card {
            flex: 1 1 320px;
            border: 1px solid #d4d4d4;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            background: #fafafa;
        }

        .admin-card h3 {
            margin-top: 0;
            font-size: 18px;
            color: #2f4f6f;
        }

        .admin-card p {
            font-size: 13px;
            color: #4d4d4d;
            line-height: 1.5;
        }

        .admin-actions {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 12px;
        }

        .admin-actions button,
        .admin-actions a {
            align-self: flex-start;
            padding: 6px 12px;
            font-size: 13px;
            border-radius: 4px;
            border: 1px solid #4b8fcf;
            background: #4b8fcf;
            color: #ffffff;
            cursor: pointer;
            text-decoration: none;
            transition: background 0.2s, color 0.2s, border 0.2s;
        }

        .admin-actions button.secondary,
        .admin-actions a.secondary {
            background: transparent;
            color: #4b8fcf;
        }

        .admin-actions button:hover,
        .admin-actions a:hover {
            background: #3f7bb4;
            color: #ffffff;
        }

        .admin-actions button.secondary:hover,
        .admin-actions a.secondary:hover {
            background: rgba(75, 143, 207, 0.12);
        }

        .admin-hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <header id="header">
            <div class="header-title">
                <span>City of Walnut Creek</span>
                <span>Traffic Analytics Map</span>
            </div>
            <a class="header-link-button" href="edit-only.html">Open Editing Map</a>
        </header>

        <div id="viewDiv">
            <div id="loadingSpinner"></div>
        </div>

        <div id="featuresDiv">
            <div id="tableToolbar">
                <div class="toolbar-left">
                    <div id="tableTabs" role="tablist" aria-label="Table views">
                        <button type="button" class="table-tab active" role="tab" aria-selected="true" aria-controls="attributeTable" data-tab="features" tabindex="0">Traffic Data</button>
                        <button type="button" class="table-tab" role="tab" aria-selected="false" aria-controls="attributeTable" data-tab="adt" tabindex="-1">ADT Counts</button>
                    </div>
                    <div id="tableSummaryText" aria-live="polite">Loading data...</div>
                </div>
                <div class="toolbar-actions">
                    <button type="button" id="clearSelectionBtn" aria-label="Clear current selection" disabled>Clear Selection</button>
                    <button type="button" id="resetFiltersBtn" aria-label="Reset all filters to defaults" disabled>Reset Filters</button>
                </div>
            </div>
            <!-- This div handles the scrolling -->
            <div id="featuresContentDiv">
                <table class="attribute-table" id="attributeTable">
                    <thead></thead> <!-- Headers added dynamically -->
                    <tbody></tbody> <!-- Data added dynamically -->
                </table>
            </div>
        </div>

        <div id="adminPanel" aria-live="polite">
            <div class="admin-card" id="adminWelcomeCard">
                <h3>Data Management Access</h3>
                <p id="adminStatusMessage">Sign in with your ArcGIS Online credentials to manage Average Daily Traffic (ADT) counts and intersection traffic tables.</p>
                <div class="admin-actions">
                    <button type="button" id="adminSignInBtn">Sign in</button>
                    <button type="button" id="adminSignOutBtn" class="secondary admin-hidden">Sign out</button>
                    <a id="adtTemplateLink" class="secondary admin-hidden" download="ADT_Template.csv" href="#">Download ADT CSV template</a>
                    <a id="trafficTemplateLink" class="secondary admin-hidden" download="Traffic_Template.csv" href="#">Download Traffic CSV template</a>
                </div>
            </div>

            <div class="admin-card admin-hidden" id="adtImportCard">
                <h3>Upload ADT Counts</h3>
                <p>Upload a CSV containing new or updated Average Daily Traffic measurements. Records must include <code>LineGUID</code>, <code>ADT</code>, <code>CountDate</code>, <code>Year</code>, and <code>join_key</code>.</p>
                <div class="admin-actions">
                    <input type="file" id="adtFileInput" accept=".csv,.xls,.xlsx" />
                    <button type="button" id="adtUploadBtn">Upload ADT CSV</button>
                    <button type="button" id="adtManualEntryBtn" class="secondary">Add single ADT record</button>
                </div>
                <div id="adtUploadFeedback" role="status"></div>
            </div>

            <div class="admin-card admin-hidden" id="trafficImportCard">
                <h3>Traffic Count Tables</h3>
                <p>Match uploads to an existing intersection using <code>Intersection_ID</code>. This tool will create related table entries for the selected intersection.</p>
                <div class="admin-actions">
                    <input type="file" id="trafficFileInput" accept=".csv,.xls,.xlsx" />
                    <button type="button" id="trafficUploadBtn">Upload Traffic CSV</button>
                    <button type="button" id="trafficManualEntryBtn" class="secondary">Record counts manually</button>
                </div>
                <div id="trafficUploadFeedback" role="status"></div>
            </div>
        </div>

        <!-- Templates for UI elements -->
        <div id="filterDivTemplate" style="display: none;">
            <div id="filterControls"></div>
            <div id="filterStatus">
                <strong>Filter Behavior:</strong>
                If features are selected (highlighted cyan on map), filters apply only to the selection. Otherwise,
                filters apply globally.<br>
                Clicking empty map space unselects all features. Filters hide non-matching features/data.
                <div id="filterStatusSummary" aria-live="polite"></div>
            </div>
        </div>

        <div id="reportingDivTemplate" style="display: none;">
            <select id="reportFormat" aria-label="Select Report Format">
                <option value="pdf">PDF</option>
                <option value="csv">CSV</option>
            </select>
            <button id="generateReportBtn" aria-label="Generate Report">Generate Report</button>
            <button id="printMapBtn" aria-label="Export Map">Export Map PDF</button>
        </div>

    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // --- Constants ---
            const DATA_TYPE_FIELD = "Data_Type";
            const YEAR_FIELD = "Year";
            const PERIOD_FIELD = "Period";
            const MAJOR_STREETS_FIELD = "Major_Streets";
            const MINOR_STREETS_FIELD = "Minor_Streets";
            const STREET_FILTER_DEBOUNCE_MS = 300;

            const VIEW_DIV_ID = "viewDiv";
            const FILTER_DIV_ID = "filterDiv";
            const REPORTING_DIV_ID = "reportingDiv";
            const ATTRIBUTE_TABLE_ID = "attributeTable";
            const LOADING_SPINNER_ID = "loadingSpinner";
            const FILTER_CONTROLS_ID = "filterControls";
            const FILTER_STATUS_SUMMARY_ID = "filterStatusSummary";
            const DATA_TYPE_FILTER_ID = "dataTypeFilter";
            const YEAR_FILTER_ID = "yearFilter";
            const PERIOD_FILTER_ID = "periodFilter";
            const STREET_FILTER_ID = "streetFilter";
            const GENERATE_REPORT_BTN_ID = "generateReportBtn";
            const PRINT_MAP_BTN_ID = "printMapBtn";
            const REPORT_FORMAT_ID = "reportFormat";
            const TABLE_SUMMARY_ID = "tableSummaryText";
            const CLEAR_SELECTION_BTN_ID = "clearSelectionBtn";
            const RESET_FILTERS_BTN_ID = "resetFiltersBtn";
            const TABLE_TABS_ID = "tableTabs";
            const TABLE_TAB_BUTTON_CLASS = "table-tab";
            const TABLE_TAB_FEATURES = "features";
            const TABLE_TAB_ADT = "adt";
            const TABLE_TAB_ACTIVE_CLASS = "active";
            const ADT_FIELD_CONFIG = [
                { name: "ADT", alias: "ADT" },
                { name: "Year", alias: "Year" },
                { name: "join_key", alias: "join_key" }
            ];
            const MAX_ADT_REL_QUERY_BATCH = 500;
            const ADMIN_PANEL_ID = "adminPanel";
            const ADMIN_SIGN_IN_BTN_ID = "adminSignInBtn";
            const ADMIN_SIGN_OUT_BTN_ID = "adminSignOutBtn";
            const ADMIN_STATUS_MESSAGE_ID = "adminStatusMessage";
            const ADT_TEMPLATE_LINK_ID = "adtTemplateLink";
            const TRAFFIC_TEMPLATE_LINK_ID = "trafficTemplateLink";
            const ADT_IMPORT_CARD_ID = "adtImportCard";
            const TRAFFIC_IMPORT_CARD_ID = "trafficImportCard";
            const ADT_FILE_INPUT_ID = "adtFileInput";
            const ADT_UPLOAD_BTN_ID = "adtUploadBtn";
            const ADT_MANUAL_ENTRY_BTN_ID = "adtManualEntryBtn";
            const ADT_UPLOAD_FEEDBACK_ID = "adtUploadFeedback";
            const TRAFFIC_FILE_INPUT_ID = "trafficFileInput";
            const TRAFFIC_UPLOAD_BTN_ID = "trafficUploadBtn";
            const TRAFFIC_MANUAL_ENTRY_BTN_ID = "trafficManualEntryBtn";
            const TRAFFIC_UPLOAD_FEEDBACK_ID = "trafficUploadFeedback";
            const ADT_REFERENCE_LAYER_TITLE = "Unique PEAK Traffic Count Intersections";
            const ADT_VIEW_LAYER_TITLE = "PEAK_ADTViewable_10152025 - ADT";
            const LEGACY_ADT_LAYER_TITLE = "Average Daily Traffic Counts";
            const ADT_VIEW_LAYER_URL_FRAGMENT = "PEAK_ADTViewable_10152025/FeatureServer";
            const ADT_EDITABLE_PORTAL_ITEM_ID = "f5c54f8a112149d0bce715a4ded24f02";
            const TRAFFIC_EDITABLE_PORTAL_ITEM_ID = "ca9fcb119fc54c21a0d3dade0d4915db";
            const APP_CONFIG = window.PEAK_APP_CONFIG || {};
            const PORTAL_URL = APP_CONFIG.portalUrl || "https://www.arcgis.com";
            const OAUTH_APP_ID = APP_CONFIG.oauthAppId || "REPLACE_WITH_YOUR_APP_ID";
            const OAUTH_REDIRECT_URI = APP_CONFIG.oauthRedirectUri || (window.location.origin + window.location.pathname);
            const ADMIN_FEATURES_ENABLED = !!APP_CONFIG.enableAdminUploads;

            // --- State Variables ---
            let map, view;
            let allLayers = []; // Will hold FeatureLayers from the WebMap
            let highlightHandles = {};
            let allYears = new Set();
            let streetList = [];
            let currentDataType = "All"; // Initialize with a simple default
            let currentYears = [];       // Initialize as an empty array
            let currentPeriod = "All";   // Initialize with a simple default
            let currentStreet = "";      // Initialize with a simple default
            let selectedFeatures = [];
            let filteredAndVisibleFeatures = [];
            let relatedDataCache = {};
            let currentTableHeaders = [];
            let currentTableData = [];
            let originalViewpoint = null;
            let streetFilterTimeout = null;
            let currentTableTab = TABLE_TAB_FEATURES;
            let adtLineLayer = null;
            let adtRelationshipInfo = null;
            let adtRelatedTableLayer = null;
            let adtSelectedOids = new Set();
            let adtAllParentOids = null;
            let adtFieldInfos = null;
            let filterControlsElement = null;
            let adminCredential = null;
            let adminUser = null;
            let isAdminMode = false;
            let adminResourcesReady = false;
            let adminUi = null;
            let registeredOAuthInfo = null;
            let adminTemplateUrls = { adt: null, traffic: null };
            let adtEditableLayer = null;
            let adtEditableRelationshipInfo = null;
            let adtEditableTable = null;
            let adtEditableForeignKeyField = null;
            let adtParentLookupByGuid = new Map();
            let adtParentLookupByJoinKey = new Map();
            let trafficEditableLayer = null;
            let trafficEditableRelationships = [];
            let trafficRelatedTables = [];
            let trafficEditableForeignKeyField = null;
            let trafficParentLookupById = new Map();
            let trafficParentLookupByGuid = new Map();
            let trafficPrimaryKeyField = null;
            let trafficTableForCounts = null;

            if (!ADMIN_FEATURES_ENABLED) {
                const adminPanelElement = document.getElementById(ADMIN_PANEL_ID);
                if (adminPanelElement) {
                    adminPanelElement.style.display = "none";
                }
            }

            // --- ArcGIS Modules ---
            require([
                "esri/WebMap",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/Graphic",
                "esri/rest/support/Query",
                "esri/rest/support/RelationshipQuery",
                "esri/layers/support/FeatureFilter",
                "esri/geometry/Extent",
                "esri/core/reactiveUtils",
                "esri/widgets/LayerList",
                "esri/identity/IdentityManager",
                "esri/identity/OAuthInfo"
            ], function (
                WebMap, MapView, FeatureLayer, Graphic, Query, RelationshipQuery, FeatureFilter, Extent,
                reactiveUtils, LayerList, IdentityManager, OAuthInfo
            ) {

                // ===========================================================
                // FUNCTION DEFINITIONS
                // ===========================================================

                function addUiElements() {
                    const filterDivTemplate = document.getElementById('filterDivTemplate');
                    const reportingDivTemplate = document.getElementById('reportingDivTemplate');
                    if (!filterDivTemplate || !reportingDivTemplate) { console.error("UI template elements not found!"); return; }
                    const filterDiv = filterDivTemplate.cloneNode(true);
                    filterDiv.id = FILTER_DIV_ID;
                    filterDiv.style.display = 'block';
                    const summaryNode = filterDiv.querySelector('#' + FILTER_STATUS_SUMMARY_ID);
                    if (summaryNode) summaryNode.textContent = 'Loading data...';
                    view.ui.add(filterDiv, "top-right");
                    const reportingDiv = reportingDivTemplate.cloneNode(true);
                    reportingDiv.id = REPORTING_DIV_ID;
                    reportingDiv.style.display = 'flex';
                    reportingDiv.style.alignItems = 'center';
                    view.ui.add(reportingDiv, "top-left");
                }

                async function populateStreetList(spatialLayers) {
                    const streetSet = new Set();
                    const hasMajor = spatialLayers.some(l => l.fields && l.fields.some(f => f.name === MAJOR_STREETS_FIELD));
                    const hasMinor = spatialLayers.some(l => l.fields && l.fields.some(f => f.name === MINOR_STREETS_FIELD));
                    const fieldsToQuery = [];
                    if (hasMajor) fieldsToQuery.push(MAJOR_STREETS_FIELD);
                    if (hasMinor) fieldsToQuery.push(MINOR_STREETS_FIELD);

                    if (fieldsToQuery.length === 0) {
                        console.warn("Neither Major_Streets nor Minor_Streets field found in any loaded FeatureLayer. Cannot populate street list.");
                        streetList = [];
                        return;
                    }

                    console.log("Querying fields for street list:", fieldsToQuery);

                    const query = new Query({
                        where: "1=1",
                        returnDistinctValues: true,
                        outFields: fieldsToQuery,
                        returnGeometry: false
                    });

                    const queryPromises = spatialLayers.map(layer => {
                        const layerHasField = fieldsToQuery.some(fld => layer.fields && layer.fields.some(f => f.name === fld));
                        if (!layerHasField) {
                            return Promise.resolve(); // Resolve immediately if layer lacks fields
                        }

                        return layer.queryFeatures(query)
                            .then(result => {
                                result.features.forEach(feature => {
                                    fieldsToQuery.forEach(fld => {
                                        if (feature.attributes && feature.attributes.hasOwnProperty(fld)) {
                                            const streetName = feature.attributes[fld];
                                            if (streetName && typeof streetName === 'string' && streetName.trim()) {
                                                streetSet.add(streetName.trim());
                                            }
                                        }
                                    });
                                });
                            }).catch(error => console.warn(`Error querying streets from layer ${layer.title || layer.id}:`, error));
                    });

                    await Promise.all(queryPromises);
                    streetList = Array.from(streetSet).sort();
                    console.log(`Populated street list with ${streetList.length} unique names.`);
                }

                async function populateYearsFromRelatedData(spatialLayer) {
                    const layerTitle = spatialLayer && spatialLayer.title ? spatialLayer.title : 'undefined';
                    const layerTitleSafe = spatialLayer && spatialLayer.title ? spatialLayer.title : 'N/A';
                    console.log(`Attempting to populate years from relationships of layer: ${layerTitle}`);
                    if (!spatialLayer || !spatialLayer.relationships || spatialLayer.relationships.length === 0) {
                        console.log(`Layer ${layerTitleSafe} has no relationships defined or is not valid.`);
                        return;
                    }
                    if (!YEAR_FIELD) {
                        console.warn("YEAR_FIELD constant is not defined. Cannot query for years.");
                        return;
                    }

                    const objectIdField = spatialLayer.objectIdField;
                    if (!objectIdField) {
                        console.error(`Layer ${spatialLayer.title || spatialLayer.id} does not have a valid objectIdField.`);
                        return;
                    }

                    const parentQuery = new Query({
                        where: "1=1",
                        returnGeometry: false,
                        outFields: [objectIdField],
                        num: 1000
                    });

                    let parentOids = [];
                    try {
                        const parentResult = await spatialLayer.queryFeatures(parentQuery);
                        parentOids = parentResult.features.map(f => f.attributes[objectIdField]);
                        if (parentOids.length === 0) {
                            console.log("No parent features found, cannot query related data.");
                            return;
                        }
                        if (parentResult.exceededTransferLimit) {
                            console.warn(`Parent feature query exceeded transfer limit for layer ${spatialLayer.title || spatialLayer.id}. Year list might be incomplete.`);
                        }
                    } catch (error) {
                        console.error(`Error querying parent features for layer ${spatialLayer.title || spatialLayer.id}:`, error);
                        return;
                    }

                    const relationshipPromises = [];

                    for (const rel of spatialLayer.relationships) {
                        let relatedTableHasYearField = false;
                        try {
                            const relatedTable = map.allTables.find(t => t.layerId === rel.relatedTableId) || map.allLayers.find(l => l.layerId === rel.relatedTableId);
                            if (relatedTable) {
                                if (!relatedTable.loaded) await relatedTable.load();
                                relatedTableHasYearField = relatedTable.fields && relatedTable.fields.some(f => f.name === YEAR_FIELD);
                            } else {
                                console.warn(`Could not find related table/layer with ID ${rel.relatedTableId} in the map.`);
                            }
                        } catch (loadError) {
                            console.warn(`Error loading related table ${rel.relatedTableId} to check fields:`, loadError);
                        }

                        if (!relatedTableHasYearField) {
                            console.log(`Skipping relationship query for Rel ID ${rel.id} as related table does not contain the field '${YEAR_FIELD}'.`);
                            continue;
                        }

                        const relQuery = new RelationshipQuery({
                            relationshipId: rel.id,
                            objectIds: parentOids,
                            outFields: [YEAR_FIELD],
                            returnGeometry: false
                        });

                        relationshipPromises.push(
                            spatialLayer.queryRelatedFeatures(relQuery)
                                .then(relatedResults => {
                                    for (const parentOid in relatedResults) {
                                        const relatedFeatures = (relatedResults[parentOid] && relatedResults[parentOid].features) ? relatedResults[parentOid].features : [];
                                        relatedFeatures.forEach(relatedFeature => {
                                            if (relatedFeature.attributes && relatedFeature.attributes.hasOwnProperty(YEAR_FIELD)) {
                                                const year = relatedFeature.attributes[YEAR_FIELD];
                                                if (year !== null && year !== undefined && String(year).trim() !== '') {
                                                    allYears.add(String(year));
                                                }
                                            }
                                        });
                                    }
                                })
                                .catch(error => console.warn(`Error querying relationship ID ${rel.id} for layer ${spatialLayer.title || spatialLayer.id}:`, error))
                        );
                    }

                    await Promise.all(relationshipPromises);
                    console.log(`Finished querying relationships for layer ${spatialLayer.title || spatialLayer.id}. Total unique years found: ${allYears.size}`);
                }

                function createFilterElements() {
                    const filterControlsDiv = document.getElementById(FILTER_CONTROLS_ID);
                    if (!filterControlsDiv) { console.error(`Element ID '${FILTER_CONTROLS_ID}' not found.`); return; }
                    filterControlsDiv.innerHTML = '';

                    // Data Type Filter
                    const dataTypes = ["All", "Bikes", "Intersection Info", "PHF", "Pedestrian", "Heavy Vehicles", "Turning Movement"];
                    filterControlsDiv.innerHTML += `<label for="${DATA_TYPE_FILTER_ID}">Data Type:</label><select id="${DATA_TYPE_FILTER_ID}">${dataTypes.map(type => `<option value="${type}">${type}</option>`).join('')}</select>`;

                    // Year Filter (Multiple Select)
                    const sortedYears = Array.from(allYears).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
                    if (sortedYears.length === 0) {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year:</label><select id="${YEAR_FILTER_ID}" disabled><option value="All">No Years Found</option></select>`;
                    } else {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year (Ctrl+Click):</label><select id="${YEAR_FILTER_ID}" multiple size="5"><option value="All" selected>All Years</option>${sortedYears.map(year => `<option value="${year}">${year}</option>`).join('')}</select>`;
                    }

                    // Period Filter
                    const periods = ["All", "AM", "MID", "PM"];
                    filterControlsDiv.innerHTML += `<label for="${PERIOD_FILTER_ID}">Period:</label><select id="${PERIOD_FILTER_ID}">${periods.map(period => `<option value="${period}">${period}</option>`).join('')}</select>`;

                    // Street Name Filter (Autocomplete)
                    filterControlsDiv.innerHTML += `<label for="${STREET_FILTER_ID}">Street Name:</label><input type="text" id="${STREET_FILTER_ID}" placeholder="Type street name...">`;
                }

                function initializeStreetAutocomplete() {
                    const streetInput = $(`#${STREET_FILTER_ID}`);
                    if (streetInput.length) {
                        streetInput.autocomplete({
                            source: streetList,
                            minLength: 0,
                            select: function (event, ui) {
                                $(this).val(ui.item.value);
                                applyFiltersAndDisplay();
                                return false;
                            },
                            change: function (event, ui) {
                                if (!ui.item) {
                                    applyFiltersAndDisplay();
                                }
                            }
                        }).focus(function () {
                            if (!$(this).val()) {
                                $(this).autocomplete("search", "");
                            }
                        });
                    } else {
                        console.error("Street filter input element not found for autocomplete.");
                    }
                }

                function getTableTabButtons() {
                    const tabsContainer = document.getElementById(TABLE_TABS_ID);
                    if (!tabsContainer) return [];
                    return Array.from(tabsContainer.querySelectorAll(`.${TABLE_TAB_BUTTON_CLASS}`));
                }

                function updateTableTabButtons() {
                    const tabButtons = getTableTabButtons();
                    tabButtons.forEach(button => {
                        const tabKey = button.dataset.tab;
                        const isActive = tabKey === currentTableTab;
                        button.classList.toggle(TABLE_TAB_ACTIVE_CLASS, isActive);
                        button.setAttribute("aria-selected", isActive ? "true" : "false");
                        button.setAttribute("tabindex", isActive ? "0" : "-1");
                    });
                }

                function setActiveTableTab(tabKey, options = {}) {
                    if (!tabKey) return;
                    if (tabKey === currentTableTab) {
                        updateTableTabButtons();
                        return;
                    }
                    currentTableTab = tabKey;
                    updateTableTabButtons();
                    if (!options.skipRefresh) {
                        applyFiltersAndDisplay().catch(error => console.error("Error switching table tab:", error));
                    }
                }

                function initializeTableTabs() {
                    const tabButtons = getTableTabButtons();
                    if (tabButtons.length === 0) {
                        console.warn("Table tabs not found in DOM.");
                        return;
                    }
                    tabButtons.forEach(button => {
                        button.addEventListener("click", () => setActiveTableTab(button.dataset.tab));
                    });
                    updateTableTabButtons();
                }

                function collectionToArray(collection) {
                    if (!collection) return [];
                    if (typeof collection.toArray === "function") {
                        return collection.toArray();
                    }
                    if (Array.isArray(collection)) {
                        return collection;
                    }
                    return [];
                }

                function findRootLayerByTitle(title) {
                    if (!map?.layers?.toArray) return null;
                    const normalized = (title || "").trim().toLowerCase();
                    return map.layers.toArray().find(layer => (layer?.title || "").trim().toLowerCase() === normalized) || null;
                }

                function findLayerByTitle(collection, title) {
                    const normalized = (title || "").trim().toLowerCase();
                    for (const layer of collectionToArray(collection)) {
                        const layerTitle = (layer?.title || "").trim().toLowerCase();
                        if (layerTitle === normalized) {
                            return layer;
                        }
                        if (layer?.layers) {
                            const childMatch = findLayerByTitle(layer.layers, title);
                            if (childMatch) return childMatch;
                        }
                    }
                    return null;
                }

                function findLayerByUrlFragment(collection, fragment) {
                    if (!fragment) return null;
                    const lowerFragment = fragment.toLowerCase();
                    for (const layer of collectionToArray(collection)) {
                        const layerUrl = (layer?.url || "").toLowerCase();
                        if (layerUrl.includes(lowerFragment)) {
                            return layer;
                        }
                        if (layer?.layers) {
                            const childMatch = findLayerByUrlFragment(layer.layers, fragment);
                            if (childMatch) return childMatch;
                        }
                    }
                    return null;
                }

                function reorderAdtLayerBelowReference(referenceLayer) {
                    if (!adtLineLayer || !map?.layers?.toArray) return;
                    const rootLayers = map.layers.toArray();
                    const targetIndex = rootLayers.findIndex(layer => layer === referenceLayer);
                    if (targetIndex >= 0) {
                        map.reorder(adtLineLayer, targetIndex + 1);
                    }
                }

                function tryReorderAdtLayer() {
                    if (!adtLineLayer) return false;
                    const referenceLayer = findRootLayerByTitle(ADT_REFERENCE_LAYER_TITLE);
                    if (referenceLayer) {
                        reorderAdtLayerBelowReference(referenceLayer);
                        return true;
                    }
                    return false;
                }

                function addEventListeners() {
                    const filterControls = document.getElementById(FILTER_CONTROLS_ID);
                    const reportingControls = document.getElementById(REPORTING_DIV_ID);
                    const attributeTableElement = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const attributeTableHead = attributeTableElement ? attributeTableElement.querySelector('thead') : null;

                    if (filterControls) {
                        filterControls.addEventListener('change', (event) => {
                            const target = event.target;
                            if (target && target.tagName === 'SELECT') {
                                if (target.id === YEAR_FILTER_ID) {
                                    const selectedOptions = Array.from(target.selectedOptions).map(opt => opt.value);
                                    const allOption = target.querySelector('option[value="All"]');

                                    if (selectedOptions.includes("All") && selectedOptions.length > 1) {
                                        Array.from(target.querySelectorAll('option:not([value="All"])')).forEach(opt => opt.selected = false);
                                        if (allOption) { allOption.selected = true; }
                                    } else if (!selectedOptions.includes("All") && selectedOptions.length > 0 && allOption && allOption.selected) {
                                        allOption.selected = false;
                                    } else if (selectedOptions.length === 0 && allOption) {
                                        allOption.selected = true;
                                    }
                                }
                                applyFiltersAndDisplay();
                            }
                        });

                        filterControls.addEventListener('input', (event) => {
                            const target = event.target;
                            if (target && target.id === STREET_FILTER_ID) {
                                clearTimeout(streetFilterTimeout);
                                streetFilterTimeout = setTimeout(applyFiltersAndDisplay, STREET_FILTER_DEBOUNCE_MS);
                            }
                        });
                    }

                    view.on("click", handleMapClick);

                    if (reportingControls) {
                        reportingControls.addEventListener('click', (event) => {
                            const target = event.target;
                            if (target && target.id === GENERATE_REPORT_BTN_ID) {
                                generateReport();
                            } else if (target && target.id === PRINT_MAP_BTN_ID) {
                                exportMapAsPDF();
                            }
                        });
                    }

                    if (attributeTableHead) {
                        attributeTableHead.addEventListener('click', (event) => {
                            const headerCell = event.target.closest('th');
                            if (headerCell) {
                                const colIndex = Array.from(headerCell.parentNode.children).indexOf(headerCell);
                                sortTable(document.getElementById(ATTRIBUTE_TABLE_ID), colIndex, headerCell);
                            }
                        });
                    }

                    const clearSelectionButtonEl = document.getElementById(CLEAR_SELECTION_BTN_ID);
                    if (clearSelectionButtonEl) {
                        clearSelectionButtonEl.addEventListener('click', () => {
                            clearFeatureSelection();
                        });
                    }

                    const resetFiltersButtonEl = document.getElementById(RESET_FILTERS_BTN_ID);
                    if (resetFiltersButtonEl) {
                        resetFiltersButtonEl.addEventListener('click', () => {
                            resetFiltersToDefaults();
                        });
                    }
                }

                // ===========================================================
                // ADMIN PANEL & AUTHENTICATION
                // ===========================================================
                function getAdminUi() {
                    if (adminUi) {
                        return adminUi;
                    }
                    adminUi = {
                        panel: document.getElementById(ADMIN_PANEL_ID),
                        statusMessage: document.getElementById(ADMIN_STATUS_MESSAGE_ID),
                        signInBtn: document.getElementById(ADMIN_SIGN_IN_BTN_ID),
                        signOutBtn: document.getElementById(ADMIN_SIGN_OUT_BTN_ID),
                        adtTemplateLink: document.getElementById(ADT_TEMPLATE_LINK_ID),
                        trafficTemplateLink: document.getElementById(TRAFFIC_TEMPLATE_LINK_ID),
                        adtCard: document.getElementById(ADT_IMPORT_CARD_ID),
                        trafficCard: document.getElementById(TRAFFIC_IMPORT_CARD_ID),
                        adtUploadBtn: document.getElementById(ADT_UPLOAD_BTN_ID),
                        adtManualBtn: document.getElementById(ADT_MANUAL_ENTRY_BTN_ID),
                        adtFileInput: document.getElementById(ADT_FILE_INPUT_ID),
                        adtFeedback: document.getElementById(ADT_UPLOAD_FEEDBACK_ID),
                        trafficUploadBtn: document.getElementById(TRAFFIC_UPLOAD_BTN_ID),
                        trafficManualBtn: document.getElementById(TRAFFIC_MANUAL_ENTRY_BTN_ID),
                        trafficFileInput: document.getElementById(TRAFFIC_FILE_INPUT_ID),
                        trafficFeedback: document.getElementById(TRAFFIC_UPLOAD_FEEDBACK_ID)
                    };
                    return adminUi;
                }

                function isOAuthConfigured() {
                    return typeof OAUTH_APP_ID === "string" &&
                        OAUTH_APP_ID &&
                        OAUTH_APP_ID !== "REPLACE_WITH_YOUR_APP_ID";
                }

                function setAdminStatus(message, tone) {
                    const ui = getAdminUi();
                    if (!ui.statusMessage) {
                        return;
                    }
                    ui.statusMessage.textContent = message;
                    if (tone) {
                        ui.statusMessage.dataset.statusTone = tone;
                    } else if (ui.statusMessage.dataset.statusTone) {
                        delete ui.statusMessage.dataset.statusTone;
                    }
                }

                function setFeedbackMessage(element, message, tone) {
                    if (!element) {
                        return;
                    }
                    element.textContent = message;
                    if (tone) {
                        element.dataset.statusTone = tone;
                    } else if (element.dataset.statusTone) {
                        delete element.dataset.statusTone;
                    }
                }

                function toggleElementHidden(element, hidden) {
                    if (!element) {
                        return;
                    }
                    element.classList.toggle("admin-hidden", !!hidden);
                }

                function updateAdminUiState() {
                    const ui = getAdminUi();
                    if (!ui.panel) {
                        return;
                    }

                    ui.panel.classList.add("active");

                    const signedIn = !!adminCredential;
                    const resourcesReady = signedIn && adminResourcesReady;

                    if (ui.signInBtn) {
                        ui.signInBtn.disabled = !isOAuthConfigured() || signedIn;
                        toggleElementHidden(ui.signInBtn, signedIn);
                    }
                    if (ui.signOutBtn) {
                        ui.signOutBtn.disabled = !signedIn;
                        toggleElementHidden(ui.signOutBtn, !signedIn);
                    }

                    toggleElementHidden(ui.adtCard, !signedIn);
                    toggleElementHidden(ui.trafficCard, !signedIn);
                    toggleElementHidden(ui.adtTemplateLink, !resourcesReady);
                    toggleElementHidden(ui.trafficTemplateLink, !resourcesReady);

                    if (ui.adtUploadBtn) ui.adtUploadBtn.disabled = !resourcesReady;
                    if (ui.adtFileInput) ui.adtFileInput.disabled = !resourcesReady;
                    if (ui.adtManualBtn) ui.adtManualBtn.disabled = !resourcesReady;

                    if (ui.trafficUploadBtn) ui.trafficUploadBtn.disabled = !resourcesReady;
                    if (ui.trafficFileInput) ui.trafficFileInput.disabled = !resourcesReady;
                    if (ui.trafficManualBtn) ui.trafficManualBtn.disabled = !resourcesReady;
                }

                function handleAdminSignOut() {
                    IdentityManager.destroyCredentials();
                    adminCredential = null;
                    adminUser = null;
                    isAdminMode = false;
                    adminResourcesReady = false;
                    adtEditableLayer = null;
                    adtEditableRelationshipInfo = null;
                    adtEditableTable = null;
                    adtEditableForeignKeyField = null;
                    adtParentLookupByGuid.clear();
                    adtParentLookupByJoinKey.clear();
                    trafficEditableLayer = null;
                    trafficEditableRelationships = [];
                    trafficRelatedTables = [];
                    trafficTableForCounts = null;
                    trafficEditableForeignKeyField = null;
                    trafficPrimaryKeyField = null;
                    trafficParentLookupById.clear();
                    trafficParentLookupByGuid.clear();
                    setAdminStatus("Signed out. Sign in to upload data.");
                    updateAdminUiState();
                    const ui = getAdminUi();
                    if (ui.adtFeedback) ui.adtFeedback.textContent = "";
                    if (ui.trafficFeedback) ui.trafficFeedback.textContent = "";
                    if (ui.adtTemplateLink) ui.adtTemplateLink.removeAttribute("href");
                    if (ui.trafficTemplateLink) ui.trafficTemplateLink.removeAttribute("href");
                    if (adminTemplateUrls.adt) {
                        try { URL.revokeObjectURL(adminTemplateUrls.adt); } catch (error) { console.warn("Failed to revoke ADT template URL:", error); }
                        adminTemplateUrls.adt = null;
                    }
                    if (adminTemplateUrls.traffic) {
                        try { URL.revokeObjectURL(adminTemplateUrls.traffic); } catch (error) { console.warn("Failed to revoke traffic template URL:", error); }
                        adminTemplateUrls.traffic = null;
                    }
                }

                async function handleAdminSignIn(oauthInfo) {
                    if (!oauthInfo || !isOAuthConfigured()) {
                        setAdminStatus("ArcGIS OAuth is not configured. Update OAUTH_APP_ID before enabling uploads.", "error");
                        return;
                    }
                    const ui = getAdminUi();
                    if (ui.signInBtn) ui.signInBtn.disabled = true;
                    setAdminStatus("Signing in...", "info");
                    try {
                        const credential = await IdentityManager.getCredential(oauthInfo.portalUrl + "/sharing");
                        await applySignedInCredential(credential);
                    } catch (error) {
                        if (error && error.message && error.message.indexOf("User canceled") !== -1) {
                            setAdminStatus("Sign-in was cancelled.", "warning");
                        } else {
                            console.error("ArcGIS sign-in failed:", error);
                            setAdminStatus(`Sign-in failed: ${error.message || error}`, "error");
                        }
                    } finally {
                        if (ui.signInBtn) ui.signInBtn.disabled = !!adminCredential;
                    }
                }

                async function applySignedInCredential(credential) {
                    if (!credential) {
                        return;
                    }
                    adminCredential = credential;
                    adminUser = credential.userId || null;
                    isAdminMode = true;
                    adminResourcesReady = false;
                    updateAdminUiState();
                    const displayUser = adminUser || "authenticated user";
                    setAdminStatus(`Signed in as ${displayUser}. Loading editable datasets...`);
                    try {
                        await loadEditableResources();
                        adminResourcesReady = true;
                        updateAdminUiState();
                        refreshAdminTemplateDownloads();
                        setAdminStatus(`Signed in as ${displayUser}. Upload tools are ready.`);
                    } catch (error) {
                        console.error("Failed to load editable resources:", error);
                        setAdminStatus(`Signed in as ${displayUser}, but failed to load editable services: ${error.message || error}.`, "error");
                    }
                }

                function findRelatedForeignKeyField(parentLayer, childLayer, relationshipInfo) {
                    if (!parentLayer || !childLayer || !relationshipInfo) {
                        return null;
                    }
                    const relatedTableId = parentLayer.layerId;
                    const relationshipFromChild = (childLayer.relationships || []).find(rel => rel.relatedTableId === relatedTableId);
                    if (relationshipFromChild && relationshipFromChild.keyField) {
                        return relationshipFromChild.keyField;
                    }
                    const candidates = ["LineGUID", "lineguid", "ParentGUID", "ParentGlobalID", "ParentGuid", "ParentID", "Intersection_ID", "intersection_id", "GlobalID"];
                    const childFieldNames = childLayer.fields ? childLayer.fields.map(f => (f.name || "").toLowerCase()) : [];
                    const match = candidates.find(name => childFieldNames.includes(name.toLowerCase()));
                    return match || null;
                }

                function findFieldNameCaseInsensitive(layer, targetName) {
                    if (!layer || !layer.fields || !targetName) {
                        return null;
                    }
                    const lower = targetName.toLowerCase();
                    const field = layer.fields.find(f => (f.name || "").toLowerCase() === lower);
                    return field ? field.name : null;
                }

                async function loadEditableResources() {
                    if (adminResourcesReady) {
                        return;
                    }
                    if (!adminCredential) {
                        throw new Error("No credential available for loading editable resources.");
                    }

                    const loadTasks = [];

                    const loadAdtTask = (async () => {
                        if (!ADT_EDITABLE_PORTAL_ITEM_ID) {
                            throw new Error("ADT editable portal item ID is not configured.");
                        }
                        adtEditableLayer = await FeatureLayer.fromPortalItem({
                            portalItem: { id: ADT_EDITABLE_PORTAL_ITEM_ID },
                            outFields: ["*"]
                        });
                        await adtEditableLayer.load();
                        adtEditableRelationshipInfo = (adtEditableLayer.relationships || []).find(rel => {
                            const relName = (rel.name || "").toLowerCase();
                            return relName.includes("traffic") || relName.includes("adt") || relName.includes("count") || rel.role === "esriRelRoleOrigin";
                        }) || (adtEditableLayer.relationships && adtEditableLayer.relationships[0]);
                        if (!adtEditableRelationshipInfo) {
                            throw new Error("ADT editable layer does not expose a related table for counts.");
                        }
                        const baseUrl = adtEditableLayer.url.replace(/\/\d+$/, "");
                        adtEditableTable = new FeatureLayer({
                            url: `${baseUrl}/${adtEditableRelationshipInfo.relatedTableId}`,
                            outFields: ["*"]
                        });
                    await adtEditableTable.load();
                    adtEditableForeignKeyField = findRelatedForeignKeyField(adtEditableLayer, adtEditableTable, adtEditableRelationshipInfo);
                    if (!adtEditableForeignKeyField) {
                        console.warn("Unable to determine ADT table foreign key field automatically.");
                    }
                    await rebuildAdtParentLookups();
                })();

                    loadTasks.push(loadAdtTask);

                    const loadTrafficTask = (async () => {
                        if (!TRAFFIC_EDITABLE_PORTAL_ITEM_ID) {
                            throw new Error("Traffic editable portal item ID is not configured.");
                        }
                    trafficEditableLayer = await FeatureLayer.fromPortalItem({
                        portalItem: { id: TRAFFIC_EDITABLE_PORTAL_ITEM_ID },
                        outFields: ["*"]
                    });
                    await trafficEditableLayer.load();
                    trafficEditableRelationships = trafficEditableLayer.relationships ? trafficEditableLayer.relationships.slice() : [];
                    trafficPrimaryKeyField = (trafficEditableRelationships[0] && trafficEditableRelationships[0].keyField) || trafficEditableLayer.globalIdField;
                    trafficRelatedTables = [];
                    trafficTableForCounts = null;
                    if (trafficEditableRelationships.length > 0) {
                        const baseUrl = trafficEditableLayer.url.replace(/\/\d+$/, "");
                        for (const rel of trafficEditableRelationships) {
                                try {
                                    const tableLayer = new FeatureLayer({
                                        url: `${baseUrl}/${rel.relatedTableId}`,
                                        outFields: ["*"]
                                    });
                                    await tableLayer.load();
                                    trafficRelatedTables.push({ relationship: rel, layer: tableLayer });
                                } catch (innerError) {
                                    console.warn(`Failed to load related table ${rel.relatedTableId} for traffic layer:`, innerError);
                                }
                            }
                            const preferredTable = trafficRelatedTables.find(entry => {
                                const name = (entry.relationship?.name || "").toLowerCase();
                                return name.includes("traffic") || name.includes("count");
                            }) || trafficRelatedTables[0];
                            if (preferredTable) {
                            trafficTableForCounts = preferredTable.layer;
                            trafficEditableForeignKeyField = findRelatedForeignKeyField(trafficEditableLayer, trafficTableForCounts, preferredTable.relationship);
                        }
                    }
                    if (!trafficTableForCounts) {
                        console.warn("No related traffic count table could be determined from editable service.");
                    }
                    await rebuildTrafficParentLookups();
                })();

                    loadTasks.push(loadTrafficTask);

                    await Promise.all(loadTasks);
                }

                async function rebuildAdtParentLookups() {
                    adtParentLookupByGuid.clear();
                    adtParentLookupByJoinKey.clear();
                    if (!adtEditableLayer) {
                        return;
                    }
                    await adtEditableLayer.load();
                    const objectIdField = adtEditableLayer.objectIdField;
                    const parentKeyField = (adtEditableRelationshipInfo && adtEditableRelationshipInfo.keyField) || adtEditableLayer.globalIdField;
                    if (!parentKeyField) {
                        console.warn("ADT editable layer is missing a key field definition; parent lookup cannot be built.");
                        return;
                    }
                    const joinKeyField = findFieldNameCaseInsensitive(adtEditableLayer, "join_key");
                    const lineGuidField = findFieldNameCaseInsensitive(adtEditableLayer, "LineGUID");
                    const query = adtEditableLayer.createQuery();
                    query.where = "1=1";
                    query.outFields = Array.from(new Set([objectIdField, parentKeyField, joinKeyField, lineGuidField].filter(Boolean)));
                    query.returnGeometry = false;
                    query.returnExceededLimitFeatures = true;
                    const result = await adtEditableLayer.queryFeatures(query);
                    const features = result && result.features ? result.features : [];
                    if (result && result.exceededTransferLimit) {
                        console.warn("ADT parent lookup query exceeded transfer limit; some features may be missing from the lookup.");
                    }
                    features.forEach(feature => {
                        const attrs = feature.attributes || {};
                        const objectId = attrs[objectIdField];
                        const keyValueRaw = attrs[parentKeyField];
                        const keyValueNormalized = normalizeGuid(keyValueRaw);
                        if (!keyValueNormalized) {
                            return;
                        }
                        const joinKeyRaw = joinKeyField ? attrs[joinKeyField] : null;
                        const joinKeyNormalized = joinKeyRaw ? normalizeJoinKey(joinKeyRaw) : null;
                        const lineGuidRaw = lineGuidField ? attrs[lineGuidField] : null;
                        const lineGuidNormalized = lineGuidRaw ? normalizeGuid(lineGuidRaw) : null;
                        const entry = {
                            objectId,
                            keyFieldName: parentKeyField,
                            keyValueRaw,
                            keyValueNormalized,
                            joinKeyRaw,
                            joinKeyNormalized,
                            lineGuidRaw,
                            lineGuidNormalized,
                            attributes: attrs
                        };
                        adtParentLookupByGuid.set(keyValueNormalized, entry);
                        if (lineGuidNormalized) {
                            adtParentLookupByGuid.set(lineGuidNormalized, entry);
                        }
                        if (joinKeyNormalized) {
                            adtParentLookupByJoinKey.set(joinKeyNormalized, entry);
                        }
                    });
                }

                async function rebuildTrafficParentLookups() {
                    trafficParentLookupById.clear();
                    trafficParentLookupByGuid.clear();
                    if (!trafficEditableLayer) {
                        return;
                    }
                    await trafficEditableLayer.load();
                    const objectIdField = trafficEditableLayer.objectIdField;
                    const primaryKeyField = trafficPrimaryKeyField || trafficEditableLayer.globalIdField;
                    if (!primaryKeyField) {
                        console.warn("Traffic editable layer is missing a key field definition; parent lookup cannot be built.");
                        return;
                    }
                    const intersectionIdField = findFieldNameCaseInsensitive(trafficEditableLayer, "Intersection_ID") ||
                        findFieldNameCaseInsensitive(trafficEditableLayer, "IntersectionID");
                    const keyFieldInfo = trafficEditableLayer.fields.find(f => f.name === primaryKeyField);
                    const keyFieldType = (keyFieldInfo && keyFieldInfo.type) ? keyFieldInfo.type.toLowerCase() : "";
                    const isGuidKey = keyFieldType.includes("guid") || keyFieldType.includes("globalid");
                    const query = trafficEditableLayer.createQuery();
                    query.where = "1=1";
                    query.outFields = Array.from(new Set([objectIdField, primaryKeyField, intersectionIdField].filter(Boolean)));
                    query.returnGeometry = false;
                    query.returnExceededLimitFeatures = true;
                    const result = await trafficEditableLayer.queryFeatures(query);
                    const features = result && result.features ? result.features : [];
                    if (result && result.exceededTransferLimit) {
                        console.warn("Traffic parent lookup query exceeded transfer limit; some features may be missing from the lookup.");
                    }
                    features.forEach(feature => {
                        const attrs = feature.attributes || {};
                        const objectId = attrs[objectIdField];
                        const primaryKeyRaw = attrs[primaryKeyField];
                        const primaryKeyNormalized = isGuidKey
                            ? normalizeGuid(primaryKeyRaw)
                            : (primaryKeyRaw !== null && primaryKeyRaw !== undefined
                                ? String(primaryKeyRaw).trim().toUpperCase()
                                : null);
                        const intersectionIdRaw = intersectionIdField ? attrs[intersectionIdField] : null;
                        const intersectionIdNormalized = intersectionIdRaw ? normalizeJoinKey(intersectionIdRaw) : null;
                        if (!primaryKeyRaw && !intersectionIdNormalized) {
                            return;
                        }
                        const entry = {
                            objectId,
                            primaryKeyField,
                            primaryKeyRaw,
                            primaryKeyNormalized,
                            intersectionIdRaw,
                            intersectionIdNormalized,
                            isGuidKey,
                            attributes: attrs
                        };
                        if (isGuidKey && primaryKeyNormalized) {
                            trafficParentLookupByGuid.set(primaryKeyNormalized, entry);
                        }
                        if (!isGuidKey && primaryKeyNormalized) {
                            trafficParentLookupById.set(primaryKeyNormalized, entry);
                        }
                        if (intersectionIdNormalized) {
                            trafficParentLookupById.set(intersectionIdNormalized, entry);
                        }
                    });
                }

                function normalizeGuid(value) {
                    if (value === null || value === undefined) {
                        return null;
                    }
                    const stringValue = String(value).trim();
                    if (!stringValue) {
                        return null;
                    }
                    return stringValue.replace(/[{}]/g, "").toUpperCase();
                }

                function normalizeJoinKey(value) {
                    if (value === null || value === undefined) {
                        return null;
                    }
                    const stringValue = String(value).trim();
                    return stringValue ? stringValue.toUpperCase() : null;
                }

                function addRowError(errorList, rowIndex, message) {
                    errorList.push({ row: rowIndex, message });
                }

                function formatRowErrorMessages(rowErrors, limit) {
                    if (!Array.isArray(rowErrors) || rowErrors.length === 0) {
                        return "";
                    }
                    const max = Number.isInteger(limit) && limit > 0 ? limit : 5;
                    const slices = rowErrors.slice(0, max).map(err => {
                        const rowLabel = Number.isFinite(err.row) ? `Row ${err.row}` : "Row";
                        return `${rowLabel}: ${err.message}`;
                    });
                    if (rowErrors.length > max) {
                        slices.push(`and ${rowErrors.length - max} more issue(s).`);
                    }
                    return slices.join(" ");
                }

                function sampleValueForField(field) {
                    if (!field) {
                        return "";
                    }
                    switch (field.type) {
                        case "integer":
                        case "small-integer":
                        case "long":
                        case "double":
                        case "single":
                        case "esriFieldTypeInteger":
                        case "esriFieldTypeSmallInteger":
                        case "esriFieldTypeDouble":
                        case "esriFieldTypeSingle":
                            return "0";
                        case "date":
                        case "esriFieldTypeDate":
                            return "2024-01-15";
                        case "guid":
                        case "esriFieldTypeGUID":
                        case "global-id":
                        case "esriFieldTypeGlobalID":
                            return "{GUID}";
                        default:
                            return field.length && field.length < 30 ? "Sample" : "Sample value";
                    }
                }

                function parseDateToEpoch(rawValue, rowIndex, errors, fieldLabel) {
                    if (rawValue === null || rawValue === undefined || rawValue === "") {
                        return null;
                    }
                    if (rawValue instanceof Date) {
                        const time = rawValue.getTime();
                        if (!Number.isNaN(time)) {
                            return time;
                        }
                        addRowError(errors, rowIndex, `Date value for ${fieldLabel} is invalid.`);
                        return undefined;
                    }
                    if (typeof rawValue === "number") {
                        if (!Number.isFinite(rawValue)) {
                            addRowError(errors, rowIndex, `Numeric date value for ${fieldLabel} is invalid.`);
                            return undefined;
                        }
                        if (rawValue > 100000000000) {
                            return Math.trunc(rawValue);
                        }
                        if (window.XLSX && window.XLSX.SSF && typeof window.XLSX.SSF.parse_date_code === "function") {
                            const parsed = window.XLSX.SSF.parse_date_code(rawValue);
                            if (parsed) {
                                const date = new Date(Date.UTC(parsed.y, parsed.m - 1, parsed.d, parsed.H || 0, parsed.M || 0, parsed.S || 0));
                                const time = date.getTime();
                                if (!Number.isNaN(time)) {
                                    return time;
                                }
                            }
                        }
                        const excelEpoch = new Date(Math.round((rawValue - 25569) * 86400) * 1000);
                        const excelTime = excelEpoch.getTime();
                        if (!Number.isNaN(excelTime)) {
                            return excelTime;
                        }
                        addRowError(errors, rowIndex, `Unable to convert numeric date value for ${fieldLabel}.`);
                        return undefined;
                    }
                    if (typeof rawValue === "string") {
                        const trimmed = rawValue.trim();
                        if (!trimmed) {
                            return null;
                        }
                        const parsed = new Date(trimmed);
                        if (!Number.isNaN(parsed.getTime())) {
                            return parsed.getTime();
                        }
                        const normalized = trimmed.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/, "$3-$1-$2");
                        const fallbackDate = new Date(normalized);
                        if (!Number.isNaN(fallbackDate.getTime())) {
                            return fallbackDate.getTime();
                        }
                        addRowError(errors, rowIndex, `Unable to parse date value "${rawValue}" for ${fieldLabel}.`);
                        return undefined;
                    }
                    addRowError(errors, rowIndex, `Unsupported date value for ${fieldLabel}.`);
                    return undefined;
                }

                function castValueForField(field, rawValue, rowIndex, errors) {
                    if (rawValue === null || rawValue === undefined) {
                        return null;
                    }
                    if (typeof rawValue === "string" && rawValue.trim() === "") {
                        return null;
                    }
                    const fieldType = (field.type || "").toLowerCase();
                    if (fieldType.includes("integer") || fieldType === "oid") {
                        const parsed = Number(rawValue);
                        if (Number.isInteger(parsed)) {
                            return parsed;
                        }
                        addRowError(errors, rowIndex, `Value "${rawValue}" is not a valid integer for ${field.alias || field.name}.`);
                        return undefined;
                    }
                    if (fieldType.includes("double") || fieldType.includes("single") || fieldType.includes("float")) {
                        const parsed = Number(rawValue);
                        if (Number.isFinite(parsed)) {
                            return parsed;
                        }
                        addRowError(errors, rowIndex, `Value "${rawValue}" is not a valid number for ${field.alias || field.name}.`);
                        return undefined;
                    }
                    if (fieldType === "date" || fieldType === "esrifieldtypedate") {
                        return parseDateToEpoch(rawValue, rowIndex, errors, field.alias || field.name);
                    }
                    if (fieldType.includes("guid")) {
                        const normalized = normalizeGuid(rawValue);
                        if (!normalized) {
                            addRowError(errors, rowIndex, `Value "${rawValue}" is not a valid GUID for ${field.alias || field.name}.`);
                            return undefined;
                        }
                        return `{${normalized}}`;
                    }
                    if (fieldType.includes("globalid")) {
                        const normalized = normalizeGuid(rawValue);
                        if (!normalized) {
                            addRowError(errors, rowIndex, `Value "${rawValue}" is not a valid GlobalID for ${field.alias || field.name}.`);
                            return undefined;
                        }
                        return `{${normalized}}`;
                    }
                    if (fieldType.includes("string") || fieldType === "text") {
                        return String(rawValue).trim();
                    }
                    return rawValue;
                }

                function buildLowerKeyMap(record) {
                    const map = new Map();
                    if (!record || typeof record !== "object") {
                        return map;
                    }
                    Object.entries(record).forEach(([key, value]) => {
                        if (typeof key === "string") {
                            map.set(key.trim().toLowerCase(), { originalKey: key, value });
                        }
                    });
                    return map;
                }

                function getValueFromMap(lowerKeyMap, candidateNames, includeEmpty) {
                    if (!lowerKeyMap || !(lowerKeyMap instanceof Map)) {
                        return null;
                    }
                    for (const name of candidateNames) {
                        if (!name) continue;
                        const entry = lowerKeyMap.get(name.toLowerCase());
                        if (!entry) continue;
                        const value = entry.value;
                        if (value === null || value === undefined) {
                            if (includeEmpty) return value;
                            continue;
                        }
                        if (typeof value === "string") {
                            const trimmed = value.trim();
                            if (trimmed) {
                                return trimmed;
                            }
                            if (includeEmpty) {
                                return "";
                            }
                        } else {
                            return value;
                        }
                    }
                    return null;
                }

                function escapeCsvValue(value) {
                    if (value === null || value === undefined) {
                        return "";
                    }
                    const stringValue = String(value);
                    if (/[",\r\n]/.test(stringValue)) {
                        return `"${stringValue.replace(/"/g, '""')}"`;
                    }
                    return stringValue;
                }

                function buildCsvTemplate(columns) {
                    if (!columns || columns.length === 0) {
                        return "";
                    }
                    const headerLine = columns.map(col => escapeCsvValue(col.name)).join(",");
                    const sampleLine = columns.map(col => escapeCsvValue(col.sample || "")).join(",");
                    return `${headerLine}\r\n${sampleLine}\r\n`;
                }

                function setTemplateLinkHref(linkElement, csvContent, key) {
                    if (!linkElement) {
                        return;
                    }
                    if (key && adminTemplateUrls[key]) {
                        try {
                            URL.revokeObjectURL(adminTemplateUrls[key]);
                        } catch (error) {
                            console.warn("Failed to revoke object URL:", error);
                        }
                        adminTemplateUrls[key] = null;
                    }
                    if (!csvContent) {
                        linkElement.removeAttribute("href");
                        return;
                    }
                    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
                    const url = URL.createObjectURL(blob);
                    if (key) {
                        adminTemplateUrls[key] = url;
                    }
                    linkElement.href = url;
                }

                function buildAdtTemplateColumns() {
                    if (!adtEditableTable) {
                        return [];
                    }
                    const columns = [];
                    const keyField = adtEditableForeignKeyField ||
                        findFieldNameCaseInsensitive(adtEditableTable, "LineGUID") ||
                        findFieldNameCaseInsensitive(adtEditableTable, "ParentGlobalID") ||
                        findFieldNameCaseInsensitive(adtEditableTable, "GlobalID");
                    if (keyField) {
                        const fieldInfo = adtEditableTable.fields.find(f => f.name === keyField);
                        columns.push({
                            name: keyField,
                            sample: "{LINE-GLOBALID}",
                            alias: fieldInfo?.alias || keyField
                        });
                    }
                    const candidateFields = [
                        { names: ["join_key"], sample: "JOIN-KEY" },
                        { names: ["Year"], sample: new Date().getFullYear().toString() },
                        { names: ["ADT"], sample: "25000" },
                        { names: ["CountDate", "Count_Date"], sample: "2024-01-15" }
                    ];
                    candidateFields.forEach(info => {
                        const actualName = info.names.map(name => findFieldNameCaseInsensitive(adtEditableTable, name)).find(Boolean);
                        if (actualName && !columns.some(col => col.name === actualName)) {
                            const fieldInfo = adtEditableTable.fields.find(f => f.name === actualName);
                            columns.push({
                                name: actualName,
                                sample: info.sample,
                                alias: fieldInfo?.alias || actualName
                            });
                        }
                    });
                    return columns;
                }

                function buildTrafficTemplateColumns() {
                    if (!trafficTableForCounts) {
                        return [];
                    }
                    const table = trafficTableForCounts;
                    const columns = [];
                    const keyField = trafficEditableForeignKeyField ||
                        findFieldNameCaseInsensitive(table, "Intersection_ID") ||
                        findFieldNameCaseInsensitive(table, "IntersectionID");
                    if (keyField) {
                        const keyFieldInfo = table.fields.find(f => f.name === keyField);
                        columns.push({
                            name: keyField,
                            sample: "INTERSECTION-ID",
                            alias: keyFieldInfo?.alias || keyField
                        });
                    }

                    const systemFieldNames = new Set([
                        table.objectIdField?.toLowerCase(),
                        table.globalIdField?.toLowerCase(),
                        "shape",
                        "shape__length",
                        "shape__area",
                        "created_user",
                        "createdate",
                        "creationdate",
                        "creator",
                        "editdate",
                        "editor",
                        "last_edited_user",
                        "last_edited_date"
                    ]);

                    table.fields.forEach(field => {
                        if (!field || !field.name) {
                            return;
                        }
                        const fieldLower = field.name.toLowerCase();
                        if (systemFieldNames.has(fieldLower)) {
                            return;
                        }
                        if (field.type === "oid" || field.type === "geometry" || field.type === "blob" || field.type === "raster") {
                            return;
                        }
                        if (!field.editable && fieldLower !== (keyField ? keyField.toLowerCase() : "")) {
                            return;
                        }
                        if (columns.some(col => col.name === field.name)) {
                            return;
                        }
                        columns.push({
                            name: field.name,
                            sample: sampleValueForField(field),
                            alias: field.alias || field.name
                        });
                    });

                    return columns;
                }

                function refreshAdminTemplateDownloads() {
                    const ui = getAdminUi();
                    if (!ui) {
                        return;
                    }
                    if (!adminResourcesReady) {
                        if (ui.adtTemplateLink) ui.adtTemplateLink.removeAttribute("href");
                        if (ui.trafficTemplateLink) ui.trafficTemplateLink.removeAttribute("href");
                        return;
                    }
                    if (ui.adtTemplateLink) {
                        const adtColumns = buildAdtTemplateColumns();
                        const adtCsv = buildCsvTemplate(adtColumns);
                        setTemplateLinkHref(ui.adtTemplateLink, adtCsv, "adt");
                    }
                    if (ui.trafficTemplateLink) {
                        const trafficColumns = buildTrafficTemplateColumns();
                        const trafficCsv = buildCsvTemplate(trafficColumns);
                        setTemplateLinkHref(ui.trafficTemplateLink, trafficCsv, "traffic");
                    }
                }

                function readTabularFile(file) {
                    return new Promise((resolve, reject) => {
                        if (!file) {
                            reject(new Error("No file provided."));
                            return;
                        }
                        const extension = (file.name.split(".").pop() || "").toLowerCase();
                        if (extension === "csv" || extension === "txt") {
                            if (!window.Papa) {
                                reject(new Error("PapaParse library is unavailable."));
                                return;
                            }
                            window.Papa.parse(file, {
                                header: true,
                                skipEmptyLines: true,
                                dynamicTyping: false,
                                complete: (result) => {
                                    if (result.errors && result.errors.length > 0) {
                                        const firstError = result.errors[0];
                                        reject(new Error(`CSV parsing error (row ${firstError.row}): ${firstError.message}`));
                                    } else {
                                        resolve(result.data || []);
                                    }
                                },
                                error: (error) => reject(error)
                            });
                            return;
                        }

                        if (!window.XLSX) {
                            reject(new Error("SheetJS (XLSX) library is unavailable."));
                            return;
                        }
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            try {
                                const data = event.target.result;
                                const workbook = window.XLSX.read(data, { type: "array" });
                                const firstSheet = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[firstSheet];
                                const json = window.XLSX.utils.sheet_to_json(worksheet, { defval: null });
                                resolve(json);
                            } catch (error) {
                                reject(error);
                            }
                        };
                        reader.onerror = () => reject(reader.error || new Error("Failed to read the selected file."));
                        reader.readAsArrayBuffer(file);
                    });
                }

                async function handleAdtUpload() {
                    const ui = getAdminUi();
                    if (!ui) {
                        return;
                    }
                    if (!adminResourcesReady || !adtEditableTable || !adtEditableForeignKeyField) {
                        setFeedbackMessage(ui.adtFeedback, "ADT upload tools are not ready. Confirm you are signed in and retry.", "error");
                        return;
                    }
                    const fileInput = ui.adtFileInput;
                    const uploadButton = ui.adtUploadBtn;
                    const feedback = ui.adtFeedback;
                    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                        setFeedbackMessage(feedback, "Select a CSV or Excel file before uploading.", "warning");
                        return;
                    }
                    const file = fileInput.files[0];
                    if (!file) {
                        setFeedbackMessage(feedback, "Unable to read the selected file.", "error");
                        return;
                    }
                    if (uploadButton) uploadButton.disabled = true;
                    setFeedbackMessage(feedback, `Processing ${file.name}...`, "info");
                    try {
                        const rows = await readTabularFile(file);
                        const outcome = await processAdtRecords(rows);
                        const tone = outcome.tone || (outcome.success ? "success" : "error");
                        setFeedbackMessage(feedback, outcome.message, tone);
                        if (outcome.success) {
                            fileInput.value = "";
                            await rebuildAdtParentLookups().catch((error) => console.warn("Failed to refresh ADT parent lookup after upload:", error));
                            adtAllParentOids = null;
                            if (adtLineLayer) {
                                adtLineLayer.refresh();
                            }
                            if (adtRelatedTableLayer) {
                                adtRelatedTableLayer.refresh();
                            }
                            applyFiltersAndDisplay().catch(error => console.warn("Failed to refresh view after ADT upload:", error));
                        }
                    } catch (error) {
                        console.error("ADT upload failed:", error);
                        setFeedbackMessage(feedback, `Upload failed: ${error.message || error}`, "error");
                    } finally {
                        if (uploadButton) uploadButton.disabled = false;
                    }
                }

                async function processAdtRecords(records) {
                    if (!Array.isArray(records) || records.length === 0) {
                        return {
                            success: false,
                            tone: "warning",
                            message: "The selected file did not contain any data rows."
                        };
                    }
                    const table = adtEditableTable;
                    if (!table) {
                        throw new Error("ADT editable table is not available.");
                    }
                    const lowerFieldMap = new Map();
                    table.fields.forEach(field => {
                        if (field && field.name) {
                            lowerFieldMap.set(field.name.toLowerCase(), field);
                        }
                    });
                    const objectIdField = table.objectIdField || null;
                    const globalIdField = table.globalIdField || null;
                    const joinKeyField = findFieldNameCaseInsensitive(table, "join_key");
                    const adtValueField = findFieldNameCaseInsensitive(table, "ADT");
                    const yearValueField = findFieldNameCaseInsensitive(table, "Year");
                    const foreignKeyField = adtEditableForeignKeyField;
                    const processedRows = [];
                    const rowsNeedingLookup = [];
                    records.forEach((record, index) => {
                        const rowNumber = index + 2;
                        const errors = [];
                        const lowerMap = buildLowerKeyMap(record);
                        const parentGuidRaw = getValueFromMap(lowerMap, ["lineguid", "line_guid", "line guid"]);
                        const parentJoinKeyRaw = getValueFromMap(lowerMap, ["join_key", "joinkey", "join key"]);
                        const parentGuid = normalizeGuid(parentGuidRaw);
                        const parentJoinKey = normalizeJoinKey(parentJoinKeyRaw);
                        let parentInfo = null;
                        if (parentGuid && adtParentLookupByGuid.has(parentGuid)) {
                            parentInfo = adtParentLookupByGuid.get(parentGuid);
                        }
                        if (!parentInfo && parentJoinKey && adtParentLookupByJoinKey.has(parentJoinKey)) {
                            parentInfo = adtParentLookupByJoinKey.get(parentJoinKey);
                        }
                        if (!parentInfo) {
                            addRowError(errors, rowNumber, "Unable to locate an ADT line using LineGUID or join_key.");
                        }
                        const attributes = {};
                        let updateObjectId = null;
                        let updateGlobalId = null;
                        lowerMap.forEach((entry, lowerKey) => {
                            const field = lowerFieldMap.get(lowerKey);
                            if (!field) {
                                return;
                            }
                            if (objectIdField && field.name === objectIdField) {
                                const parsed = Number(entry.value);
                                if (Number.isInteger(parsed)) {
                                    updateObjectId = parsed;
                                } else if (entry.value !== null && entry.value !== undefined && entry.value !== "") {
                                    addRowError(errors, rowNumber, `OBJECTID value "${entry.value}" is not a valid integer.`);
                                }
                                return;
                            }
                            if (globalIdField && field.name === globalIdField) {
                                const normalized = normalizeGuid(entry.value);
                                if (normalized) {
                                    updateGlobalId = normalized;
                                } else if (entry.value) {
                                    addRowError(errors, rowNumber, `GlobalID value "${entry.value}" is not a valid GUID.`);
                                }
                                return;
                            }
                            const casted = castValueForField(field, entry.value, rowNumber, errors);
                            if (casted !== undefined) {
                                attributes[field.name] = casted;
                            }
                        });
                        if (!parentGuid && !parentJoinKey) {
                            addRowError(errors, rowNumber, "Provide either LineGUID or join_key for each record.");
                        }
                        if (parentInfo && foreignKeyField) {
                            const keyRaw = parentInfo.keyValueRaw || `{${parentInfo.keyValueNormalized}}`;
                            attributes[foreignKeyField] = keyRaw;
                        }
                        if (joinKeyField && parentInfo && parentInfo.joinKeyRaw !== undefined && attributes[joinKeyField] === undefined) {
                            attributes[joinKeyField] = parentInfo.joinKeyRaw;
                        }
                        if (adtValueField && (attributes[adtValueField] === undefined || attributes[adtValueField] === null || attributes[adtValueField] === "")) {
                            addRowError(errors, rowNumber, "ADT field is required.");
                        }
                        if (yearValueField && (attributes[yearValueField] === undefined || attributes[yearValueField] === null || attributes[yearValueField] === "")) {
                            addRowError(errors, rowNumber, "Year field is required.");
                        }
                        const processed = {
                            rowNumber,
                            errors,
                            attributes,
                            parentInfo,
                            updateObjectId,
                            updateGlobalId,
                            originalRecord: record
                        };
                        if (!updateObjectId && updateGlobalId) {
                            rowsNeedingLookup.push(processed);
                        }
                        processedRows.push(processed);
                    });

                    if (rowsNeedingLookup.length > 0 && globalIdField) {
                        await populateAdtObjectIdsFromGlobalIds(rowsNeedingLookup);
                    } else if (rowsNeedingLookup.length > 0 && !globalIdField) {
                        rowsNeedingLookup.forEach(row => addRowError(row.errors, row.rowNumber, "GlobalID updates are not supported for this table. Include OBJECTID instead."));
                    }

                    const rowErrors = [];
                    processedRows.forEach(row => {
                        if (!row.parentInfo) {
                            addRowError(row.errors, row.rowNumber, "Parent ADT line was not resolved.");
                        }
                        if (row.errors.length > 0) {
                            rowErrors.push(...row.errors);
                        }
                    });

                    const addFeatures = [];
                    const addRows = [];
                    const updateFeatures = [];
                    const updateRows = [];
                    processedRows.forEach(row => {
                        if (row.errors.length > 0 || !row.parentInfo) {
                            return;
                        }
                        if (row.updateObjectId) {
                            if (objectIdField) {
                                row.attributes[objectIdField] = row.updateObjectId;
                            }
                            updateFeatures.push({ attributes: row.attributes });
                            updateRows.push(row);
                        } else {
                            addFeatures.push({ attributes: row.attributes });
                            addRows.push(row);
                        }
                    });

                    if (addFeatures.length === 0 && updateFeatures.length === 0) {
                        const message = rowErrors.length > 0
                            ? `No records were uploaded because of validation issues. ${formatRowErrorMessages(rowErrors, 5)}`
                            : "No valid records were found in the upload file.";
                        return {
                            success: false,
                            tone: rowErrors.length > 0 ? "error" : "warning",
                            message
                        };
                    }

                    const payload = {};
                    if (addFeatures.length > 0) payload.addFeatures = addFeatures;
                    if (updateFeatures.length > 0) payload.updateFeatures = updateFeatures;

                    const editResults = await adtEditableTable.applyEdits(payload);
                    const addResults = (editResults && editResults.addFeatureResults) ? editResults.addFeatureResults : [];
                    const updateResults = (editResults && editResults.updateFeatureResults) ? editResults.updateFeatureResults : [];

                    let successfulAdds = 0;
                    let successfulUpdates = 0;
                    const serverErrors = [];

                    addResults.forEach((result, index) => {
                        if (result && result.success) {
                            successfulAdds += 1;
                        } else {
                            const row = addRows[index];
                            const message = result && result.error && result.error.message ? result.error.message : "Unknown error adding record.";
                            serverErrors.push({ row: row ? row.rowNumber : null, message });
                        }
                    });

                    updateResults.forEach((result, index) => {
                        if (result && result.success) {
                            successfulUpdates += 1;
                        } else {
                            const row = updateRows[index];
                            const message = result && result.error && result.error.message ? result.error.message : "Unknown error updating record.";
                            serverErrors.push({ row: row ? row.rowNumber : null, message });
                        }
                    });

                    const combinedErrors = [...rowErrors, ...serverErrors];
                    const totalSuccesses = successfulAdds + successfulUpdates;
                    const parts = [];
                    if (successfulAdds > 0) {
                        parts.push(`${successfulAdds} add${successfulAdds === 1 ? "" : "s"}`);
                    }
                    if (successfulUpdates > 0) {
                        parts.push(`${successfulUpdates} update${successfulUpdates === 1 ? "" : "s"}`);
                    }
                    let message = parts.length > 0 ? `Completed ${parts.join(" and ")}.` : "No changes were applied.";
                    if (combinedErrors.length > 0) {
                        message += ` ${formatRowErrorMessages(combinedErrors, 5)}`;
                    }
                    const tone = combinedErrors.length === 0
                        ? "success"
                        : totalSuccesses > 0 ? "warning" : "error";
                    return {
                        success: totalSuccesses > 0 && combinedErrors.length === 0,
                        tone,
                        message
                    };
                }

                async function populateAdtObjectIdsFromGlobalIds(rows) {
                    if (!adtEditableTable || !Array.isArray(rows) || rows.length === 0) {
                        return;
                    }
                    const globalIds = Array.from(new Set(rows
                        .map(row => row.updateGlobalId)
                        .filter(Boolean)));
                    if (globalIds.length === 0) {
                        return;
                    }
                    const mapping = new Map();
                    const chunkSize = 200;
                    for (let i = 0; i < globalIds.length; i += chunkSize) {
                        const chunk = globalIds.slice(i, i + chunkSize);
                        const query = adtEditableTable.createQuery();
                        query.returnGeometry = false;
                        query.outFields = [
                            adtEditableTable.objectIdField,
                            adtEditableTable.globalIdField
                        ];
                        query.globalIds = chunk.map(guid => `{${guid}}`);
                        try {
                            const response = await adtEditableTable.queryFeatures(query);
                            const features = response && response.features ? response.features : [];
                            features.forEach(feature => {
                                const attrs = feature.attributes || {};
                                const gid = normalizeGuid(attrs[adtEditableTable.globalIdField]);
                                const oid = attrs[adtEditableTable.objectIdField];
                                if (gid && Number.isInteger(oid)) {
                                    mapping.set(gid, oid);
                                }
                            });
                        } catch (error) {
                            console.warn("Failed to query ADT table for GlobalIDs:", error);
                        }
                    }
                    rows.forEach(row => {
                        if (!row.updateGlobalId) {
                            return;
                        }
                        const objectId = mapping.get(row.updateGlobalId);
                        if (Number.isInteger(objectId)) {
                            row.updateObjectId = objectId;
                        } else {
                            addRowError(row.errors, row.rowNumber, `Could not find an existing record with GlobalID ${row.updateGlobalId}.`);
                        }
                    });
                }

                async function handleTrafficUpload() {
                    const ui = getAdminUi();
                    if (!ui) {
                        return;
                    }
                    if (!adminResourcesReady || !trafficTableForCounts || !trafficEditableForeignKeyField) {
                        setFeedbackMessage(ui.trafficFeedback, "Traffic upload tools are not ready. Confirm you are signed in and retry.", "error");
                        return;
                    }
                    const fileInput = ui.trafficFileInput;
                    const uploadButton = ui.trafficUploadBtn;
                    const feedback = ui.trafficFeedback;
                    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                        setFeedbackMessage(feedback, "Select a CSV or Excel file before uploading.", "warning");
                        return;
                    }
                    const file = fileInput.files[0];
                    if (!file) {
                        setFeedbackMessage(feedback, "Unable to read the selected file.", "error");
                        return;
                    }
                    if (uploadButton) uploadButton.disabled = true;
                    setFeedbackMessage(feedback, `Processing ${file.name}...`, "info");
                    try {
                        const rows = await readTabularFile(file);
                        const outcome = await processTrafficRecords(rows);
                        const tone = outcome.tone || (outcome.success ? "success" : "error");
                        setFeedbackMessage(feedback, outcome.message, tone);
                        if (outcome.success) {
                            fileInput.value = "";
                            if (trafficTableForCounts) {
                                trafficTableForCounts.refresh();
                            }
                            applyFiltersAndDisplay().catch(error => console.warn("Failed to refresh view after traffic upload:", error));
                        }
                    } catch (error) {
                        console.error("Traffic upload failed:", error);
                        setFeedbackMessage(feedback, `Upload failed: ${error.message || error}`, "error");
                    } finally {
                        if (uploadButton) uploadButton.disabled = false;
                    }
                }

                async function processTrafficRecords(records) {
                    if (!Array.isArray(records) || records.length === 0) {
                        return {
                            success: false,
                            tone: "warning",
                            message: "The selected file did not contain any data rows."
                        };
                    }
                    const table = trafficTableForCounts;
                    if (!table) {
                        throw new Error("Traffic related table is not available.");
                    }
                    const lowerFieldMap = new Map();
                    table.fields.forEach(field => {
                        if (field && field.name) {
                            lowerFieldMap.set(field.name.toLowerCase(), field);
                        }
                    });
                    const objectIdField = table.objectIdField || null;
                    const globalIdField = table.globalIdField || null;
                    const intersectionTableField = findFieldNameCaseInsensitive(table, "Intersection_ID") ||
                        findFieldNameCaseInsensitive(table, "IntersectionID");
                    const foreignKeyField = trafficEditableForeignKeyField;
                    const foreignKeyFieldInfo = foreignKeyField
                        ? table.fields.find(field => field.name === foreignKeyField)
                        : null;
                    const foreignKeyFieldType = (foreignKeyFieldInfo && foreignKeyFieldInfo.type)
                        ? foreignKeyFieldInfo.type.toLowerCase()
                        : "";
                    const foreignKeyIsGuid = foreignKeyFieldType.includes("guid") || foreignKeyFieldType.includes("globalid");
                    const majorStreetField = findFieldNameCaseInsensitive(table, "Major_Street") ||
                        findFieldNameCaseInsensitive(table, "Major_Streets");
                    const minorStreetField = findFieldNameCaseInsensitive(table, "Minor_Street") ||
                        findFieldNameCaseInsensitive(table, "Minor_Streets");
                    const yearField = findFieldNameCaseInsensitive(table, "Year");
                    const periodField = findFieldNameCaseInsensitive(table, "Period");
                    const dataTypeField = findFieldNameCaseInsensitive(table, "Data_Type");
                    const directionalFieldMap = {
                        S: findFieldNameCaseInsensitive(table, "S"),
                        W: findFieldNameCaseInsensitive(table, "W"),
                        N: findFieldNameCaseInsensitive(table, "N"),
                        E: findFieldNameCaseInsensitive(table, "E"),
                        EB: findFieldNameCaseInsensitive(table, "EB"),
                        WB: findFieldNameCaseInsensitive(table, "WB"),
                        SB: findFieldNameCaseInsensitive(table, "SB"),
                        Intersection_Value: findFieldNameCaseInsensitive(table, "Intersection_Value"),
                        EBT: findFieldNameCaseInsensitive(table, "EBT"),
                        EBR: findFieldNameCaseInsensitive(table, "EBR"),
                        WBL: findFieldNameCaseInsensitive(table, "WBL"),
                        WBT: findFieldNameCaseInsensitive(table, "WBT"),
                        WBR: findFieldNameCaseInsensitive(table, "WBR"),
                        NBL: findFieldNameCaseInsensitive(table, "NBL"),
                        NBT: findFieldNameCaseInsensitive(table, "NBT"),
                        NBR: findFieldNameCaseInsensitive(table, "NBR"),
                        SBL: findFieldNameCaseInsensitive(table, "SBL"),
                        SBT: findFieldNameCaseInsensitive(table, "SBT"),
                        SBR: findFieldNameCaseInsensitive(table, "SBR")
                    };
                    const baseRequiredFields = [
                        { field: majorStreetField, label: "Major_Street" },
                        { field: minorStreetField, label: "Minor_Street" },
                        { field: yearField, label: "Year" },
                        { field: periodField, label: "Period" },
                        { field: dataTypeField, label: "Data_Type" }
                    ].filter(entry => !!entry.field);
                    const processedRows = [];
                    const rowsNeedingLookup = [];
                    records.forEach((record, index) => {
                        const rowNumber = index + 2;
                        const errors = [];
                        const lowerMap = buildLowerKeyMap(record);
                        const intersectionCandidates = ["intersection_id", "intersectionid", "intersection id"];
                        const guidCandidates = ["parentglobalid", "parent_globalid", "intersection_globalid", "intersectionguid", "intersection_guid", "globalid_parent"];
                        if (foreignKeyField) {
                            const fkLower = foreignKeyField.toLowerCase();
                            if (foreignKeyIsGuid) {
                                guidCandidates.push(fkLower);
                            } else {
                                intersectionCandidates.push(fkLower);
                            }
                        }
                        const intersectionIdRaw = getValueFromMap(lowerMap, intersectionCandidates);
                        const parentGuidRaw = getValueFromMap(lowerMap, guidCandidates);
                        const intersectionIdNormalized = intersectionIdRaw ? normalizeJoinKey(intersectionIdRaw) : null;
                        const parentGuidNormalized = normalizeGuid(parentGuidRaw);
                        let parentInfo = null;
                        if (intersectionIdNormalized && trafficParentLookupById.has(intersectionIdNormalized)) {
                            parentInfo = trafficParentLookupById.get(intersectionIdNormalized);
                        }
                        if (!parentInfo && parentGuidNormalized && trafficParentLookupByGuid.has(parentGuidNormalized)) {
                            parentInfo = trafficParentLookupByGuid.get(parentGuidNormalized);
                        }
                        if (!parentInfo) {
                            addRowError(errors, rowNumber, "Unable to locate an intersection using Intersection_ID or parent GlobalID.");
                        }
                        const attributes = {};
                        let updateObjectId = null;
                        let updateGlobalId = null;
                        lowerMap.forEach((entry, lowerKey) => {
                            const field = lowerFieldMap.get(lowerKey);
                            if (!field) {
                                return;
                            }
                            if (objectIdField && field.name === objectIdField) {
                                const parsed = Number(entry.value);
                                if (Number.isInteger(parsed)) {
                                    updateObjectId = parsed;
                                } else if (entry.value !== null && entry.value !== undefined && entry.value !== "") {
                                    addRowError(errors, rowNumber, `OBJECTID value "${entry.value}" is not a valid integer.`);
                                }
                                return;
                            }
                            if (globalIdField && field.name === globalIdField) {
                                const normalized = normalizeGuid(entry.value);
                                if (normalized) {
                                    updateGlobalId = normalized;
                                } else if (entry.value) {
                                    addRowError(errors, rowNumber, `GlobalID value "${entry.value}" is not a valid GUID.`);
                                }
                                return;
                            }
                            const casted = castValueForField(field, entry.value, rowNumber, errors);
                            if (casted !== undefined) {
                                attributes[field.name] = casted;
                            }
                        });
                        if (!intersectionIdRaw && !parentGuidRaw) {
                            addRowError(errors, rowNumber, "Provide Intersection_ID or parent GlobalID for each record.");
                        }
                        if (parentInfo && foreignKeyField) {
                            let keyValue;
                            if (foreignKeyIsGuid || parentInfo.isGuidKey) {
                                const guidValue = parentInfo.primaryKeyRaw || parentInfo.primaryKeyNormalized;
                                keyValue = guidValue ? `{${normalizeGuid(guidValue)}}` : undefined;
                            } else {
                                keyValue = parentInfo.primaryKeyRaw !== null && parentInfo.primaryKeyRaw !== undefined
                                    ? parentInfo.primaryKeyRaw
                                    : parentInfo.intersectionIdRaw;
                            }
                            if (keyValue !== undefined) {
                                attributes[foreignKeyField] = keyValue;
                            }
                        }
                        if (intersectionTableField && parentInfo && parentInfo.intersectionIdRaw !== undefined && attributes[intersectionTableField] === undefined) {
                            attributes[intersectionTableField] = parentInfo.intersectionIdRaw;
                        }

                        baseRequiredFields.forEach(({ field, label }) => {
                            if (attributes[field] === undefined || attributes[field] === null || (typeof attributes[field] === "string" && attributes[field].trim() === "")) {
                                addRowError(errors, rowNumber, `${label} is required.`);
                            }
                        });

                        let dataTypeValue = dataTypeField ? attributes[dataTypeField] : null;
                        if (typeof dataTypeValue === "string") {
                            dataTypeValue = dataTypeValue.trim();
                        }
                        const dataTypeLower = dataTypeValue ? dataTypeValue.toLowerCase() : "";

                        if (dataTypeLower === "bike" || dataTypeLower === "bikes" || dataTypeLower === "bicycle" || dataTypeLower === "ped" || dataTypeLower === "pedestrian") {
                            ["S", "W", "N", "E"].forEach(dir => {
                                const fieldName = directionalFieldMap[dir];
                                if (fieldName && (attributes[fieldName] === undefined || attributes[fieldName] === null || attributes[fieldName] === "")) {
                                    addRowError(errors, rowNumber, `${dir} value is required for ${dataTypeValue || "Bike/Pedestrian"} records.`);
                                }
                            });
                        }

                        if (dataTypeLower === "turning movement heavy vehicles" || dataTypeLower === "turningmovementheavyvehicles") {
                            ["EBT", "EBR", "WBL", "WBT", "WBR", "NBL", "NBT", "NBR", "SBT", "SBR", "SBL"].forEach(dir => {
                                const fieldName = directionalFieldMap[dir];
                                if (fieldName && (attributes[fieldName] === undefined || attributes[fieldName] === null || attributes[fieldName] === "")) {
                                    addRowError(errors, rowNumber, `${dir} value is required for Turning Movement Heavy Vehicles records.`);
                                }
                            });
                        }

                        if (dataTypeLower === "phf") {
                            const ebField = directionalFieldMap.EB;
                            const wbField = directionalFieldMap.WB;
                            const sbField = directionalFieldMap.SB;
                            const intersectionValueField = directionalFieldMap.Intersection_Value;
                            const hasDirectionalTotals = [ebField, wbField, sbField].every(fieldName => fieldName && attributes[fieldName] !== undefined && attributes[fieldName] !== null && attributes[fieldName] !== "");
                            const hasIntersectionValue = intersectionValueField && attributes[intersectionValueField] !== undefined && attributes[intersectionValueField] !== null && attributes[intersectionValueField] !== "";
                            if (!hasDirectionalTotals && !hasIntersectionValue) {
                                addRowError(errors, rowNumber, "PHF records require EB, WB, and SB values or an Intersection_Value.");
                            }
                        }

                        const processed = {
                            rowNumber,
                            errors,
                            attributes,
                            parentInfo,
                            updateObjectId,
                            updateGlobalId,
                            originalRecord: record
                        };
                        if (!updateObjectId && updateGlobalId) {
                            rowsNeedingLookup.push(processed);
                        }
                        processedRows.push(processed);
                    });

                    if (rowsNeedingLookup.length > 0 && globalIdField) {
                        await populateTrafficObjectIdsFromGlobalIds(rowsNeedingLookup);
                    } else if (rowsNeedingLookup.length > 0 && !globalIdField) {
                        rowsNeedingLookup.forEach(row => addRowError(row.errors, row.rowNumber, "GlobalID updates are not supported for this table. Include OBJECTID instead."));
                    }

                    const rowErrors = [];
                    processedRows.forEach(row => {
                        if (!row.parentInfo) {
                            addRowError(row.errors, row.rowNumber, "Parent intersection was not resolved.");
                        }
                        if (row.errors.length > 0) {
                            rowErrors.push(...row.errors);
                        }
                    });

                    const addFeatures = [];
                    const addRows = [];
                    const updateFeatures = [];
                    const updateRows = [];
                    processedRows.forEach(row => {
                        if (row.errors.length > 0 || !row.parentInfo) {
                            return;
                        }
                        if (row.updateObjectId) {
                            if (objectIdField) {
                                row.attributes[objectIdField] = row.updateObjectId;
                            }
                            updateFeatures.push({ attributes: row.attributes });
                            updateRows.push(row);
                        } else {
                            addFeatures.push({ attributes: row.attributes });
                            addRows.push(row);
                        }
                    });

                    if (addFeatures.length === 0 && updateFeatures.length === 0) {
                        const message = rowErrors.length > 0
                            ? `No records were uploaded because of validation issues. ${formatRowErrorMessages(rowErrors, 5)}`
                            : "No valid records were found in the upload file.";
                        return {
                            success: false,
                            tone: rowErrors.length > 0 ? "error" : "warning",
                            message
                        };
                    }

                    const payload = {};
                    if (addFeatures.length > 0) payload.addFeatures = addFeatures;
                    if (updateFeatures.length > 0) payload.updateFeatures = updateFeatures;

                    const editResults = await trafficTableForCounts.applyEdits(payload);
                    const addResults = (editResults && editResults.addFeatureResults) ? editResults.addFeatureResults : [];
                    const updateResults = (editResults && editResults.updateFeatureResults) ? editResults.updateFeatureResults : [];

                    let successfulAdds = 0;
                    let successfulUpdates = 0;
                    const serverErrors = [];

                    addResults.forEach((result, index) => {
                        if (result && result.success) {
                            successfulAdds += 1;
                        } else {
                            const row = addRows[index];
                            const message = result && result.error && result.error.message ? result.error.message : "Unknown error adding record.";
                            serverErrors.push({ row: row ? row.rowNumber : null, message });
                        }
                    });

                    updateResults.forEach((result, index) => {
                        if (result && result.success) {
                            successfulUpdates += 1;
                        } else {
                            const row = updateRows[index];
                            const message = result && result.error && result.error.message ? result.error.message : "Unknown error updating record.";
                            serverErrors.push({ row: row ? row.rowNumber : null, message });
                        }
                    });

                    const combinedErrors = [...rowErrors, ...serverErrors];
                    const totalSuccesses = successfulAdds + successfulUpdates;
                    const parts = [];
                    if (successfulAdds > 0) {
                        parts.push(`${successfulAdds} add${successfulAdds === 1 ? "" : "s"}`);
                    }
                    if (successfulUpdates > 0) {
                        parts.push(`${successfulUpdates} update${successfulUpdates === 1 ? "" : "s"}`);
                    }
                    let message = parts.length > 0 ? `Completed ${parts.join(" and ")}.` : "No changes were applied.";
                    if (combinedErrors.length > 0) {
                        message += ` ${formatRowErrorMessages(combinedErrors, 5)}`;
                    }
                    const tone = combinedErrors.length === 0
                        ? "success"
                        : totalSuccesses > 0 ? "warning" : "error";
                    return {
                        success: totalSuccesses > 0 && combinedErrors.length === 0,
                        tone,
                        message
                    };
                }

                async function populateTrafficObjectIdsFromGlobalIds(rows) {
                    if (!trafficTableForCounts || !Array.isArray(rows) || rows.length === 0) {
                        return;
                    }
                    const globalIds = Array.from(new Set(rows
                        .map(row => row.updateGlobalId)
                        .filter(Boolean)));
                    if (globalIds.length === 0) {
                        return;
                    }
                    const mapping = new Map();
                    const chunkSize = 200;
                    for (let i = 0; i < globalIds.length; i += chunkSize) {
                        const chunk = globalIds.slice(i, i + chunkSize);
                        const query = trafficTableForCounts.createQuery();
                        query.returnGeometry = false;
                        query.outFields = [
                            trafficTableForCounts.objectIdField,
                            trafficTableForCounts.globalIdField
                        ];
                        query.globalIds = chunk.map(guid => `{${guid}}`);
                        try {
                            const response = await trafficTableForCounts.queryFeatures(query);
                            const features = response && response.features ? response.features : [];
                            features.forEach(feature => {
                                const attrs = feature.attributes || {};
                                const gid = normalizeGuid(attrs[trafficTableForCounts.globalIdField]);
                                const oid = attrs[trafficTableForCounts.objectIdField];
                                if (gid && Number.isInteger(oid)) {
                                    mapping.set(gid, oid);
                                }
                            });
                        } catch (error) {
                            console.warn("Failed to query traffic table for GlobalIDs:", error);
                        }
                    }
                    rows.forEach(row => {
                        if (!row.updateGlobalId) {
                            return;
                        }
                        const objectId = mapping.get(row.updateGlobalId);
                        if (Number.isInteger(objectId)) {
                            row.updateObjectId = objectId;
                        } else {
                            addRowError(row.errors, row.rowNumber, `Could not find an existing record with GlobalID ${row.updateGlobalId}.`);
                        }
                    });
                }

                function initializeAdminPanel(oauthInfo) {
                    const ui = getAdminUi();
                    if (!ui.panel) {
                        console.warn("Admin panel container not found; admin tools will be disabled.");
                        return;
                    }

                    updateAdminUiState();

                    if (!isOAuthConfigured()) {
                        setAdminStatus("ArcGIS sign-in is not configured. Set OAUTH_APP_ID to enable uploads.", "warning");
                        if (ui.signInBtn) {
                            ui.signInBtn.disabled = true;
                        }
                        return;
                    }

                    if (ui.signInBtn) {
                        ui.signInBtn.addEventListener("click", () => handleAdminSignIn(oauthInfo));
                    }
                    if (ui.signOutBtn) {
                        ui.signOutBtn.addEventListener("click", () => handleAdminSignOut());
                    }

                    if (ui.adtUploadBtn) {
                        ui.adtUploadBtn.addEventListener("click", () => handleAdtUpload());
                    }
                    if (ui.adtManualBtn) {
                        ui.adtManualBtn.addEventListener("click", () => setFeedbackMessage(ui.adtFeedback, "Manual ADT entry is not available yet. Use the upload workflow.", "warning"));
                    }
                    if (ui.trafficUploadBtn) {
                        ui.trafficUploadBtn.addEventListener("click", () => handleTrafficUpload());
                    }
                    if (ui.trafficManualBtn) {
                        ui.trafficManualBtn.addEventListener("click", () => setFeedbackMessage(ui.trafficFeedback, "Manual traffic entry is not available yet. Use the upload workflow.", "warning"));
                    }

                    IdentityManager.checkSignInStatus(oauthInfo.portalUrl + "/sharing").then((credential) => {
                        applySignedInCredential(credential);
                    }).catch(() => {
                        setAdminStatus("Sign in with your ArcGIS Online credentials to upload data.");
                        updateAdminUiState();
                    });
                }

                function updateFilterStatusSummary(totalConsidered, totalDisplayed, selectionCount, isFilteringSelection) {
                    const summaryNodes = document.querySelectorAll('#' + FILTER_STATUS_SUMMARY_ID);
                    const tableSummaryNode = document.getElementById(TABLE_SUMMARY_ID);
                    if (summaryNodes.length === 0 && !tableSummaryNode) {
                        return;
                    }

                    const isAdtMode = currentTableTab === TABLE_TAB_ADT;
                    const normalizedTotalConsidered = Number.isFinite(totalConsidered) && totalConsidered >= 0 ? totalConsidered : 0;
                    const normalizedTotalDisplayed = Number.isFinite(totalDisplayed) && totalDisplayed >= 0 ? totalDisplayed : 0;

                    let baseText;
                    if (isAdtMode) {
                        if (normalizedTotalConsidered > 0) {
                            baseText = `${normalizedTotalDisplayed.toLocaleString()} ADT record${normalizedTotalDisplayed === 1 ? '' : 's'} displayed from ${normalizedTotalConsidered.toLocaleString()} line${normalizedTotalConsidered === 1 ? '' : 's'}.`;
                        } else {
                            baseText = "No ADT data is currently available for the selected filters.";
                        }
                    } else {
                        const consideredLabel = isFilteringSelection ? "selected feature(s)" : "visible feature(s)";
                        if (normalizedTotalConsidered > 0) {
                            baseText = `${normalizedTotalDisplayed.toLocaleString()} of ${normalizedTotalConsidered.toLocaleString()} ${consideredLabel} match current filters.`;
                        } else {
                            baseText = "No map features are currently available for the selected filters.";
                        }
                    }

                    let selectionText;
                    if (isAdtMode) {
                        selectionText = adtSelectedOids.size > 0
                            ? `${adtSelectedOids.size.toLocaleString()} ADT line${adtSelectedOids.size === 1 ? '' : 's'} selected.`
                            : "No ADT selection active.";
                    } else if (selectedFeatures.length > 0) {
                        selectionText = `${selectedFeatures.length.toLocaleString()} feature${selectedFeatures.length === 1 ? '' : 's'} selected.`;
                    } else if (adtSelectedOids.size > 0) {
                        selectionText = `${adtSelectedOids.size.toLocaleString()} ADT line${adtSelectedOids.size === 1 ? '' : 's'} selected.`;
                    } else {
                        selectionText = "No selection active.";
                    }

                    const filterParts = [];
                    if (isAdtMode) {
                        if (currentYears.length > 0) filterParts.push(`Year=${currentYears.join(', ')}`);
                    } else {
                        if (currentDataType !== "All") filterParts.push(`Type=${currentDataType}`);
                        if (currentYears.length > 0) filterParts.push(`Year=${currentYears.join(', ')}`);
                        if (currentPeriod !== "All") filterParts.push(`Period=${currentPeriod}`);
                        if (currentStreet) filterParts.push(`Street contains "${currentStreet}"`);
                    }
                    const filtersDescription = filterParts.length > 0 ? `Active filters: ${filterParts.join('; ')}.` : "Active filters: none.";

                    const clearSelectionButton = document.getElementById(CLEAR_SELECTION_BTN_ID);
                    if (clearSelectionButton) {
                        clearSelectionButton.disabled = (selectedFeatures.length + adtSelectedOids.size) === 0;
                    }
                    const resetFiltersButton = document.getElementById(RESET_FILTERS_BTN_ID);
                    if (resetFiltersButton) {
                        const hasActiveFilter = currentDataType !== "All" || currentYears.length > 0 || currentPeriod !== "All" || currentStreet;
                        resetFiltersButton.disabled = !hasActiveFilter;
                    }

                    const baseMessage = `${baseText} ${selectionText}`.trim();
                    if (summaryNodes.length > 0) {
                        summaryNodes.forEach(node => {
                            node.textContent = `${baseMessage} ${filtersDescription}`.trim();
                        });
                    }
                    if (tableSummaryNode) {
                        tableSummaryNode.textContent = baseMessage;
                        tableSummaryNode.setAttribute('title', filtersDescription);
                    }
                }
                function resetFiltersToDefaults() {
                    const dataTypeSelect = document.getElementById(DATA_TYPE_FILTER_ID);
                    if (dataTypeSelect) dataTypeSelect.value = "All";
                    const yearSelect = document.getElementById(YEAR_FILTER_ID);
                    if (yearSelect) {
                        Array.from(yearSelect.options).forEach(option => option.selected = option.value === "All");
                    }
                    const periodSelect = document.getElementById(PERIOD_FILTER_ID);
                    if (periodSelect) periodSelect.value = "All";
                    const streetInput = document.getElementById(STREET_FILTER_ID);
                    if (streetInput) streetInput.value = "";
                    clearTimeout(streetFilterTimeout);
                    applyFiltersAndDisplay().catch(error => console.error("Error resetting filters:", error));
                }

                function clearFeatureSelection() {
                    const hadSelection = selectedFeatures.length > 0 || adtSelectedOids.size > 0;
                    if (!hadSelection) {
                        return;
                    }
                    selectedFeatures = [];
                    adtSelectedOids.clear();
                    clearAllHighlights();
                    applyFiltersAndDisplay().catch(error => console.error("Error clearing selection:", error));
                }
                function readFilterControlValues() {
                    const dataTypeSelect = document.getElementById(DATA_TYPE_FILTER_ID);
                    const yearSelect = document.getElementById(YEAR_FILTER_ID);
                    const periodSelect = document.getElementById(PERIOD_FILTER_ID);
                    const streetInput = document.getElementById(STREET_FILTER_ID);

                    currentDataType = (dataTypeSelect && dataTypeSelect.value) ? dataTypeSelect.value : "All";
                    currentPeriod = (periodSelect && periodSelect.value) ? periodSelect.value : "All";
                    currentStreet = streetInput && typeof streetInput.value === "string" ? streetInput.value.trim() : "";

                    currentYears = yearSelect ? Array.from(yearSelect.selectedOptions).map(opt => opt.value) : [];
                    if (currentYears.includes("All") || currentYears.length === 0) {
                        currentYears = [];
                    } else {
                        currentYears = currentYears.filter(y => y !== "All");
                    }
                }

                async function applyFiltersAndDisplay() {
                    showLoadingSpinner();
                    console.log("Applying filters...");
                    try {
                        readFilterControlValues();
                        if (currentTableTab === TABLE_TAB_ADT) {
                            await refreshAdtTable();
                        } else {
                            await refreshFeatureTable();
                        }
                    } catch (error) {
                        console.error("Error applying filters:", error);
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                async function refreshFeatureTable() {
                    const escapedStreet = currentStreet.replace(/'/g, "''");
                    let definitionExpression = "1=1";
                    if (currentStreet && MAJOR_STREETS_FIELD && MINOR_STREETS_FIELD) {
                        const hasMajor = allLayers.some(l => l.fields && l.fields.some(f => f.name === MAJOR_STREETS_FIELD));
                        const hasMinor = allLayers.some(l => l.fields && l.fields.some(f => f.name === MINOR_STREETS_FIELD));
                        const conditions = [];
                        if (hasMajor) conditions.push(`${MAJOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (hasMinor) conditions.push(`${MINOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (conditions.length > 0) {
                            definitionExpression = `(${conditions.join(' OR ')})`;
                        }
                    }

                    allLayers.forEach(layer => {
                        if (layer.definitionExpression !== definitionExpression) {
                            layer.definitionExpression = definitionExpression;
                        }
                    });

                    let baseFeaturesToFilter = [];
                    const isFilteringSelection = selectedFeatures.length > 0;

                    if (isFilteringSelection) {
                        baseFeaturesToFilter = selectedFeatures;
                        await clearAllLayerViewFilters();
                    } else {
                        baseFeaturesToFilter = await queryAllVisibleFeaturesAcrossLayers(allLayers);
                    }

                    relatedDataCache = await fetchRelatedDataForFeatures(baseFeaturesToFilter);
                    filteredAndVisibleFeatures = clientSideFilterFeatures(baseFeaturesToFilter, relatedDataCache, currentYears, currentPeriod, currentDataType);
                    await updateMapViewBasedOnFilters(isFilteringSelection, filteredAndVisibleFeatures);
                    displayAttributes(filteredAndVisibleFeatures, relatedDataCache);
                    if (adtLineLayer && adtSelectedOids.size > 0) {
                        try {
                            const lv = await view.whenLayerView(adtLineLayer);
                            if (lv) {
                                if (highlightHandles[adtLineLayer.id]) {
                                    highlightHandles[adtLineLayer.id].remove();
                                }
                                highlightHandles[adtLineLayer.id] = lv.highlight(Array.from(adtSelectedOids));
                            }
                        } catch (error) {
                            console.warn("Highlight error for ADT layer:", error);
                        }
                    }

                    const effectiveSelectionCount = selectedFeatures.length + adtSelectedOids.size;
                    updateFilterStatusSummary(baseFeaturesToFilter.length, filteredAndVisibleFeatures.length, effectiveSelectionCount, isFilteringSelection);
                }

                function buildAdtYearWhereClause(years) {
                    if (!years || years.length === 0) return null;
                    const sanitized = years
                        .map(year => String(year).trim())
                        .filter(Boolean)
                        .map(val => `'${val.replace(/'/g, "''")}'`);
                    if (sanitized.length === 0) return null;
                    return `${YEAR_FIELD} IN (${sanitized.join(",")})`;
                }

                async function ensureAdtRelatedTableLayer() {
                    if (adtRelatedTableLayer) {
                        if (!adtRelatedTableLayer.loaded) await adtRelatedTableLayer.load();
                        return adtRelatedTableLayer;
                    }
                    if (!adtLineLayer || !adtRelationshipInfo) return null;

                    let relatedTable = null;
                    if (map && map.allTables) {
                        relatedTable = map.allTables.find(tbl => tbl.layerId === adtRelationshipInfo.relatedTableId);
                    }
                    if (!relatedTable && map && map.allLayers) {
                        relatedTable = map.allLayers.find(layer => layer.layerId === adtRelationshipInfo.relatedTableId);
                    }

                    if (relatedTable) {
                        adtRelatedTableLayer = relatedTable;
                    } else if (adtLineLayer.url) {
                        const baseUrl = adtLineLayer.url.replace(/\/\d+$/, "");
                        const tableUrl = `${baseUrl}/${adtRelationshipInfo.relatedTableId}`;
                        adtRelatedTableLayer = new FeatureLayer({
                            url: tableUrl,
                            outFields: ["*"]
                        });
                    }

                    if (adtRelatedTableLayer && !adtRelatedTableLayer.loaded) {
                        await adtRelatedTableLayer.load();
                    }
                    adtFieldInfos = null;
                    return adtRelatedTableLayer;
                }

                async function getAllAdtParentOids() {
                    if (adtAllParentOids && adtAllParentOids.length > 0) {
                        return adtAllParentOids;
                    }
                    if (!adtLineLayer || !adtLineLayer.objectIdField) return [];
                    try {
                        const query = adtLineLayer.createQuery();
                        query.where = adtLineLayer.definitionExpression || "1=1";
                        const objectIds = await adtLineLayer.queryObjectIds(query);
                        adtAllParentOids = Array.isArray(objectIds) ? objectIds : [];
                        return adtAllParentOids;
                    } catch (error) {
                        console.warn("Error querying ADT parent object IDs:", error);
                        return [];
                    }
                }

                async function queryAdtRelatedRecords(parentOids, whereClause) {
                    if (!adtLineLayer || !adtRelationshipInfo) return [];
                    if (!parentOids || parentOids.length === 0) return [];

                    const records = [];
                    for (let i = 0; i < parentOids.length; i += MAX_ADT_REL_QUERY_BATCH) {
                        const chunk = parentOids.slice(i, i + MAX_ADT_REL_QUERY_BATCH);
                        const relQuery = new RelationshipQuery({
                            relationshipId: adtRelationshipInfo.id,
                            objectIds: chunk,
                            outFields: ["*"],
                            returnGeometry: false
                        });
                        if (whereClause) relQuery.where = whereClause;
                        try {
                            const response = await adtLineLayer.queryRelatedFeatures(relQuery);
                            Object.entries(response).forEach(([parentOid, data]) => {
                                const features = data && data.features ? data.features : [];
                                features.forEach(feature => {
                                    if (feature && feature.attributes) {
                                        records.push({
                                            parentObjectId: Number(parentOid),
                                            attributes: feature.attributes
                                        });
                                    }
                                });
                            });
                        } catch (error) {
                            console.warn("Error querying ADT related data:", error);
                        }
                    }
                    return records;
                }

                function displayAdtRecords(records) {
                    const attributeTable = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const thead = attributeTable ? attributeTable.querySelector("thead") : null;
                    const tbody = attributeTable ? attributeTable.querySelector("tbody") : null;
                    if (!attributeTable || !thead || !tbody) return;

                    thead.innerHTML = "";
                    tbody.innerHTML = "";
                    currentTableHeaders = [];
                    currentTableData = [];

                    if (!records || records.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No ADT count records match the current filters.</td></tr>`;
                        return;
                    }

                    const tableLayer = adtRelatedTableLayer;
                    const fieldLookup = new Map();
                    if (tableLayer && tableLayer.fields) {
                        tableLayer.fields.forEach(field => fieldLookup.set(field.name.toLowerCase(), field));
                    } else {
                        console.warn("ADT related table metadata was unavailable; using configured column definitions.");
                    }
                    const columnInfos = ADT_FIELD_CONFIG.map(config => {
                        const matchedField = fieldLookup.get(config.name.toLowerCase());
                        if (!matchedField) {
                            console.warn(`ADT related table is missing expected field '${config.name}'.`);
                        }
                        return {
                            name: matchedField ? matchedField.name : config.name,
                            alias: config.alias || (matchedField ? (matchedField.alias || matchedField.name) : config.name),
                            type: matchedField ? matchedField.type || "" : ""
                        };
                    });
                    adtFieldInfos = columnInfos;
                    currentTableHeaders = columnInfos.map(info => info.alias);

                    const headerRow = document.createElement("tr");
                    columnInfos.forEach(info => {
                        const th = document.createElement("th");
                        th.title = `Sort by ${info.alias}`;
                        th.textContent = info.alias;
                        const span = document.createElement("span");
                        span.className = 'sort-indicator';
                        span.textContent = ' \u21C5';
                        th.appendChild(span);
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    records.forEach(record => {
                        const row = document.createElement("tr");
                        const rowData = {};

                        columnInfos.forEach(info => {
                            let value = record.attributes ? record.attributes[info.name] : null;
                            if (value === null || value === undefined) {
                                value = '';
                            } else if ((info.type === "date" || info.type === "esriFieldTypeDate")) {
                                const dateVal = value instanceof Date ? value : new Date(value);
                                value = isNaN(dateVal.getTime()) ? '' : dateVal.toLocaleDateString();
                            } else if (value && typeof value === "object" && typeof value.toISOString === "function") {
                                value = value.toISOString();
                            } else if (typeof value === "number" && !Number.isInteger(value)) {
                                value = value.toFixed(2);
                            }
                            const valueStr = value === '' ? '' : String(value);
                            rowData[info.alias] = valueStr;
                            const cell = document.createElement("td");
                            cell.textContent = valueStr;
                            row.appendChild(cell);
                        });

                        tbody.appendChild(row);
                        currentTableData.push(rowData);
                    });

                    const noDataCell = tbody.querySelector('.no-features-row td');
                    if (noDataCell) {
                        noDataCell.colSpan = currentTableHeaders.length || 1;
                    }
                }

                async function refreshAdtTable() {
                    if (!adtLineLayer) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const adtTableLayer = await ensureAdtRelatedTableLayer();
                    if (!adtTableLayer) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const parentOids = adtSelectedOids.size > 0 ? Array.from(adtSelectedOids) : await getAllAdtParentOids();
                    if (!parentOids || parentOids.length === 0) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const whereClause = buildAdtYearWhereClause(currentYears);
                    const records = await queryAdtRelatedRecords(parentOids, whereClause);
                    displayAdtRecords(records);
                    if (adtLineLayer) {
                        try {
                            const lv = await view.whenLayerView(adtLineLayer);
                            if (lv) {
                                if (highlightHandles[adtLineLayer.id]) {
                                    highlightHandles[adtLineLayer.id].remove();
                                }
                                if (adtSelectedOids.size > 0) {
                                    highlightHandles[adtLineLayer.id] = lv.highlight(Array.from(adtSelectedOids));
                                }
                            }
                        } catch (error) {
                            console.warn("Highlight error for ADT selection:", error);
                        }
                    }

                    filteredAndVisibleFeatures = [];
                    relatedDataCache = {};

                    const effectiveSelectionCount = selectedFeatures.length + adtSelectedOids.size;
                    const isFilteringSelection = adtSelectedOids.size > 0;
                    updateFilterStatusSummary(parentOids.length, records.length, effectiveSelectionCount, isFilteringSelection);
                }

                function clientSideFilterFeatures(features, relatedDataMap, filterYears, filterPeriod, filterDataType) {
                    if (filterYears.length === 0 && filterPeriod === "All" && filterDataType === "All") {
                        return features;
                    }

                    return features.filter(f => {
                        const oidField = f.layer ? f.layer.objectIdField : null;
                        if (!oidField) return false;
                        const oid = f.attributes[oidField];
                        const relatedRecs = relatedDataMap[oid] || [];

                        if (relatedRecs.some(relAttrs => doesRecordMatchFilters(relAttrs, filterYears, filterPeriod, filterDataType))) {
                            return true;
                        }

                        const mainMatches = doesRecordMatchFilters(f.attributes, filterYears, filterPeriod, filterDataType);
                        if (mainMatches) {
                            const mainCanMatchDataType = filterDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD));
                            const mainCanMatchYear = filterYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD));
                            const mainCanMatchPeriod = filterPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD));
                            if (mainCanMatchDataType && mainCanMatchYear && mainCanMatchPeriod) {
                                return true;
                            }
                        }
                        return false;
                    });
                }

                function doesRecordMatchFilters(attrs, filterYears, filterPeriod, filterDataType) {
                    if (!attrs) return false;

                    if (filterDataType !== "All" && (!attrs.hasOwnProperty(DATA_TYPE_FIELD) || attrs[DATA_TYPE_FIELD] !== filterDataType)) {
                        return false;
                    }
                    if (filterYears.length > 0 && (!attrs.hasOwnProperty(YEAR_FIELD) || !filterYears.includes(String((attrs[YEAR_FIELD] !== undefined && attrs[YEAR_FIELD] !== null) ? attrs[YEAR_FIELD] : '')))) {
                        return false;
                    }
                    if (filterPeriod !== "All" && (!attrs.hasOwnProperty(PERIOD_FIELD) || attrs[PERIOD_FIELD] !== filterPeriod)) {
                        return false;
                    }
                    return true;
                }

                async function fetchRelatedDataForFeatures(features) {
                    const relatedDataMap = {};
                    if (!features || features.length === 0) return relatedDataMap;

                    const featuresByLayer = features.reduce((acc, f) => {
                        if (!f.layer || !f.layer.id || !f.layer.objectIdField) {
                            console.warn("Feature missing layer information, skipping for related data fetch:", f.attributes);
                            return acc;
                        }
                        const layerId = f.layer.id;
                        const oid = f.attributes[f.layer.objectIdField];
                        if (oid === null || oid === undefined) return acc;
                        if (!acc[layerId]) {
                            acc[layerId] = { layer: f.layer, objectIds: new Set() };
                        }
                        acc[layerId].objectIds.add(oid);
                        return acc;
                    }, {});

                    const fetchPromises = Object.values(featuresByLayer).map(async ({ layer, objectIds }) => {
                        if (!layer.relationships || layer.relationships.length === 0) return;
                        const oids = Array.from(objectIds);
                        if (oids.length === 0) return;

                        const relPromises = layer.relationships.map(async rel => {
                            const relQuery = new RelationshipQuery({
                                relationshipId: rel.id,
                                objectIds: oids,
                                outFields: ["*"],
                                returnGeometry: false,
                            });
                            try {
                                const result = await layer.queryRelatedFeatures(relQuery);
                                for (const parentOId in result) {
                                    const relatedFeatures = (result[parentOId] && result[parentOId].features) ? result[parentOId].features : [];
                                    if (relatedFeatures.length > 0) {
                                        const numericParentOid = Number(parentOId);
                                        if (!relatedDataMap[numericParentOid]) relatedDataMap[numericParentOid] = [];
                                        relatedDataMap[numericParentOid].push(...relatedFeatures.map(feat => feat.attributes));
                                    }
                                }
                            } catch (error) {
                                console.warn(`Relationship query error (Rel ID: ${rel.id}, Layer: ${layer.title || layer.id}):`, error);
                            }
                        });
                        await Promise.all(relPromises);
                    });

                    await Promise.all(fetchPromises);
                    return relatedDataMap;
                }

                async function updateMapViewBasedOnFilters(isFilteringSelection, featuresToShow) {
                    clearAllHighlights();

                    const oidsToShowByLayer = featuresToShow.reduce((acc, f) => {
                        if (f.layer && f.layer.id && f.layer.objectIdField) {
                            const layerId = f.layer.id;
                            const oid = f.attributes[f.layer.objectIdField];
                            if (oid !== null && oid !== undefined) {
                                if (!acc[layerId]) acc[layerId] = new Set();
                                acc[layerId].add(oid);
                            }
                        }
                        return acc;
                    }, {});

                    if (isFilteringSelection) {
                        await clearAllLayerViewFilters();
                        const hlPromises = Object.entries(oidsToShowByLayer).map(async ([layerId, oidsSet]) => {
                            const layer = allLayers.find(l => l.id === layerId);
                            if (!layer || oidsSet.size === 0) return;
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (lv) highlightHandles[layerId] = lv.highlight(Array.from(oidsSet));
                            } catch (error) { console.warn(`Highlight error on layer ${layerId}:`, error); }
                        });
                        await Promise.all(hlPromises);
                    } else {
                        const filterPromises = allLayers.map(async (layer) => {
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (!lv) return;
                                const layerOIDsSet = oidsToShowByLayer[layer.id];
                                const objectIdsForFilter = layerOIDsSet && layerOIDsSet.size > 0 ? Array.from(layerOIDsSet) : [-1];
                                lv.filter = new FeatureFilter({ objectIds: objectIdsForFilter });
                            } catch (error) {
                                console.warn(`LayerView filter error on layer ${layer.id}:`, error);
                            }
                        });
                        await Promise.all(filterPromises);
                    }
                }

                function clearAllHighlights() {
                    Object.values(highlightHandles).forEach(handle => handle && handle.remove && handle.remove());
                    highlightHandles = {};
                }

                async function clearAllLayerViewFilters() {
                    const clearPromises = allLayers.map(async (layer) => {
                        try {
                            const lv = await view.whenLayerView(layer);
                            if (lv) lv.filter = null;
                        } catch (error) {
                            console.warn(`Clear LayerView filter error on layer ${layer.id}:`, error);
                        }
                    });
                    await Promise.all(clearPromises);
                }

                async function queryAllVisibleFeaturesAcrossLayers(layers) {
                    let allFeatures = [];
                    const queryPromises = layers.map(async (layer) => {
                        if (!layer.visible || layer.type !== 'feature') return;
                        const query = layer.createQuery();
                        query.where = layer.definitionExpression || "1=1";
                        query.outFields = ["*"];
                        query.returnGeometry = true;
                        try {
                            const result = await layer.queryFeatures(query);
                            result.features.forEach(f => f.layer = layer);
                            allFeatures.push(...result.features);
                        } catch (error) {
                            console.warn(`Query error on layer ${layer.title || layer.id}:`, error);
                        }
                    });
                    await Promise.all(queryPromises);
                    return allFeatures;
                }

                function displayAttributes(features, relatedDataMap) {
                    const attributeTable = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const thead = attributeTable ? attributeTable.querySelector("thead") : null;
                    const tbody = attributeTable ? attributeTable.querySelector("tbody") : null;
                    if (!attributeTable || !thead || !tbody) return;

                    thead.innerHTML = "";
                    tbody.innerHTML = "";
                    currentTableHeaders = [];
                    currentTableData = [];

                    if (!features || features.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No features match filters/selection.</td></tr>`;
                        return;
                    }

                    const headersSet = new Set();
                    const tableRowsData = [];
                    const columnValues = {};

                    features.forEach(f => {
                        const oidField = f.layer ? f.layer.objectIdField : null;
                        if (!oidField) return;
                        const oid = f.attributes[oidField];
                        const related = relatedDataMap[oid] || [];

                        const matchingRelated = related.filter(rec => doesRecordMatchFilters(rec, currentYears, currentPeriod, currentDataType));
                        const mainMatches = doesRecordMatchFilters(f.attributes, currentYears, currentPeriod, currentDataType);
                        const mainCanMatchFilters =
                            (currentDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD))) &&
                            (currentYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD))) &&
                            (currentPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD)));

                        if (matchingRelated.length > 0) {
                            matchingRelated.forEach(relAttrs => {
                                const rowData = { ...f.attributes, ...relAttrs };
                                tableRowsData.push(rowData);
                                Object.keys(rowData).forEach(attr => {
                                    headersSet.add(attr);
                                    if (!columnValues[attr]) columnValues[attr] = new Set();
                                    columnValues[attr].add((rowData[attr] !== undefined && rowData[attr] !== null) ? rowData[attr] : null);
                                });
                            });
                        } else if (mainMatches && mainCanMatchFilters) {
                            const rowData = { ...f.attributes };
                            tableRowsData.push(rowData);
                            Object.keys(rowData).forEach(attr => {
                                headersSet.add(attr);
                                if (!columnValues[attr]) columnValues[attr] = new Set();
                                columnValues[attr].add((rowData[attr] !== undefined && rowData[attr] !== null) ? rowData[attr] : null);
                            });
                        }
                    });

                    if (tableRowsData.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No data records meet the current filter criteria (Data Type, Year, Period).</td></tr>`;
                        return;
                    }

                    const fieldsToExclude = [
                        "OBJECTID", "Shape", "SHAPE_Length", "SHAPE_Area", "Intersection_IDs",
                        "LocationID", "Intersection_ID", "Longitude", "Latitude",
                        "PopupInfo", "Names", "Traffic_DataCollection_Date", "City", "State",
                        "Intersection_Type", "Leg_Type", "OBJECTID_1", "ParentGlobalID", "GlobalID",
                        "Shape__Area", "Shape__Length", "Major_Street", "Minor_Street", "PEAK_ID",
                        "CreationDate", "Creator", "EditDate", "Editor", "created_user", "createdate",
                        "creationdate", "editdate", "last_edited_user", "last_edited_date"
                    ];

                    let headersToDisplay = Array.from(headersSet).filter(attr => {
                        if (fieldsToExclude.includes(attr)) return false;
                        const vals = columnValues[attr];
                        return vals && Array.from(vals).some(v => v !== null && v !== undefined && String(v).trim() !== '');
                    });

                    const preferredOrder = ["Name", MAJOR_STREETS_FIELD, MINOR_STREETS_FIELD, DATA_TYPE_FIELD, YEAR_FIELD, PERIOD_FIELD, "TurningMovement_Sum"].filter(Boolean);
                    headersToDisplay.sort((a, b) => {
                        const idxA = preferredOrder.indexOf(a);
                        const idxB = preferredOrder.indexOf(b);
                        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                        if (idxA !== -1) return -1;
                        if (idxB !== -1) return 1;
                        return a.localeCompare(b);
                    });

                    // Group and sort directional movement columns according to user feedback
                    const directionalOrder = [
                        "EBL", "EBT", "EBR",
                        "WBL", "WBT", "WBR",
                        "NBL", "NBT", "NBR",
                        "SBL", "SBT", "SBR",
                        // Also include other potential directional totals in a logical order
                        "EB", "WB", "NB", "SB",
                        "E", "W", "N", "S"
                    ];

                    // Extract all directional columns that are present in the data
                    const existingDirCols = headersToDisplay.filter(h => directionalOrder.includes(h));

                    // Sort these extracted columns based on the predefined directionalOrder
                    existingDirCols.sort((a, b) => {
                        return directionalOrder.indexOf(a) - directionalOrder.indexOf(b);
                    });

                    // Remove the directional columns from the main list to re-insert them in the correct order
                    headersToDisplay = headersToDisplay.filter(h => !directionalOrder.includes(h));

                    // Determine the insertion point (e.g., right after 'Period')
                    let insertIndex = headersToDisplay.indexOf(PERIOD_FIELD);
                    // Insert after 'Period', or at the end if 'Period' is not found
                    insertIndex = (insertIndex !== -1) ? insertIndex + 1 : headersToDisplay.length;

                    headersToDisplay.splice(insertIndex, 0, ...existingDirCols);

                    currentTableHeaders = headersToDisplay;
                    currentTableData = tableRowsData;

                    const noDataRow = tbody.querySelector('.no-features-row td');
                    if (noDataRow) noDataRow.colSpan = headersToDisplay.length || 1;

                    const headerRow = document.createElement("tr");
                    headersToDisplay.forEach((headerText) => {
                        const th = document.createElement('th');
                        th.title = `Sort by ${headerText}`;
                        th.textContent = headerText;
                        const span = document.createElement('span');
                        span.className = 'sort-indicator';
                        span.textContent = ' \\u21C5';
                        th.appendChild(span);
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    tableRowsData.forEach(rowData => {
                        const row = document.createElement("tr");
                        headersToDisplay.forEach(header => {
                            const cell = document.createElement("td");
                            let displayValue = (rowData[header] !== undefined && rowData[header] !== null) ? rowData[header] : '';
                            if (typeof displayValue === 'number' && !Number.isInteger(displayValue)) {
                                displayValue = displayValue.toFixed(2);
                            }
                            cell.textContent = displayValue;
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    });
                }

                function handleMapClick(event) {
                    view.hitTest(event).then(response => {
                        const hitResults = response && response.results ? response.results : [];
                        const featureResult = hitResults.find(r =>
                            r.graphic && r.graphic.layer && r.graphic.layer.type === "feature" &&
                            allLayers.some(opLayer => opLayer.id === r.graphic.layer.id)
                        );
                        if (featureResult) {
                            toggleFeatureSelection(featureResult.graphic);
                            return;
                        }
                        const adtResult = hitResults.find(r =>
                            adtLineLayer && r.graphic && r.graphic.layer && r.graphic.layer.id === adtLineLayer.id
                        );
                        if (adtResult) {
                            toggleAdtFeatureSelection(adtResult.graphic);
                            return;
                        }
                        if (selectedFeatures.length > 0 || adtSelectedOids.size > 0) {
                            selectedFeatures = [];
                            adtSelectedOids.clear();
                            applyFiltersAndDisplay().catch(error => console.error("Error clearing selection on map click:", error));
                        }
                    }).catch(error => console.error("HitTest error:", error));
                }

                function toggleFeatureSelection(feature) {
                    if (!feature || !feature.layer || !feature.layer.objectIdField) return;
                    const oidField = feature.layer.objectIdField;
                    const oid = feature.attributes[oidField];
                    const layerId = feature.layer.id;
                    const idx = selectedFeatures.findIndex(f => f.layer.id === layerId && f.attributes[oidField] === oid);

                    if (idx > -1) {
                        selectedFeatures.splice(idx, 1);
                    } else {
                        selectedFeatures.push(feature);
                    }
                    applyFiltersAndDisplay().catch(error => console.error("Error updating selection:", error));
                }

                function toggleAdtFeatureSelection(feature) {
                    if (!feature || !adtLineLayer || feature.layer.id !== adtLineLayer.id || !adtLineLayer.objectIdField) {
                        return;
                    }
                    const rawOid = feature.attributes ? feature.attributes[adtLineLayer.objectIdField] : null;
                    if (rawOid === null || rawOid === undefined) {
                        return;
                    }
                    const numericOid = typeof rawOid === "number" ? rawOid : Number(rawOid);
                    if (!Number.isFinite(numericOid)) {
                        return;
                    }
                    if (adtSelectedOids.has(numericOid)) {
                        adtSelectedOids.delete(numericOid);
                    } else {
                        adtSelectedOids.add(numericOid);
                    }
                    setActiveTableTab(TABLE_TAB_ADT, { skipRefresh: true });
                    applyFiltersAndDisplay().catch(error => console.error("Error applying ADT selection:", error));
                }

                function sortTable(table, colIndex, headerCell) {
                    const tbody = table && table.tBodies ? table.tBodies[0] : null;
                    if (!tbody || !headerCell || colIndex < 0 || colIndex >= headerCell.parentNode.children.length) return;

                    const rows = Array.from(tbody.rows);
                    const newDirection = (headerCell.dataset.sort === 'asc') ? 'desc' : 'asc';
                    headerCell.dataset.sort = newDirection;
                    const isAsc = newDirection === 'asc';

                    rows.sort((a, b) => {
                        const aText = a.cells[colIndex] ? a.cells[colIndex].textContent : "".trim() || '';
                        const bText = b.cells[colIndex] ? b.cells[colIndex].textContent : "".trim() || '';
                        if (aText === '') return 1;
                        if (bText === '') return -1;
                        const aNum = Number(aText.replace(/,/g, ''));
                        const bNum = Number(bText.replace(/,/g, ''));
                        let comparisonResult;
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            comparisonResult = aNum - bNum;
                        } else {
                            comparisonResult = aText.localeCompare(bText, undefined, { sensitivity: 'base', numeric: true });
                        }
                        return isAsc ? comparisonResult : -comparisonResult;
                    });

                    rows.forEach(row => tbody.appendChild(row));
                    updateSortIndicators(table, colIndex, newDirection);
                }

                function updateSortIndicators(table, sortedColIndex, direction) {
                    const headers = table && table.tHead && table.tHead.rows[0] ? table.tHead.rows[0].cells : null;
                    if (!headers) return;
                    for (let i = 0; i < headers.length; i++) {
                        const indicator = headers[i].querySelector(".sort-indicator");
                        if (indicator) {
                            if (i === sortedColIndex) {
                                indicator.textContent = direction === 'asc' ? ' \\u25B2' : ' \\u25BC';
                            } else {
                                indicator.textContent = ' \\u21C5';
                                headers[i].dataset.sort = 'none';
                            }
                        }
                    }
                }

                function generatePDFReport() {
                    if (!window.jspdf || (!window.jspdf.autoTable && (!(window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)))) {
                        alert("PDF generation library not loaded correctly. Please check console.");
                        return;
                    }

                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate PDF report.");
                        return;
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'landscape', unit: 'pt' });
                    const isAdtMode = currentTableTab === TABLE_TAB_ADT;

                    doc.setFontSize(18);
                    doc.text(isAdtMode ? "ADT Counts Report" : "Traffic Analytics Report", 40, 50);
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`Generated: ${new Date().toLocaleString()}`, 40, 65);
                    const filterSummary = isAdtMode
                        ? `Filters: Year(s)=${currentYears.join(',') || 'All'}`
                        : `Filters: Type=${currentDataType}, Year(s)=${currentYears.join(',') || 'All'}, Period=${currentPeriod}, Street=${currentStreet || 'None'}`;
                    doc.text(filterSummary, 40, 78);

                    const head = [currentTableHeaders];
                    const body = currentTableData.map(row => currentTableHeaders.map(header => String((row[header] !== undefined && row[header] !== null) ? row[header] : '')));

                    doc.autoTable({
                        head: head,
                        body: body,
                        startY: 90,
                        theme: 'striped',
                        styles: { fontSize: 7, cellPadding: 2, overflow: 'linebreak' },
                        headStyles: { fillColor: [75, 143, 207], textColor: 255, fontStyle: 'bold' },
                        margin: { top: 40, right: 40, bottom: 40, left: 40 },
                        didDrawPage: (data) => doc.text('Page ' + doc.internal.getNumberOfPages(), data.settings.margin.left, doc.internal.pageSize.height - 15)
                    });

                    doc.save(isAdtMode ? "adt_counts_report.pdf" : "traffic_analytics_report.pdf");
                }

                function generateCSVReport() {
                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate CSV report.");
                        return;
                    }
                    const escapeCSV = (val) => {
                        const str = String((val !== undefined && val !== null) ? val : '');
                        return str.includes(',') || str.includes('\n') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                    };
                    let csv = currentTableHeaders.map(escapeCSV).join(",") + "\n";
                    currentTableData.forEach(row => {
                        csv += currentTableHeaders.map(h => escapeCSV(row[h])).join(",") + "\n";
                    });
                    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
                    const blobUrl = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = blobUrl;
                    link.download = currentTableTab === TABLE_TAB_ADT ? "adt_counts_report.csv" : "traffic_analytics_report.csv";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(blobUrl), 0);
                }
                function generateReport() {
                    const format = (function(){ const el = document.getElementById(REPORT_FORMAT_ID); return el && el.value ? el.value : 'pdf'; })();
                    if (format === "pdf") generatePDFReport();
                    else if (format === "csv") generateCSVReport();
                }

                async function exportMapAsPDF() {
                    showLoadingSpinner();
                    const currentVP = view.viewpoint.clone();
                    try {
                        let targetExtent = null;
                        if (selectedFeatures.length > 0) {
                            selectedFeatures.forEach(f => {
                                const featExtent = f.geometry ? f.geometry.extent : null;
                                if (featExtent) {
                                    if (!targetExtent) targetExtent = featExtent.clone();
                                    else targetExtent = targetExtent.union(featExtent);
                                }
                            });
                            if (targetExtent) await view.goTo(targetExtent.expand(1.3));
                        }

                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const screenshot = await view.takeScreenshot({ width: 1600, height: 1000, format: 'png' });
                        if (targetExtent) await view.goTo(currentVP);

                        if (!window.jspdf) throw new Error("jsPDF library not found.");
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'letter' });
                        const pageW = doc.internal.pageSize.getWidth();
                        const pageH = doc.internal.pageSize.getHeight();
                        const margin = 40;
                        doc.setFontSize(18);
                        doc.text("City of Walnut Creek - Traffic Map", margin, margin + 10);
                        doc.setFontSize(10);
                        doc.setTextColor(100);
                        doc.text(`Exported: ${new Date().toLocaleString()}`, margin, margin + 25);
                        const availW = pageW - 2 * margin;
                        const availH = pageH - (margin + 40) - margin;
                        const imgProps = doc.getImageProperties(screenshot.dataUrl);
                        const imgRatio = imgProps.width / imgProps.height;
                        let imgW = availW, imgH = imgW / imgRatio;
                        if (imgH > availH) { imgH = availH; imgW = imgH * imgRatio; }
                        doc.addImage(screenshot.dataUrl, "PNG", margin + (availW - imgW) / 2, margin + 40, imgW, imgH);
                        doc.save("traffic_map_export.pdf");
                    } catch (error) {
                        console.error("Error during map export:", error);
                        alert(`Failed to export map: ${error.message}`);
                        await view.goTo(currentVP).catch(() => { });
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                function showLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'block';
                }

                function hideLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'none';
                }

                // ===========================================================
                // INITIALIZATION
                // ===========================================================
                async function init() {
                    showLoadingSpinner();
                    try {
                        map = new WebMap({ portalItem: { id: "6e90dece2b0a4833aa0379c01d0df23c" } });
                        view = new MapView({
                            container: VIEW_DIV_ID,
                            map: map,
                            highlightOptions: { color: [0, 255, 255, 1], haloOpacity: 0.9, fillOpacity: 0.3 }
                        });
                        view.popup.autoOpenEnabled = false;
                        view.popup.defaultPopupTemplateEnabled = false;
                        await view.when();
                        await map.load();

                        if (map.loadStatus === 'failed') {
                            throw new Error(map.loadError && map.loadError.message || 'Unknown WebMap loading error');
                        }

                        const layerListWidget = new LayerList({ view });
                        view.ui.add(layerListWidget, "top-left");

                        const legacyAdtLayer = findLayerByTitle(map.layers, LEGACY_ADT_LAYER_TITLE);
                        if (legacyAdtLayer) {
                            try {
                                map.layers.remove(legacyAdtLayer);
                            } catch (removeError) {
                                console.warn("Unable to remove legacy ADT layer:", removeError);
                                legacyAdtLayer.visible = false;
                                legacyAdtLayer.appExcludeFromFilters = true;
                            }
                        }

                        adtLineLayer = findLayerByTitle(map.layers, ADT_VIEW_LAYER_TITLE) ||
                            findLayerByUrlFragment(map.layers, ADT_VIEW_LAYER_URL_FRAGMENT);
                        if (adtLineLayer) {
                            adtLineLayer.appExcludeFromFilters = true;
                            if (!Array.isArray(adtLineLayer.outFields) || adtLineLayer.outFields.length === 0) {
                                adtLineLayer.outFields = ["*"];
                            }
                            if (typeof adtLineLayer.labelsVisible === "undefined") {
                                adtLineLayer.labelsVisible = true;
                            }
                            if (!tryReorderAdtLayer()) {
                                const reorderHandle = map.layers.on("change", () => {
                                    if (tryReorderAdtLayer()) {
                                        reorderHandle.remove();
                                    }
                                });
                                reactiveUtils.when(() => !!findRootLayerByTitle(ADT_REFERENCE_LAYER_TITLE), () => {
                                    if (tryReorderAdtLayer()) {
                                        reorderHandle.remove();
                                    }
                                }, { once: true });
                            }
                            await adtLineLayer.when();
                            adtSelectedOids.clear();
                            adtAllParentOids = null;
                            adtRelationshipInfo = (adtLineLayer.relationships || []).find(rel => {
                                const relName = (rel.name || "").toLowerCase();
                                return relName.includes("trafficcounts");
                            }) || (adtLineLayer.relationships && adtLineLayer.relationships.length > 0 ? adtLineLayer.relationships[0] : null);
                            if (!adtRelationshipInfo) {
                                console.warn("No related table definition found for ADT layer; ADT tab will be limited.");
                            } else {
                                await ensureAdtRelatedTableLayer().catch(error => console.warn("Unable to load ADT related table during initialization:", error));
                            }
                        } else {
                            console.warn("ADT view layer was not found in the web map; ADT tab will be unavailable.");
                        }

                        originalViewpoint = view.viewpoint.clone();
                        addUiElements();
                        initializeTableTabs();
                        allLayers = map.layers.filter(layer => layer.type === "feature" && !layer.appExcludeFromFilters).toArray();

                        if (allLayers.length === 0) {
                            throw new Error("No FeatureLayers found in the Web Map. Application cannot function.");
                        }

                        await view.when(() => Promise.all(allLayers.map(layer => view.whenLayerView(layer))));

                        // Use the first layer that has relationships to populate years
                        const layerForYears = allLayers.find(l => l.relationships && l.relationships.length > 0) || allLayers[0];

                        const yearPopulationPromises = [
                            populateStreetList(allLayers),
                            populateYearsFromRelatedData(layerForYears)
                        ];
                        if (adtLineLayer && adtLineLayer.relationships && adtLineLayer.relationships.length > 0) {
                            yearPopulationPromises.push(populateYearsFromRelatedData(adtLineLayer));
                        }
                        await Promise.all(yearPopulationPromises);

                        createFilterElements();
                        initializeStreetAutocomplete();
                        addEventListeners();
                        await applyFiltersAndDisplay();

                    } catch (error) {
                        console.error("Initialization failed:", error);
                        alert(`Application failed to initialize: ${error.message}. Please check console.`);
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                if (ADMIN_FEATURES_ENABLED && isOAuthConfigured()) {
                    registeredOAuthInfo = new OAuthInfo({
                        appId: OAUTH_APP_ID,
                        portalUrl: PORTAL_URL,
                        popup: true,
                        popupCallbackUrl: OAUTH_REDIRECT_URI
                    });
                    IdentityManager.registerOAuthInfos([registeredOAuthInfo]);
                }

                if (ADMIN_FEATURES_ENABLED) {
                    initializeAdminPanel(registeredOAuthInfo);
                }
                init();

            });
            
        });
    </script>
</body>

</html>


