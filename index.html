<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Analytics Map</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.30/esri/themes/light/main.css">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>

    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>
    <script src="https://js.arcgis.com/4.30/"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
            overflow: hidden;
            /* Prevent body scrollbars */
        }

        /* Main container uses flex column layout */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            background: #f5f5f5;
        }

        /* Header remains fixed height */
        #header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px;
            background-color: #ffffff;
            border-bottom: 1px solid #ccc;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 1;
        }

        /* Map View takes up remaining flexible space */
        #viewDiv {
            flex: 1 1 auto;
            position: relative;
            /* Set a minimum height to ensure the map has enough space for UI elements like the filter panel, preventing overlap on short browser windows. */
            min-height: 320px;
            width: 100%;
        }

        /* Features Div (Table Container) at the bottom */
        #featuresDiv {
            /* Changed flex-shrink from 0 to 1. This allows the table panel to shrink if the browser window becomes too short, yielding space to the map view above. */
            flex: 0 1 45%;
            background-color: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Important for child scroll container */
            border-top: 1px solid #ccc;
            width: 100%;
        }

        /* Table content area scrolls if needed */
        #featuresContentDiv {
            flex: 1 1 auto;
            box-sizing: border-box;
            overflow: auto;
            /* THIS IS THE SCROLL CONTAINER FOR THE TABLE */
            background: #ffffff;
            /* Tells the scroll container to leave space at the top for the sticky header */
            /* Adjust this value based on the actual height of your header row */
            scroll-padding-top: 40px;
        }

        /* Use separate border model for better sticky compatibility */
        .attribute-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            table-layout: fixed;
            background-color: #ffffff;
            border: 1px solid #ddd;
            /* Border on table itself */
        }


        /* --- Sticky Header CSS (Applied to TH) --- */
        .attribute-table thead th {
            /* Positioning */
            position: sticky;
            top: 0;
            /* Stick to the top of the scroll container (#featuresContentDiv) */
            z-index: 2;
            /* Needs to be above tbody rows (default 0/auto) */

            /* Appearance */
            background-color: #4b8fcf;
            /* Crucial for opacity */
            color: #fff;
            text-align: left;
            font-weight: bold;
            padding: 8px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            box-sizing: border-box;
            vertical-align: middle;

            /* Borders */
            border-top: 1px solid #ccc;
            border-left: 1px solid #ccc;
            border-bottom: 2px solid #ccc;
            /* Distinct bottom border */
        }

        /* Adjust border overrides as needed */
        .attribute-table thead tr:first-child th {
            border-top: none;
            /* Remove top border on the very first row of headers */
        }

        .attribute-table thead th:first-child {
            border-left: none;
            /* Remove left border on the first header cell */
            padding-left: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th:last-child {
            padding-right: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            color: #eee;
        }

        /* --- End Sticky Header CSS --- */


        /* --- Table Body Cells --- */
        .attribute-table tbody td {
            padding: 8px 8px;
            box-sizing: border-box;
            vertical-align: middle;
            word-wrap: break-word;

            /* Borders */
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
            z-index: 1;
            /* Lower z-index than sticky headers */
        }

        .attribute-table tbody td:first-child {
            border-left: none;
            /* Remove left border on first body cell */
            padding-left: 10px;
        }

        .attribute-table tbody td:last-child {
            padding-right: 10px;
        }

        /* --- End Table Body Cells --- */


        /* Background styles */
        .attribute-table tbody tr:nth-child(even) td {
            background-color: #f9f9f9;
        }

        .attribute-table tbody tr:nth-child(odd) td {
            background-color: #ffffff;
        }

        .attribute-table tbody tr:hover td {
            background-color: #e8f0fe;
        }

        /* 'No features' row styling */
        .attribute-table .no-features-row td {
            text-align: center;
            font-style: italic;
            color: #666;
            background-color: #fff !important;
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
        }

        .attribute-table .no-features-row td:first-child:last-child {
            border-left: none;
        }

        #filterDiv,
        #reportingDiv {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            border: 1px solid #ccc;
            margin: 10px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            z-index: 50;
            /* Ensure they are above sticky headers */
        }

        #filterDiv {
            width: 270px;
        }

        #filterControls label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        #filterControls select,
        #filterControls input {
            width: 100%;
            margin-top: 3px;
            margin-bottom: 12px;
            padding: 6px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }

        #filterControls select[multiple] {
            height: auto;
        }

        #reportingDiv button {
            padding: 8px 15px;
            margin-left: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f7f7f7, #e2e2e2);
            transition: background 0.2s, border-color 0.2s;
        }

        #reportingDiv select {
            padding: 8px 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
        }

        #reportingDiv button:hover {
            background: linear-gradient(to bottom, #f0f0f0, #d9d9d9);
            border-color: #999;
        }

        #reportingDiv button:active {
            background: linear-gradient(to bottom, #d9d9d9, #c2c2c2);
            border-color: #777;
        }

        #loadingSpinner {
            position: absolute;
            top: 50%;
            left: 50%;
            z-index: 1000;
            display: none;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        #filterStatus {
            margin-top: 10px;
            color: #555;
            font-size: 12px;
            line-height: 1.4;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #filterStatus strong {
            display: block;
            margin-bottom: 4px;
        }
        #filterStatusSummary {
            margin-top: 6px;
            font-size: 12px;
            color: #333;
        }

        #tableToolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            border-bottom: 1px solid #d4d4d4;
            background-color: #fafafa;
            gap: 12px;
        }

        #tableToolbar .toolbar-left {
            flex: 1 1 auto;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        #tableTabs {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .table-tab {
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #b5b5b5;
            border-radius: 4px;
            background: linear-gradient(to bottom, #ffffff, #e8e8e8);
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, box-shadow 0.2s, color 0.2s;
        }

        .table-tab:hover:not(.active) {
            background: linear-gradient(to bottom, #fdfdfd, #dddddd);
            border-color: #999;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        .table-tab.active {
            background: linear-gradient(to bottom, #4b8fcf, #3f7bb4);
            color: #ffffff;
            border-color: #3a6fa6;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .table-tab:focus-visible {
            outline: 2px solid #4b8fcf;
            outline-offset: 2px;
        }

        #tableSummaryText {
            flex: 1 1 auto;
            font-size: 13px;
            color: #3a3a3a;
            line-height: 1.4;
        }

        #tableToolbar .toolbar-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
        }

        #tableToolbar button {
            padding: 6px 12px;
            font-size: 13px;
            border: 1px solid #b5b5b5;
            border-radius: 4px;
            background: linear-gradient(to bottom, #ffffff, #e8e8e8);
            cursor: pointer;
            transition: background 0.2s, border-color 0.2s, box-shadow 0.2s;
        }

        #tableToolbar button:hover {
            background: linear-gradient(to bottom, #fdfdfd, #dddddd);
            border-color: #999;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        #tableToolbar button:active {
            background: linear-gradient(to bottom, #dcdcdc, #c4c4c4);
            border-color: #7a7a7a;
        }

        #tableToolbar button:focus-visible {
            outline: 2px solid #4b8fcf;
            outline-offset: 2px;
        }

        #tableToolbar button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: linear-gradient(to bottom, #f2f2f2, #d8d8d8);
            border-color: #c0c0c0;
            box-shadow: none;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <header id="header">
            <div>City of Walnut Creek</div>
            <div>Traffic Analytics Map</div>
        </header>

        <div id="viewDiv">
            <div id="loadingSpinner"></div>
        </div>

        <div id="featuresDiv">
            <div id="tableToolbar">
                <div class="toolbar-left">
                    <div id="tableTabs" role="tablist" aria-label="Table views">
                        <button type="button" class="table-tab active" role="tab" aria-selected="true" aria-controls="attributeTable" data-tab="features" tabindex="0">Traffic Data</button>
                        <button type="button" class="table-tab" role="tab" aria-selected="false" aria-controls="attributeTable" data-tab="adt" tabindex="-1">ADT Counts</button>
                    </div>
                    <div id="tableSummaryText" aria-live="polite">Loading data...</div>
                </div>
                <div class="toolbar-actions">
                    <button type="button" id="clearSelectionBtn" aria-label="Clear current selection" disabled>Clear Selection</button>
                    <button type="button" id="resetFiltersBtn" aria-label="Reset all filters to defaults" disabled>Reset Filters</button>
                </div>
            </div>
            <!-- This div handles the scrolling -->
            <div id="featuresContentDiv">
                <table class="attribute-table" id="attributeTable">
                    <thead></thead> <!-- Headers added dynamically -->
                    <tbody></tbody> <!-- Data added dynamically -->
                </table>
            </div>
        </div>

        <!-- Templates for UI elements -->
        <div id="filterDivTemplate" style="display: none;">
            <div id="filterControls"></div>
            <div id="filterStatus">
                <strong>Filter Behavior:</strong>
                If features are selected (highlighted cyan on map), filters apply only to the selection. Otherwise,
                filters apply globally.<br>
                Clicking empty map space unselects all features. Filters hide non-matching features/data.
                <div id="filterStatusSummary" aria-live="polite"></div>
            </div>
        </div>

        <div id="reportingDivTemplate" style="display: none;">
            <select id="reportFormat" aria-label="Select Report Format">
                <option value="pdf">PDF</option>
                <option value="csv">CSV</option>
            </select>
            <button id="generateReportBtn" aria-label="Generate Report">Generate Report</button>
            <button id="printMapBtn" aria-label="Export Map">Export Map PDF</button>
        </div>

    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // --- Constants ---
            const DATA_TYPE_FIELD = "Data_Type";
            const YEAR_FIELD = "Year";
            const PERIOD_FIELD = "Period";
            const MAJOR_STREETS_FIELD = "Major_Streets";
            const MINOR_STREETS_FIELD = "Minor_Streets";
            const STREET_FILTER_DEBOUNCE_MS = 300;

            const VIEW_DIV_ID = "viewDiv";
            const FILTER_DIV_ID = "filterDiv";
            const REPORTING_DIV_ID = "reportingDiv";
            const ATTRIBUTE_TABLE_ID = "attributeTable";
            const LOADING_SPINNER_ID = "loadingSpinner";
            const FILTER_CONTROLS_ID = "filterControls";
            const FILTER_STATUS_SUMMARY_ID = "filterStatusSummary";
            const DATA_TYPE_FILTER_ID = "dataTypeFilter";
            const YEAR_FILTER_ID = "yearFilter";
            const PERIOD_FILTER_ID = "periodFilter";
            const STREET_FILTER_ID = "streetFilter";
            const GENERATE_REPORT_BTN_ID = "generateReportBtn";
            const PRINT_MAP_BTN_ID = "printMapBtn";
            const REPORT_FORMAT_ID = "reportFormat";
            const TABLE_SUMMARY_ID = "tableSummaryText";
            const CLEAR_SELECTION_BTN_ID = "clearSelectionBtn";
            const RESET_FILTERS_BTN_ID = "resetFiltersBtn";
            const TABLE_TABS_ID = "tableTabs";
            const TABLE_TAB_BUTTON_CLASS = "table-tab";
            const TABLE_TAB_FEATURES = "features";
            const TABLE_TAB_ADT = "adt";
            const TABLE_TAB_ACTIVE_CLASS = "active";
            const ADT_FIELD_CONFIG = [
                { name: "ADT", alias: "ADT" },
                { name: "Year", alias: "Year" },
                { name: "join_key", alias: "join_key" }
            ];
            const MAX_ADT_REL_QUERY_BATCH = 500;

            // --- State Variables ---
            let map, view;
let allLayers = []; // Will hold FeatureLayers from the WebMap
let highlightHandles = {};
let allYears = new Set();
let streetList = [];
let currentDataType = "All"; // Initialize with a simple default
let currentYears = [];       // Initialize as an empty array
let currentPeriod = "All";   // Initialize with a simple default
let currentStreet = "";      // Initialize with a simple default
let selectedFeatures = [];
            let filteredAndVisibleFeatures = [];
            let relatedDataCache = {};
            let currentTableHeaders = [];
            let currentTableData = [];
            let originalViewpoint = null;
            let streetFilterTimeout = null;
            let currentTableTab = TABLE_TAB_FEATURES;
            let adtLineLayer = null;
            let adtRelationshipInfo = null;
            let adtRelatedTableLayer = null;
            let adtSelectedOids = new Set();
            let adtAllParentOids = null;
            let adtFieldInfos = null;
            const ADT_REFERENCE_LAYER_TITLE = "Unique PEAK Traffic Count Intersections";

            // --- ArcGIS Modules ---
            require([
                "esri/WebMap",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/Graphic",
                "esri/rest/support/Query",
                "esri/rest/support/RelationshipQuery",
                "esri/layers/support/FeatureFilter",
                "esri/geometry/Extent",
                "esri/core/reactiveUtils",
                "esri/widgets/LayerList"
            ], function (
                WebMap, MapView, FeatureLayer, Graphic, Query, RelationshipQuery, FeatureFilter, Extent,
                reactiveUtils, LayerList
            ) {

                // ===========================================================
                // FUNCTION DEFINITIONS
                // ===========================================================

                function addUiElements() {
                    const filterDivTemplate = document.getElementById('filterDivTemplate');
                    const reportingDivTemplate = document.getElementById('reportingDivTemplate');
                    if (!filterDivTemplate || !reportingDivTemplate) { console.error("UI template elements not found!"); return; }
                    const filterDiv = filterDivTemplate.cloneNode(true);
                    filterDiv.id = FILTER_DIV_ID;
                    filterDiv.style.display = 'block';
                    const summaryNode = filterDiv.querySelector('#' + FILTER_STATUS_SUMMARY_ID);
                    if (summaryNode) summaryNode.textContent = 'Loading data...';
                    view.ui.add(filterDiv, "top-right");
                    const reportingDiv = reportingDivTemplate.cloneNode(true);
                    reportingDiv.id = REPORTING_DIV_ID;
                    reportingDiv.style.display = 'flex';
                    reportingDiv.style.alignItems = 'center';
                    view.ui.add(reportingDiv, "top-left");
                }

                async function populateStreetList(spatialLayers) {
                    const streetSet = new Set();
                    const hasMajor = spatialLayers.some(l => l.fields && l.fields.some(f => f.name === MAJOR_STREETS_FIELD));
                    const hasMinor = spatialLayers.some(l => l.fields && l.fields.some(f => f.name === MINOR_STREETS_FIELD));
                    const fieldsToQuery = [];
                    if (hasMajor) fieldsToQuery.push(MAJOR_STREETS_FIELD);
                    if (hasMinor) fieldsToQuery.push(MINOR_STREETS_FIELD);

                    if (fieldsToQuery.length === 0) {
                        console.warn("Neither Major_Streets nor Minor_Streets field found in any loaded FeatureLayer. Cannot populate street list.");
                        streetList = [];
                        return;
                    }

                    console.log("Querying fields for street list:", fieldsToQuery);

                    const query = new Query({
                        where: "1=1",
                        returnDistinctValues: true,
                        outFields: fieldsToQuery,
                        returnGeometry: false
                    });

                    const queryPromises = spatialLayers.map(layer => {
                        const layerHasField = fieldsToQuery.some(fld => layer.fields && layer.fields.some(f => f.name === fld));
                        if (!layerHasField) {
                            return Promise.resolve(); // Resolve immediately if layer lacks fields
                        }

                        return layer.queryFeatures(query)
                            .then(result => {
                                result.features.forEach(feature => {
                                    fieldsToQuery.forEach(fld => {
                                        if (feature.attributes && feature.attributes.hasOwnProperty(fld)) {
                                            const streetName = feature.attributes[fld];
                                            if (streetName && typeof streetName === 'string' && streetName.trim()) {
                                                streetSet.add(streetName.trim());
                                            }
                                        }
                                    });
                                });
                            }).catch(error => console.warn(`Error querying streets from layer ${layer.title || layer.id}:`, error));
                    });

                    await Promise.all(queryPromises);
                    streetList = Array.from(streetSet).sort();
                    console.log(`Populated street list with ${streetList.length} unique names.`);
                }

                async function populateYearsFromRelatedData(spatialLayer) {
                    const layerTitle = spatialLayer && spatialLayer.title ? spatialLayer.title : 'undefined';
                    const layerTitleSafe = spatialLayer && spatialLayer.title ? spatialLayer.title : 'N/A';
                    console.log(`Attempting to populate years from relationships of layer: ${layerTitle}`);
                    if (!spatialLayer || !spatialLayer.relationships || spatialLayer.relationships.length === 0) {
                        console.log(`Layer ${layerTitleSafe} has no relationships defined or is not valid.`);
                        return;
                    }
                    if (!YEAR_FIELD) {
                        console.warn("YEAR_FIELD constant is not defined. Cannot query for years.");
                        return;
                    }

                    const objectIdField = spatialLayer.objectIdField;
                    if (!objectIdField) {
                        console.error(`Layer ${spatialLayer.title || spatialLayer.id} does not have a valid objectIdField.`);
                        return;
                    }

                    const parentQuery = new Query({
                        where: "1=1",
                        returnGeometry: false,
                        outFields: [objectIdField],
                        num: 1000
                    });

                    let parentOids = [];
                    try {
                        const parentResult = await spatialLayer.queryFeatures(parentQuery);
                        parentOids = parentResult.features.map(f => f.attributes[objectIdField]);
                        if (parentOids.length === 0) {
                            console.log("No parent features found, cannot query related data.");
                            return;
                        }
                        if (parentResult.exceededTransferLimit) {
                            console.warn(`Parent feature query exceeded transfer limit for layer ${spatialLayer.title || spatialLayer.id}. Year list might be incomplete.`);
                        }
                    } catch (error) {
                        console.error(`Error querying parent features for layer ${spatialLayer.title || spatialLayer.id}:`, error);
                        return;
                    }

                    const relationshipPromises = [];

                    for (const rel of spatialLayer.relationships) {
                        let relatedTableHasYearField = false;
                        try {
                            const relatedTable = map.allTables.find(t => t.layerId === rel.relatedTableId) || map.allLayers.find(l => l.layerId === rel.relatedTableId);
                            if (relatedTable) {
                                if (!relatedTable.loaded) await relatedTable.load();
                                relatedTableHasYearField = relatedTable.fields && relatedTable.fields.some(f => f.name === YEAR_FIELD);
                            } else {
                                console.warn(`Could not find related table/layer with ID ${rel.relatedTableId} in the map.`);
                            }
                        } catch (loadError) {
                            console.warn(`Error loading related table ${rel.relatedTableId} to check fields:`, loadError);
                        }

                        if (!relatedTableHasYearField) {
                            console.log(`Skipping relationship query for Rel ID ${rel.id} as related table does not contain the field '${YEAR_FIELD}'.`);
                            continue;
                        }

                        const relQuery = new RelationshipQuery({
                            relationshipId: rel.id,
                            objectIds: parentOids,
                            outFields: [YEAR_FIELD],
                            returnGeometry: false
                        });

                        relationshipPromises.push(
                            spatialLayer.queryRelatedFeatures(relQuery)
                                .then(relatedResults => {
                                    for (const parentOid in relatedResults) {
                                        const relatedFeatures = (relatedResults[parentOid] && relatedResults[parentOid].features) ? relatedResults[parentOid].features : [];
                                        relatedFeatures.forEach(relatedFeature => {
                                            if (relatedFeature.attributes && relatedFeature.attributes.hasOwnProperty(YEAR_FIELD)) {
                                                const year = relatedFeature.attributes[YEAR_FIELD];
                                                if (year !== null && year !== undefined && String(year).trim() !== '') {
                                                    allYears.add(String(year));
                                                }
                                            }
                                        });
                                    }
                                })
                                .catch(error => console.warn(`Error querying relationship ID ${rel.id} for layer ${spatialLayer.title || spatialLayer.id}:`, error))
                        );
                    }

                    await Promise.all(relationshipPromises);
                    console.log(`Finished querying relationships for layer ${spatialLayer.title || spatialLayer.id}. Total unique years found: ${allYears.size}`);
                }

                function createFilterElements() {
                    const filterControlsDiv = document.getElementById(FILTER_CONTROLS_ID);
                    if (!filterControlsDiv) { console.error(`Element ID '${FILTER_CONTROLS_ID}' not found.`); return; }
                    filterControlsDiv.innerHTML = '';

                    // Data Type Filter
                    const dataTypes = ["All", "Bikes", "Intersection Info", "PHF", "Pedestrian", "Heavy Vehicles", "Turning Movement"];
                    filterControlsDiv.innerHTML += `<label for="${DATA_TYPE_FILTER_ID}">Data Type:</label><select id="${DATA_TYPE_FILTER_ID}">${dataTypes.map(type => `<option value="${type}">${type}</option>`).join('')}</select>`;

                    // Year Filter (Multiple Select)
                    const sortedYears = Array.from(allYears).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
                    if (sortedYears.length === 0) {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year:</label><select id="${YEAR_FILTER_ID}" disabled><option value="All">No Years Found</option></select>`;
                    } else {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year (Ctrl+Click):</label><select id="${YEAR_FILTER_ID}" multiple size="5"><option value="All" selected>All Years</option>${sortedYears.map(year => `<option value="${year}">${year}</option>`).join('')}</select>`;
                    }

                    // Period Filter
                    const periods = ["All", "AM", "MID", "PM"];
                    filterControlsDiv.innerHTML += `<label for="${PERIOD_FILTER_ID}">Period:</label><select id="${PERIOD_FILTER_ID}">${periods.map(period => `<option value="${period}">${period}</option>`).join('')}</select>`;

                    // Street Name Filter (Autocomplete)
                    filterControlsDiv.innerHTML += `<label for="${STREET_FILTER_ID}">Street Name:</label><input type="text" id="${STREET_FILTER_ID}" placeholder="Type street name...">`;
                }

                function initializeStreetAutocomplete() {
                    const streetInput = $(`#${STREET_FILTER_ID}`);
                    if (streetInput.length) {
                        streetInput.autocomplete({
                            source: streetList,
                            minLength: 0,
                            select: function (event, ui) {
                                $(this).val(ui.item.value);
                                applyFiltersAndDisplay();
                                return false;
                            },
                            change: function (event, ui) {
                                if (!ui.item) {
                                    applyFiltersAndDisplay();
                                }
                            }
                        }).focus(function () {
                            if (!$(this).val()) {
                                $(this).autocomplete("search", "");
                            }
                        });
                    } else {
                        console.error("Street filter input element not found for autocomplete.");
                    }
                }

                function getTableTabButtons() {
                    const tabsContainer = document.getElementById(TABLE_TABS_ID);
                    if (!tabsContainer) return [];
                    return Array.from(tabsContainer.querySelectorAll(`.${TABLE_TAB_BUTTON_CLASS}`));
                }

                function updateTableTabButtons() {
                    const tabButtons = getTableTabButtons();
                    tabButtons.forEach(button => {
                        const tabKey = button.dataset.tab;
                        const isActive = tabKey === currentTableTab;
                        button.classList.toggle(TABLE_TAB_ACTIVE_CLASS, isActive);
                        button.setAttribute("aria-selected", isActive ? "true" : "false");
                        button.setAttribute("tabindex", isActive ? "0" : "-1");
                    });
                }

                function setActiveTableTab(tabKey, options = {}) {
                    if (!tabKey) return;
                    if (tabKey === currentTableTab) {
                        updateTableTabButtons();
                        return;
                    }
                    currentTableTab = tabKey;
                    updateTableTabButtons();
                    if (!options.skipRefresh) {
                        applyFiltersAndDisplay().catch(error => console.error("Error switching table tab:", error));
                    }
                }

                function initializeTableTabs() {
                    const tabButtons = getTableTabButtons();
                    if (tabButtons.length === 0) {
                        console.warn("Table tabs not found in DOM.");
                        return;
                    }
                    tabButtons.forEach(button => {
                        button.addEventListener("click", () => setActiveTableTab(button.dataset.tab));
                    });
                    updateTableTabButtons();
                }

                function collectionToArray(collection) {
                    if (!collection) return [];
                    if (typeof collection.toArray === "function") {
                        return collection.toArray();
                    }
                    if (Array.isArray(collection)) {
                        return collection;
                    }
                    return [];
                }

                function findRootLayerByTitle(title) {
                    if (!map?.layers?.toArray) return null;
                    const normalized = (title || "").trim().toLowerCase();
                    return map.layers.toArray().find(layer => (layer?.title || "").trim().toLowerCase() === normalized) || null;
                }

                function findLayerByTitle(collection, title) {
                    const normalized = (title || "").trim().toLowerCase();
                    for (const layer of collectionToArray(collection)) {
                        const layerTitle = (layer?.title || "").trim().toLowerCase();
                        if (layerTitle === normalized) {
                            return layer;
                        }
                        if (layer?.layers) {
                            const childMatch = findLayerByTitle(layer.layers, title);
                            if (childMatch) return childMatch;
                        }
                    }
                    return null;
                }

                function reorderAdtLayerBelowReference(referenceLayer) {
                    if (!adtLineLayer || !map?.layers?.toArray) return;
                    const rootLayers = map.layers.toArray();
                    const targetIndex = rootLayers.findIndex(layer => layer === referenceLayer);
                    if (targetIndex >= 0) {
                        map.reorder(adtLineLayer, targetIndex + 1);
                    }
                }

                function tryReorderAdtLayer() {
                    if (!adtLineLayer) return false;
                    const referenceLayer = findRootLayerByTitle(ADT_REFERENCE_LAYER_TITLE);
                    if (referenceLayer) {
                        reorderAdtLayerBelowReference(referenceLayer);
                        return true;
                    }
                    return false;
                }

                function addEventListeners() {
                    const filterControls = document.getElementById(FILTER_CONTROLS_ID);
                    const reportingControls = document.getElementById(REPORTING_DIV_ID);
                    const attributeTableElement = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const attributeTableHead = attributeTableElement ? attributeTableElement.querySelector('thead') : null;

                    if (filterControls) {
                        filterControls.addEventListener('change', (event) => {
                            const target = event.target;
                            if (target && target.tagName === 'SELECT') {
                                if (target.id === YEAR_FILTER_ID) {
                                    const selectedOptions = Array.from(target.selectedOptions).map(opt => opt.value);
                                    const allOption = target.querySelector('option[value="All"]');

                                    if (selectedOptions.includes("All") && selectedOptions.length > 1) {
                                        Array.from(target.querySelectorAll('option:not([value="All"])')).forEach(opt => opt.selected = false);
                                        if (allOption) { allOption.selected = true; }
                                    } else if (!selectedOptions.includes("All") && selectedOptions.length > 0 && allOption && allOption.selected) {
                                        allOption.selected = false;
                                    } else if (selectedOptions.length === 0 && allOption) {
                                        allOption.selected = true;
                                    }
                                }
                                applyFiltersAndDisplay();
                            }
                        });

                        filterControls.addEventListener('input', (event) => {
                            const target = event.target;
                            if (target && target.id === STREET_FILTER_ID) {
                                clearTimeout(streetFilterTimeout);
                                streetFilterTimeout = setTimeout(applyFiltersAndDisplay, STREET_FILTER_DEBOUNCE_MS);
                            }
                        });
                    }

                    view.on("click", handleMapClick);

                    if (reportingControls) {
                        reportingControls.addEventListener('click', (event) => {
                            const target = event.target;
                            if (target && target.id === GENERATE_REPORT_BTN_ID) {
                                generateReport();
                            } else if (target && target.id === PRINT_MAP_BTN_ID) {
                                exportMapAsPDF();
                            }
                        });
                    }

                    if (attributeTableHead) {
                        attributeTableHead.addEventListener('click', (event) => {
                            const headerCell = event.target.closest('th');
                            if (headerCell) {
                                const colIndex = Array.from(headerCell.parentNode.children).indexOf(headerCell);
                                sortTable(document.getElementById(ATTRIBUTE_TABLE_ID), colIndex, headerCell);
                            }
                        });
                    }

                    const clearSelectionButtonEl = document.getElementById(CLEAR_SELECTION_BTN_ID);
                    if (clearSelectionButtonEl) {
                        clearSelectionButtonEl.addEventListener('click', () => {
                            clearFeatureSelection();
                        });
                    }

                    const resetFiltersButtonEl = document.getElementById(RESET_FILTERS_BTN_ID);
                    if (resetFiltersButtonEl) {
                        resetFiltersButtonEl.addEventListener('click', () => {
                            resetFiltersToDefaults();
                        });
                    }
                }

                function updateFilterStatusSummary(totalConsidered, totalDisplayed, selectionCount, isFilteringSelection) {
                    const summaryNodes = document.querySelectorAll('#' + FILTER_STATUS_SUMMARY_ID);
                    const tableSummaryNode = document.getElementById(TABLE_SUMMARY_ID);
                    if (summaryNodes.length === 0 && !tableSummaryNode) {
                        return;
                    }

                    const isAdtMode = currentTableTab === TABLE_TAB_ADT;
                    const normalizedTotalConsidered = Number.isFinite(totalConsidered) && totalConsidered >= 0 ? totalConsidered : 0;
                    const normalizedTotalDisplayed = Number.isFinite(totalDisplayed) && totalDisplayed >= 0 ? totalDisplayed : 0;

                    let baseText;
                    if (isAdtMode) {
                        if (normalizedTotalConsidered > 0) {
                            baseText = `${normalizedTotalDisplayed.toLocaleString()} ADT record${normalizedTotalDisplayed === 1 ? '' : 's'} displayed from ${normalizedTotalConsidered.toLocaleString()} line${normalizedTotalConsidered === 1 ? '' : 's'}.`;
                        } else {
                            baseText = "No ADT data is currently available for the selected filters.";
                        }
                    } else {
                        const consideredLabel = isFilteringSelection ? "selected feature(s)" : "visible feature(s)";
                        if (normalizedTotalConsidered > 0) {
                            baseText = `${normalizedTotalDisplayed.toLocaleString()} of ${normalizedTotalConsidered.toLocaleString()} ${consideredLabel} match current filters.`;
                        } else {
                            baseText = "No map features are currently available for the selected filters.";
                        }
                    }

                    let selectionText;
                    if (isAdtMode) {
                        selectionText = adtSelectedOids.size > 0
                            ? `${adtSelectedOids.size.toLocaleString()} ADT line${adtSelectedOids.size === 1 ? '' : 's'} selected.`
                            : "No ADT selection active.";
                    } else if (selectedFeatures.length > 0) {
                        selectionText = `${selectedFeatures.length.toLocaleString()} feature${selectedFeatures.length === 1 ? '' : 's'} selected.`;
                    } else if (adtSelectedOids.size > 0) {
                        selectionText = `${adtSelectedOids.size.toLocaleString()} ADT line${adtSelectedOids.size === 1 ? '' : 's'} selected.`;
                    } else {
                        selectionText = "No selection active.";
                    }

                    const filterParts = [];
                    if (isAdtMode) {
                        if (currentYears.length > 0) filterParts.push(`Year=${currentYears.join(', ')}`);
                    } else {
                        if (currentDataType !== "All") filterParts.push(`Type=${currentDataType}`);
                        if (currentYears.length > 0) filterParts.push(`Year=${currentYears.join(', ')}`);
                        if (currentPeriod !== "All") filterParts.push(`Period=${currentPeriod}`);
                        if (currentStreet) filterParts.push(`Street contains "${currentStreet}"`);
                    }
                    const filtersDescription = filterParts.length > 0 ? `Active filters: ${filterParts.join('; ')}.` : "Active filters: none.";

                    const clearSelectionButton = document.getElementById(CLEAR_SELECTION_BTN_ID);
                    if (clearSelectionButton) {
                        clearSelectionButton.disabled = (selectedFeatures.length + adtSelectedOids.size) === 0;
                    }
                    const resetFiltersButton = document.getElementById(RESET_FILTERS_BTN_ID);
                    if (resetFiltersButton) {
                        const hasActiveFilter = currentDataType !== "All" || currentYears.length > 0 || currentPeriod !== "All" || currentStreet;
                        resetFiltersButton.disabled = !hasActiveFilter;
                    }

                    const baseMessage = `${baseText} ${selectionText}`.trim();
                    if (summaryNodes.length > 0) {
                        summaryNodes.forEach(node => {
                            node.textContent = `${baseMessage} ${filtersDescription}`.trim();
                        });
                    }
                    if (tableSummaryNode) {
                        tableSummaryNode.textContent = baseMessage;
                        tableSummaryNode.setAttribute('title', filtersDescription);
                    }
                }
                function resetFiltersToDefaults() {
                    const dataTypeSelect = document.getElementById(DATA_TYPE_FILTER_ID);
                    if (dataTypeSelect) dataTypeSelect.value = "All";
                    const yearSelect = document.getElementById(YEAR_FILTER_ID);
                    if (yearSelect) {
                        Array.from(yearSelect.options).forEach(option => option.selected = option.value === "All");
                    }
                    const periodSelect = document.getElementById(PERIOD_FILTER_ID);
                    if (periodSelect) periodSelect.value = "All";
                    const streetInput = document.getElementById(STREET_FILTER_ID);
                    if (streetInput) streetInput.value = "";
                    clearTimeout(streetFilterTimeout);
                    applyFiltersAndDisplay().catch(error => console.error("Error resetting filters:", error));
                }

                function clearFeatureSelection() {
                    const hadSelection = selectedFeatures.length > 0 || adtSelectedOids.size > 0;
                    if (!hadSelection) {
                        return;
                    }
                    selectedFeatures = [];
                    adtSelectedOids.clear();
                    clearAllHighlights();
                    applyFiltersAndDisplay().catch(error => console.error("Error clearing selection:", error));
                }
                function readFilterControlValues() {
                    const dataTypeSelect = document.getElementById(DATA_TYPE_FILTER_ID);
                    const yearSelect = document.getElementById(YEAR_FILTER_ID);
                    const periodSelect = document.getElementById(PERIOD_FILTER_ID);
                    const streetInput = document.getElementById(STREET_FILTER_ID);

                    currentDataType = (dataTypeSelect && dataTypeSelect.value) ? dataTypeSelect.value : "All";
                    currentPeriod = (periodSelect && periodSelect.value) ? periodSelect.value : "All";
                    currentStreet = streetInput && typeof streetInput.value === "string" ? streetInput.value.trim() : "";

                    currentYears = yearSelect ? Array.from(yearSelect.selectedOptions).map(opt => opt.value) : [];
                    if (currentYears.includes("All") || currentYears.length === 0) {
                        currentYears = [];
                    } else {
                        currentYears = currentYears.filter(y => y !== "All");
                    }
                }

                async function applyFiltersAndDisplay() {
                    showLoadingSpinner();
                    console.log("Applying filters...");
                    try {
                        readFilterControlValues();
                        if (currentTableTab === TABLE_TAB_ADT) {
                            await refreshAdtTable();
                        } else {
                            await refreshFeatureTable();
                        }
                    } catch (error) {
                        console.error("Error applying filters:", error);
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                async function refreshFeatureTable() {
                    const escapedStreet = currentStreet.replace(/'/g, "''");
                    let definitionExpression = "1=1";
                    if (currentStreet && MAJOR_STREETS_FIELD && MINOR_STREETS_FIELD) {
                        const hasMajor = allLayers.some(l => l.fields && l.fields.some(f => f.name === MAJOR_STREETS_FIELD));
                        const hasMinor = allLayers.some(l => l.fields && l.fields.some(f => f.name === MINOR_STREETS_FIELD));
                        const conditions = [];
                        if (hasMajor) conditions.push(`${MAJOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (hasMinor) conditions.push(`${MINOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (conditions.length > 0) {
                            definitionExpression = `(${conditions.join(' OR ')})`;
                        }
                    }

                    allLayers.forEach(layer => {
                        if (layer.definitionExpression !== definitionExpression) {
                            layer.definitionExpression = definitionExpression;
                        }
                    });

                    let baseFeaturesToFilter = [];
                    const isFilteringSelection = selectedFeatures.length > 0;

                    if (isFilteringSelection) {
                        baseFeaturesToFilter = selectedFeatures;
                        await clearAllLayerViewFilters();
                    } else {
                        baseFeaturesToFilter = await queryAllVisibleFeaturesAcrossLayers(allLayers);
                    }

                    relatedDataCache = await fetchRelatedDataForFeatures(baseFeaturesToFilter);
                    filteredAndVisibleFeatures = clientSideFilterFeatures(baseFeaturesToFilter, relatedDataCache, currentYears, currentPeriod, currentDataType);
                    await updateMapViewBasedOnFilters(isFilteringSelection, filteredAndVisibleFeatures);
                    displayAttributes(filteredAndVisibleFeatures, relatedDataCache);
                    if (adtLineLayer && adtSelectedOids.size > 0) {
                        try {
                            const lv = await view.whenLayerView(adtLineLayer);
                            if (lv) {
                                if (highlightHandles[adtLineLayer.id]) {
                                    highlightHandles[adtLineLayer.id].remove();
                                }
                                highlightHandles[adtLineLayer.id] = lv.highlight(Array.from(adtSelectedOids));
                            }
                        } catch (error) {
                            console.warn("Highlight error for ADT layer:", error);
                        }
                    }

                    const effectiveSelectionCount = selectedFeatures.length + adtSelectedOids.size;
                    updateFilterStatusSummary(baseFeaturesToFilter.length, filteredAndVisibleFeatures.length, effectiveSelectionCount, isFilteringSelection);
                }

                function buildAdtYearWhereClause(years) {
                    if (!years || years.length === 0) return null;
                    const sanitized = years
                        .map(year => String(year).trim())
                        .filter(Boolean)
                        .map(val => `'${val.replace(/'/g, "''")}'`);
                    if (sanitized.length === 0) return null;
                    return `${YEAR_FIELD} IN (${sanitized.join(",")})`;
                }

                async function ensureAdtRelatedTableLayer() {
                    if (adtRelatedTableLayer) {
                        if (!adtRelatedTableLayer.loaded) await adtRelatedTableLayer.load();
                        return adtRelatedTableLayer;
                    }
                    if (!adtLineLayer || !adtRelationshipInfo) return null;

                    let relatedTable = null;
                    if (map && map.allTables) {
                        relatedTable = map.allTables.find(tbl => tbl.layerId === adtRelationshipInfo.relatedTableId);
                    }
                    if (!relatedTable && map && map.allLayers) {
                        relatedTable = map.allLayers.find(layer => layer.layerId === adtRelationshipInfo.relatedTableId);
                    }

                    if (relatedTable) {
                        adtRelatedTableLayer = relatedTable;
                    } else if (adtLineLayer.url) {
                        const baseUrl = adtLineLayer.url.replace(/\/\d+$/, "");
                        const tableUrl = `${baseUrl}/${adtRelationshipInfo.relatedTableId}`;
                        adtRelatedTableLayer = new FeatureLayer({
                            url: tableUrl,
                            outFields: ["*"]
                        });
                    }

                    if (adtRelatedTableLayer && !adtRelatedTableLayer.loaded) {
                        await adtRelatedTableLayer.load();
                    }
                    adtFieldInfos = null;
                    return adtRelatedTableLayer;
                }

                async function getAllAdtParentOids() {
                    if (adtAllParentOids && adtAllParentOids.length > 0) {
                        return adtAllParentOids;
                    }
                    if (!adtLineLayer || !adtLineLayer.objectIdField) return [];
                    try {
                        const query = adtLineLayer.createQuery();
                        query.where = adtLineLayer.definitionExpression || "1=1";
                        const objectIds = await adtLineLayer.queryObjectIds(query);
                        adtAllParentOids = Array.isArray(objectIds) ? objectIds : [];
                        return adtAllParentOids;
                    } catch (error) {
                        console.warn("Error querying ADT parent object IDs:", error);
                        return [];
                    }
                }

                async function queryAdtRelatedRecords(parentOids, whereClause) {
                    if (!adtLineLayer || !adtRelationshipInfo) return [];
                    if (!parentOids || parentOids.length === 0) return [];

                    const records = [];
                    for (let i = 0; i < parentOids.length; i += MAX_ADT_REL_QUERY_BATCH) {
                        const chunk = parentOids.slice(i, i + MAX_ADT_REL_QUERY_BATCH);
                        const relQuery = new RelationshipQuery({
                            relationshipId: adtRelationshipInfo.id,
                            objectIds: chunk,
                            outFields: ["*"],
                            returnGeometry: false
                        });
                        if (whereClause) relQuery.where = whereClause;
                        try {
                            const response = await adtLineLayer.queryRelatedFeatures(relQuery);
                            Object.entries(response).forEach(([parentOid, data]) => {
                                const features = data && data.features ? data.features : [];
                                features.forEach(feature => {
                                    if (feature && feature.attributes) {
                                        records.push({
                                            parentObjectId: Number(parentOid),
                                            attributes: feature.attributes
                                        });
                                    }
                                });
                            });
                        } catch (error) {
                            console.warn("Error querying ADT related data:", error);
                        }
                    }
                    return records;
                }

                function displayAdtRecords(records) {
                    const attributeTable = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const thead = attributeTable ? attributeTable.querySelector("thead") : null;
                    const tbody = attributeTable ? attributeTable.querySelector("tbody") : null;
                    if (!attributeTable || !thead || !tbody) return;

                    thead.innerHTML = "";
                    tbody.innerHTML = "";
                    currentTableHeaders = [];
                    currentTableData = [];

                    if (!records || records.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No ADT count records match the current filters.</td></tr>`;
                        return;
                    }

                    const tableLayer = adtRelatedTableLayer;
                    const fieldLookup = new Map();
                    if (tableLayer && tableLayer.fields) {
                        tableLayer.fields.forEach(field => fieldLookup.set(field.name.toLowerCase(), field));
                    } else {
                        console.warn("ADT related table metadata was unavailable; using configured column definitions.");
                    }
                    const columnInfos = ADT_FIELD_CONFIG.map(config => {
                        const matchedField = fieldLookup.get(config.name.toLowerCase());
                        if (!matchedField) {
                            console.warn(`ADT related table is missing expected field '${config.name}'.`);
                        }
                        return {
                            name: matchedField ? matchedField.name : config.name,
                            alias: config.alias || (matchedField ? (matchedField.alias || matchedField.name) : config.name),
                            type: matchedField ? matchedField.type || "" : ""
                        };
                    });
                    adtFieldInfos = columnInfos;
                    currentTableHeaders = columnInfos.map(info => info.alias);

                    const headerRow = document.createElement("tr");
                    columnInfos.forEach(info => {
                        const th = document.createElement("th");
                        th.title = `Sort by ${info.alias}`;
                        th.textContent = info.alias;
                        const span = document.createElement("span");
                        span.className = 'sort-indicator';
                        span.textContent = ' \u21C5';
                        th.appendChild(span);
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    records.forEach(record => {
                        const row = document.createElement("tr");
                        const rowData = {};

                        columnInfos.forEach(info => {
                            let value = record.attributes ? record.attributes[info.name] : null;
                            if (value === null || value === undefined) {
                                value = '';
                            } else if ((info.type === "date" || info.type === "esriFieldTypeDate")) {
                                const dateVal = value instanceof Date ? value : new Date(value);
                                value = isNaN(dateVal.getTime()) ? '' : dateVal.toLocaleDateString();
                            } else if (value && typeof value === "object" && typeof value.toISOString === "function") {
                                value = value.toISOString();
                            } else if (typeof value === "number" && !Number.isInteger(value)) {
                                value = value.toFixed(2);
                            }
                            const valueStr = value === '' ? '' : String(value);
                            rowData[info.alias] = valueStr;
                            const cell = document.createElement("td");
                            cell.textContent = valueStr;
                            row.appendChild(cell);
                        });

                        tbody.appendChild(row);
                        currentTableData.push(rowData);
                    });

                    const noDataCell = tbody.querySelector('.no-features-row td');
                    if (noDataCell) {
                        noDataCell.colSpan = currentTableHeaders.length || 1;
                    }
                }

                async function refreshAdtTable() {
                    if (!adtLineLayer) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const adtTableLayer = await ensureAdtRelatedTableLayer();
                    if (!adtTableLayer) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const parentOids = adtSelectedOids.size > 0 ? Array.from(adtSelectedOids) : await getAllAdtParentOids();
                    if (!parentOids || parentOids.length === 0) {
                        displayAdtRecords([]);
                        updateFilterStatusSummary(0, 0, selectedFeatures.length + adtSelectedOids.size, adtSelectedOids.size > 0);
                        return;
                    }

                    const whereClause = buildAdtYearWhereClause(currentYears);
                    const records = await queryAdtRelatedRecords(parentOids, whereClause);
                    displayAdtRecords(records);
                    if (adtLineLayer) {
                        try {
                            const lv = await view.whenLayerView(adtLineLayer);
                            if (lv) {
                                if (highlightHandles[adtLineLayer.id]) {
                                    highlightHandles[adtLineLayer.id].remove();
                                }
                                if (adtSelectedOids.size > 0) {
                                    highlightHandles[adtLineLayer.id] = lv.highlight(Array.from(adtSelectedOids));
                                }
                            }
                        } catch (error) {
                            console.warn("Highlight error for ADT selection:", error);
                        }
                    }

                    filteredAndVisibleFeatures = [];
                    relatedDataCache = {};

                    const effectiveSelectionCount = selectedFeatures.length + adtSelectedOids.size;
                    const isFilteringSelection = adtSelectedOids.size > 0;
                    updateFilterStatusSummary(parentOids.length, records.length, effectiveSelectionCount, isFilteringSelection);
                }

                function clientSideFilterFeatures(features, relatedDataMap, filterYears, filterPeriod, filterDataType) {
                    if (filterYears.length === 0 && filterPeriod === "All" && filterDataType === "All") {
                        return features;
                    }

                    return features.filter(f => {
                        const oidField = f.layer ? f.layer.objectIdField : null;
                        if (!oidField) return false;
                        const oid = f.attributes[oidField];
                        const relatedRecs = relatedDataMap[oid] || [];

                        if (relatedRecs.some(relAttrs => doesRecordMatchFilters(relAttrs, filterYears, filterPeriod, filterDataType))) {
                            return true;
                        }

                        const mainMatches = doesRecordMatchFilters(f.attributes, filterYears, filterPeriod, filterDataType);
                        if (mainMatches) {
                            const mainCanMatchDataType = filterDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD));
                            const mainCanMatchYear = filterYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD));
                            const mainCanMatchPeriod = filterPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD));
                            if (mainCanMatchDataType && mainCanMatchYear && mainCanMatchPeriod) {
                                return true;
                            }
                        }
                        return false;
                    });
                }

                function doesRecordMatchFilters(attrs, filterYears, filterPeriod, filterDataType) {
                    if (!attrs) return false;

                    if (filterDataType !== "All" && (!attrs.hasOwnProperty(DATA_TYPE_FIELD) || attrs[DATA_TYPE_FIELD] !== filterDataType)) {
                        return false;
                    }
                    if (filterYears.length > 0 && (!attrs.hasOwnProperty(YEAR_FIELD) || !filterYears.includes(String((attrs[YEAR_FIELD] !== undefined && attrs[YEAR_FIELD] !== null) ? attrs[YEAR_FIELD] : '')))) {
                        return false;
                    }
                    if (filterPeriod !== "All" && (!attrs.hasOwnProperty(PERIOD_FIELD) || attrs[PERIOD_FIELD] !== filterPeriod)) {
                        return false;
                    }
                    return true;
                }

                async function fetchRelatedDataForFeatures(features) {
                    const relatedDataMap = {};
                    if (!features || features.length === 0) return relatedDataMap;

                    const featuresByLayer = features.reduce((acc, f) => {
                        if (!f.layer || !f.layer.id || !f.layer.objectIdField) {
                            console.warn("Feature missing layer information, skipping for related data fetch:", f.attributes);
                            return acc;
                        }
                        const layerId = f.layer.id;
                        const oid = f.attributes[f.layer.objectIdField];
                        if (oid === null || oid === undefined) return acc;
                        if (!acc[layerId]) {
                            acc[layerId] = { layer: f.layer, objectIds: new Set() };
                        }
                        acc[layerId].objectIds.add(oid);
                        return acc;
                    }, {});

                    const fetchPromises = Object.values(featuresByLayer).map(async ({ layer, objectIds }) => {
                        if (!layer.relationships || layer.relationships.length === 0) return;
                        const oids = Array.from(objectIds);
                        if (oids.length === 0) return;

                        const relPromises = layer.relationships.map(async rel => {
                            const relQuery = new RelationshipQuery({
                                relationshipId: rel.id,
                                objectIds: oids,
                                outFields: ["*"],
                                returnGeometry: false,
                            });
                            try {
                                const result = await layer.queryRelatedFeatures(relQuery);
                                for (const parentOId in result) {
                                    const relatedFeatures = (result[parentOId] && result[parentOId].features) ? result[parentOId].features : [];
                                    if (relatedFeatures.length > 0) {
                                        const numericParentOid = Number(parentOId);
                                        if (!relatedDataMap[numericParentOid]) relatedDataMap[numericParentOid] = [];
                                        relatedDataMap[numericParentOid].push(...relatedFeatures.map(feat => feat.attributes));
                                    }
                                }
                            } catch (error) {
                                console.warn(`Relationship query error (Rel ID: ${rel.id}, Layer: ${layer.title || layer.id}):`, error);
                            }
                        });
                        await Promise.all(relPromises);
                    });

                    await Promise.all(fetchPromises);
                    return relatedDataMap;
                }

                async function updateMapViewBasedOnFilters(isFilteringSelection, featuresToShow) {
                    clearAllHighlights();

                    const oidsToShowByLayer = featuresToShow.reduce((acc, f) => {
                        if (f.layer && f.layer.id && f.layer.objectIdField) {
                            const layerId = f.layer.id;
                            const oid = f.attributes[f.layer.objectIdField];
                            if (oid !== null && oid !== undefined) {
                                if (!acc[layerId]) acc[layerId] = new Set();
                                acc[layerId].add(oid);
                            }
                        }
                        return acc;
                    }, {});

                    if (isFilteringSelection) {
                        await clearAllLayerViewFilters();
                        const hlPromises = Object.entries(oidsToShowByLayer).map(async ([layerId, oidsSet]) => {
                            const layer = allLayers.find(l => l.id === layerId);
                            if (!layer || oidsSet.size === 0) return;
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (lv) highlightHandles[layerId] = lv.highlight(Array.from(oidsSet));
                            } catch (error) { console.warn(`Highlight error on layer ${layerId}:`, error); }
                        });
                        await Promise.all(hlPromises);
                    } else {
                        const filterPromises = allLayers.map(async (layer) => {
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (!lv) return;
                                const layerOIDsSet = oidsToShowByLayer[layer.id];
                                const objectIdsForFilter = layerOIDsSet && layerOIDsSet.size > 0 ? Array.from(layerOIDsSet) : [-1];
                                lv.filter = new FeatureFilter({ objectIds: objectIdsForFilter });
                            } catch (error) {
                                console.warn(`LayerView filter error on layer ${layer.id}:`, error);
                            }
                        });
                        await Promise.all(filterPromises);
                    }
                }

                function clearAllHighlights() {
                    Object.values(highlightHandles).forEach(handle => handle && handle.remove && handle.remove());
                    highlightHandles = {};
                }

                async function clearAllLayerViewFilters() {
                    const clearPromises = allLayers.map(async (layer) => {
                        try {
                            const lv = await view.whenLayerView(layer);
                            if (lv) lv.filter = null;
                        } catch (error) {
                            console.warn(`Clear LayerView filter error on layer ${layer.id}:`, error);
                        }
                    });
                    await Promise.all(clearPromises);
                }

                async function queryAllVisibleFeaturesAcrossLayers(layers) {
                    let allFeatures = [];
                    const queryPromises = layers.map(async (layer) => {
                        if (!layer.visible || layer.type !== 'feature') return;
                        const query = layer.createQuery();
                        query.where = layer.definitionExpression || "1=1";
                        query.outFields = ["*"];
                        query.returnGeometry = true;
                        try {
                            const result = await layer.queryFeatures(query);
                            result.features.forEach(f => f.layer = layer);
                            allFeatures.push(...result.features);
                        } catch (error) {
                            console.warn(`Query error on layer ${layer.title || layer.id}:`, error);
                        }
                    });
                    await Promise.all(queryPromises);
                    return allFeatures;
                }

                function displayAttributes(features, relatedDataMap) {
                    const attributeTable = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const thead = attributeTable ? attributeTable.querySelector("thead") : null;
                    const tbody = attributeTable ? attributeTable.querySelector("tbody") : null;
                    if (!attributeTable || !thead || !tbody) return;

                    thead.innerHTML = "";
                    tbody.innerHTML = "";
                    currentTableHeaders = [];
                    currentTableData = [];

                    if (!features || features.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No features match filters/selection.</td></tr>`;
                        return;
                    }

                    const headersSet = new Set();
                    const tableRowsData = [];
                    const columnValues = {};

                    features.forEach(f => {
                        const oidField = f.layer ? f.layer.objectIdField : null;
                        if (!oidField) return;
                        const oid = f.attributes[oidField];
                        const related = relatedDataMap[oid] || [];

                        const matchingRelated = related.filter(rec => doesRecordMatchFilters(rec, currentYears, currentPeriod, currentDataType));
                        const mainMatches = doesRecordMatchFilters(f.attributes, currentYears, currentPeriod, currentDataType);
                        const mainCanMatchFilters =
                            (currentDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD))) &&
                            (currentYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD))) &&
                            (currentPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD)));

                        if (matchingRelated.length > 0) {
                            matchingRelated.forEach(relAttrs => {
                                const rowData = { ...f.attributes, ...relAttrs };
                                tableRowsData.push(rowData);
                                Object.keys(rowData).forEach(attr => {
                                    headersSet.add(attr);
                                    if (!columnValues[attr]) columnValues[attr] = new Set();
                                    columnValues[attr].add((rowData[attr] !== undefined && rowData[attr] !== null) ? rowData[attr] : null);
                                });
                            });
                        } else if (mainMatches && mainCanMatchFilters) {
                            const rowData = { ...f.attributes };
                            tableRowsData.push(rowData);
                            Object.keys(rowData).forEach(attr => {
                                headersSet.add(attr);
                                if (!columnValues[attr]) columnValues[attr] = new Set();
                                columnValues[attr].add((rowData[attr] !== undefined && rowData[attr] !== null) ? rowData[attr] : null);
                            });
                        }
                    });

                    if (tableRowsData.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No data records meet the current filter criteria (Data Type, Year, Period).</td></tr>`;
                        return;
                    }

                    const fieldsToExclude = [
                        "OBJECTID", "Shape", "SHAPE_Length", "SHAPE_Area", "Intersection_IDs",
                        "LocationID", "Intersection_ID", "Longitude", "Latitude",
                        "PopupInfo", "Names", "Traffic_DataCollection_Date", "City", "State",
                        "Intersection_Type", "Leg_Type", "OBJECTID_1", "ParentGlobalID", "GlobalID",
                        "Shape__Area", "Shape__Length", "Major_Street", "Minor_Street", "PEAK_ID"
                    ];

                    let headersToDisplay = Array.from(headersSet).filter(attr => {
                        if (fieldsToExclude.includes(attr)) return false;
                        const vals = columnValues[attr];
                        return vals && Array.from(vals).some(v => v !== null && v !== undefined && String(v).trim() !== '');
                    });

                    const preferredOrder = ["Name", MAJOR_STREETS_FIELD, MINOR_STREETS_FIELD, DATA_TYPE_FIELD, YEAR_FIELD, PERIOD_FIELD, "TurningMovement_Sum"].filter(Boolean);
                    headersToDisplay.sort((a, b) => {
                        const idxA = preferredOrder.indexOf(a);
                        const idxB = preferredOrder.indexOf(b);
                        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                        if (idxA !== -1) return -1;
                        if (idxB !== -1) return 1;
                        return a.localeCompare(b);
                    });

                    // Group and sort directional movement columns according to user feedback
                    const directionalOrder = [
                        "EBL", "EBT", "EBR",
                        "WBL", "WBT", "WBR",
                        "NBL", "NBT", "NBR",
                        "SBL", "SBT", "SBR",
                        // Also include other potential directional totals in a logical order
                        "EB", "WB", "NB", "SB",
                        "E", "W", "N", "S"
                    ];

                    // Extract all directional columns that are present in the data
                    const existingDirCols = headersToDisplay.filter(h => directionalOrder.includes(h));

                    // Sort these extracted columns based on the predefined directionalOrder
                    existingDirCols.sort((a, b) => {
                        return directionalOrder.indexOf(a) - directionalOrder.indexOf(b);
                    });

                    // Remove the directional columns from the main list to re-insert them in the correct order
                    headersToDisplay = headersToDisplay.filter(h => !directionalOrder.includes(h));

                    // Determine the insertion point (e.g., right after 'Period')
                    let insertIndex = headersToDisplay.indexOf(PERIOD_FIELD);
                    // Insert after 'Period', or at the end if 'Period' is not found
                    insertIndex = (insertIndex !== -1) ? insertIndex + 1 : headersToDisplay.length;

                    headersToDisplay.splice(insertIndex, 0, ...existingDirCols);

                    currentTableHeaders = headersToDisplay;
                    currentTableData = tableRowsData;

                    const noDataRow = tbody.querySelector('.no-features-row td');
                    if (noDataRow) noDataRow.colSpan = headersToDisplay.length || 1;

                    const headerRow = document.createElement("tr");
                    headersToDisplay.forEach((headerText) => {
                        const th = document.createElement('th');
                        th.title = `Sort by ${headerText}`;
                        th.textContent = headerText;
                        const span = document.createElement('span');
                        span.className = 'sort-indicator';
                        span.textContent = ' \\u21C5';
                        th.appendChild(span);
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    tableRowsData.forEach(rowData => {
                        const row = document.createElement("tr");
                        headersToDisplay.forEach(header => {
                            const cell = document.createElement("td");
                            let displayValue = (rowData[header] !== undefined && rowData[header] !== null) ? rowData[header] : '';
                            if (typeof displayValue === 'number' && !Number.isInteger(displayValue)) {
                                displayValue = displayValue.toFixed(2);
                            }
                            cell.textContent = displayValue;
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    });
                }

                function handleMapClick(event) {
                    view.hitTest(event).then(response => {
                        const hitResults = response && response.results ? response.results : [];
                        const featureResult = hitResults.find(r =>
                            r.graphic && r.graphic.layer && r.graphic.layer.type === "feature" &&
                            allLayers.some(opLayer => opLayer.id === r.graphic.layer.id)
                        );
                        if (featureResult) {
                            toggleFeatureSelection(featureResult.graphic);
                            return;
                        }
                        const adtResult = hitResults.find(r =>
                            adtLineLayer && r.graphic && r.graphic.layer && r.graphic.layer.id === adtLineLayer.id
                        );
                        if (adtResult) {
                            toggleAdtFeatureSelection(adtResult.graphic);
                            return;
                        }
                        if (selectedFeatures.length > 0 || adtSelectedOids.size > 0) {
                            selectedFeatures = [];
                            adtSelectedOids.clear();
                            applyFiltersAndDisplay().catch(error => console.error("Error clearing selection on map click:", error));
                        }
                    }).catch(error => console.error("HitTest error:", error));
                }

                function toggleFeatureSelection(feature) {
                    if (!feature || !feature.layer || !feature.layer.objectIdField) return;
                    const oidField = feature.layer.objectIdField;
                    const oid = feature.attributes[oidField];
                    const layerId = feature.layer.id;
                    const idx = selectedFeatures.findIndex(f => f.layer.id === layerId && f.attributes[oidField] === oid);

                    if (idx > -1) {
                        selectedFeatures.splice(idx, 1);
                    } else {
                        selectedFeatures.push(feature);
                    }
                    applyFiltersAndDisplay().catch(error => console.error("Error updating selection:", error));
                }

                function toggleAdtFeatureSelection(feature) {
                    if (!feature || !adtLineLayer || feature.layer.id !== adtLineLayer.id || !adtLineLayer.objectIdField) {
                        return;
                    }
                    const rawOid = feature.attributes ? feature.attributes[adtLineLayer.objectIdField] : null;
                    if (rawOid === null || rawOid === undefined) {
                        return;
                    }
                    const numericOid = typeof rawOid === "number" ? rawOid : Number(rawOid);
                    if (!Number.isFinite(numericOid)) {
                        return;
                    }
                    if (adtSelectedOids.has(numericOid)) {
                        adtSelectedOids.delete(numericOid);
                    } else {
                        adtSelectedOids.add(numericOid);
                    }
                    setActiveTableTab(TABLE_TAB_ADT, { skipRefresh: true });
                    applyFiltersAndDisplay().catch(error => console.error("Error applying ADT selection:", error));
                }

                function sortTable(table, colIndex, headerCell) {
                    const tbody = table && table.tBodies ? table.tBodies[0] : null;
                    if (!tbody || !headerCell || colIndex < 0 || colIndex >= headerCell.parentNode.children.length) return;

                    const rows = Array.from(tbody.rows);
                    const newDirection = (headerCell.dataset.sort === 'asc') ? 'desc' : 'asc';
                    headerCell.dataset.sort = newDirection;
                    const isAsc = newDirection === 'asc';

                    rows.sort((a, b) => {
                        const aText = a.cells[colIndex] ? a.cells[colIndex].textContent : "".trim() || '';
                        const bText = b.cells[colIndex] ? b.cells[colIndex].textContent : "".trim() || '';
                        if (aText === '') return 1;
                        if (bText === '') return -1;
                        const aNum = Number(aText.replace(/,/g, ''));
                        const bNum = Number(bText.replace(/,/g, ''));
                        let comparisonResult;
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            comparisonResult = aNum - bNum;
                        } else {
                            comparisonResult = aText.localeCompare(bText, undefined, { sensitivity: 'base', numeric: true });
                        }
                        return isAsc ? comparisonResult : -comparisonResult;
                    });

                    rows.forEach(row => tbody.appendChild(row));
                    updateSortIndicators(table, colIndex, newDirection);
                }

                function updateSortIndicators(table, sortedColIndex, direction) {
                    const headers = table && table.tHead && table.tHead.rows[0] ? table.tHead.rows[0].cells : null;
                    if (!headers) return;
                    for (let i = 0; i < headers.length; i++) {
                        const indicator = headers[i].querySelector(".sort-indicator");
                        if (indicator) {
                            if (i === sortedColIndex) {
                                indicator.textContent = direction === 'asc' ? ' \\u25B2' : ' \\u25BC';
                            } else {
                                indicator.textContent = ' \\u21C5';
                                headers[i].dataset.sort = 'none';
                            }
                        }
                    }
                }

                function generatePDFReport() {
                    if (!window.jspdf || (!window.jspdf.autoTable && (!(window.jspdf.jsPDF && window.jspdf.jsPDF.API && window.jspdf.jsPDF.API.autoTable)))) {
                        alert("PDF generation library not loaded correctly. Please check console.");
                        return;
                    }

                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate PDF report.");
                        return;
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'landscape', unit: 'pt' });
                    const isAdtMode = currentTableTab === TABLE_TAB_ADT;

                    doc.setFontSize(18);
                    doc.text(isAdtMode ? "ADT Counts Report" : "Traffic Analytics Report", 40, 50);
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`Generated: ${new Date().toLocaleString()}`, 40, 65);
                    const filterSummary = isAdtMode
                        ? `Filters: Year(s)=${currentYears.join(',') || 'All'}`
                        : `Filters: Type=${currentDataType}, Year(s)=${currentYears.join(',') || 'All'}, Period=${currentPeriod}, Street=${currentStreet || 'None'}`;
                    doc.text(filterSummary, 40, 78);

                    const head = [currentTableHeaders];
                    const body = currentTableData.map(row => currentTableHeaders.map(header => String((row[header] !== undefined && row[header] !== null) ? row[header] : '')));

                    doc.autoTable({
                        head: head,
                        body: body,
                        startY: 90,
                        theme: 'striped',
                        styles: { fontSize: 7, cellPadding: 2, overflow: 'linebreak' },
                        headStyles: { fillColor: [75, 143, 207], textColor: 255, fontStyle: 'bold' },
                        margin: { top: 40, right: 40, bottom: 40, left: 40 },
                        didDrawPage: (data) => doc.text('Page ' + doc.internal.getNumberOfPages(), data.settings.margin.left, doc.internal.pageSize.height - 15)
                    });

                    doc.save(isAdtMode ? "adt_counts_report.pdf" : "traffic_analytics_report.pdf");
                }

                function generateCSVReport() {
                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate CSV report.");
                        return;
                    }
                    const escapeCSV = (val) => {
                        const str = String((val !== undefined && val !== null) ? val : '');
                        return str.includes(',') || str.includes('\n') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                    };
                    let csv = currentTableHeaders.map(escapeCSV).join(",") + "\n";
                    currentTableData.forEach(row => {
                        csv += currentTableHeaders.map(h => escapeCSV(row[h])).join(",") + "\n";
                    });
                    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
                    const blobUrl = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.href = blobUrl;
                    link.download = currentTableTab === TABLE_TAB_ADT ? "adt_counts_report.csv" : "traffic_analytics_report.csv";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    setTimeout(() => URL.revokeObjectURL(blobUrl), 0);
                }
                function generateReport() {
                    const format = (function(){ const el = document.getElementById(REPORT_FORMAT_ID); return el && el.value ? el.value : 'pdf'; })();
                    if (format === "pdf") generatePDFReport();
                    else if (format === "csv") generateCSVReport();
                }

                async function exportMapAsPDF() {
                    showLoadingSpinner();
                    const currentVP = view.viewpoint.clone();
                    try {
                        let targetExtent = null;
                        if (selectedFeatures.length > 0) {
                            selectedFeatures.forEach(f => {
                                const featExtent = f.geometry ? f.geometry.extent : null;
                                if (featExtent) {
                                    if (!targetExtent) targetExtent = featExtent.clone();
                                    else targetExtent = targetExtent.union(featExtent);
                                }
                            });
                            if (targetExtent) await view.goTo(targetExtent.expand(1.3));
                        }

                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const screenshot = await view.takeScreenshot({ width: 1600, height: 1000, format: 'png' });
                        if (targetExtent) await view.goTo(currentVP);

                        if (!window.jspdf) throw new Error("jsPDF library not found.");
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'letter' });
                        const pageW = doc.internal.pageSize.getWidth();
                        const pageH = doc.internal.pageSize.getHeight();
                        const margin = 40;
                        doc.setFontSize(18);
                        doc.text("City of Walnut Creek - Traffic Map", margin, margin + 10);
                        doc.setFontSize(10);
                        doc.setTextColor(100);
                        doc.text(`Exported: ${new Date().toLocaleString()}`, margin, margin + 25);
                        const availW = pageW - 2 * margin;
                        const availH = pageH - (margin + 40) - margin;
                        const imgProps = doc.getImageProperties(screenshot.dataUrl);
                        const imgRatio = imgProps.width / imgProps.height;
                        let imgW = availW, imgH = imgW / imgRatio;
                        if (imgH > availH) { imgH = availH; imgW = imgH * imgRatio; }
                        doc.addImage(screenshot.dataUrl, "PNG", margin + (availW - imgW) / 2, margin + 40, imgW, imgH);
                        doc.save("traffic_map_export.pdf");
                    } catch (error) {
                        console.error("Error during map export:", error);
                        alert(`Failed to export map: ${error.message}`);
                        await view.goTo(currentVP).catch(() => { });
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                function showLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'block';
                }

                function hideLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'none';
                }

                // ===========================================================
                // INITIALIZATION
                // ===========================================================
                async function init() {
                    showLoadingSpinner();
                    try {
                        map = new WebMap({ portalItem: { id: "e22b69d781254a3bbbf5d2310ba75315" } });
                        view = new MapView({
                            container: VIEW_DIV_ID,
                            map: map,
                            highlightOptions: { color: [0, 255, 255, 1], haloOpacity: 0.9, fillOpacity: 0.3 }
                        });
                        view.popup.autoOpenEnabled = false;
                        view.popup.defaultPopupTemplateEnabled = false;
                        await view.when();
                        await map.load();

                        if (map.loadStatus === 'failed') {
                            throw new Error(map.loadError && map.loadError.message || 'Unknown WebMap loading error');
                        }

                        const layerListWidget = new LayerList({ view });
                        view.ui.add(layerListWidget, "top-left");

                        adtLineLayer = new FeatureLayer({
                            url: "https://services2.arcgis.com/AhHMUmDoudKVXiUl/arcgis/rest/services/ADT_Counts_WFL1/FeatureServer/0",
                            title: "Average Daily Traffic Counts",
                            outFields: ["*"],
                            renderer: {
                                type: "simple",
                                symbol: {
                                    type: "simple-line",
                                    style: "solid",
                                    color: [255, 140, 0, 1],
                                    width: 1.5,
                                    cap: "round",
                                    join: "round"
                                }
                            },
                            labelingInfo: [{
                                labelPlacement: "center-along-line",
                                labelExpressionInfo: { expression: "Text($feature.ADT)" },
                                symbol: {
                                    type: "text",
                                    color: [80, 80, 80, 1],
                                    haloColor: [255, 255, 255, 1],
                                    haloSize: 1.5,
                                    font: {
                                        size: 8,
                                        family: "Arial",
                                        weight: "bold"
                                    }
                                }
                            }],
                            labelsVisible: true
                        });
                        adtLineLayer.appExcludeFromFilters = true;
                        map.add(adtLineLayer);
                        const layerChangeHandle = map.layers.on("change", () => {
                            if (tryReorderAdtLayer()) {
                                layerChangeHandle.remove();
                            }
                        });
                        if (!tryReorderAdtLayer()) {
                            reactiveUtils.when(() => !!findRootLayerByTitle(ADT_REFERENCE_LAYER_TITLE), () => {
                                if (tryReorderAdtLayer()) {
                                    layerChangeHandle.remove();
                                }
                            }, { once: true });
                        } else {
                            layerChangeHandle.remove();
                        }
                        await adtLineLayer.when();
                        adtSelectedOids.clear();
                        adtAllParentOids = null;
                        adtRelationshipInfo = (adtLineLayer.relationships || []).find(rel => {
                            const relName = (rel.name || "").toLowerCase();
                            return relName.includes("trafficcounts");
                        }) || (adtLineLayer.relationships && adtLineLayer.relationships.length > 0 ? adtLineLayer.relationships[0] : null);
                        if (!adtRelationshipInfo) {
                            console.warn("No related table definition found for ADT layer; ADT tab will be limited.");
                        } else {
                            await ensureAdtRelatedTableLayer().catch(error => console.warn("Unable to load ADT related table during initialization:", error));
                        }

                        originalViewpoint = view.viewpoint.clone();
                        addUiElements();
                        initializeTableTabs();
                        allLayers = map.layers.filter(layer => layer.type === "feature" && !layer.appExcludeFromFilters).toArray();

                        if (allLayers.length === 0) {
                            throw new Error("No FeatureLayers found in the Web Map. Application cannot function.");
                        }

                        await view.when(() => Promise.all(allLayers.map(layer => view.whenLayerView(layer))));

                        // Use the first layer that has relationships to populate years
                        const layerForYears = allLayers.find(l => l.relationships && l.relationships.length > 0) || allLayers[0];

                        const yearPopulationPromises = [
                            populateStreetList(allLayers),
                            populateYearsFromRelatedData(layerForYears)
                        ];
                        if (adtLineLayer && adtLineLayer.relationships && adtLineLayer.relationships.length > 0) {
                            yearPopulationPromises.push(populateYearsFromRelatedData(adtLineLayer));
                        }
                        await Promise.all(yearPopulationPromises);

                        createFilterElements();
                        initializeStreetAutocomplete();
                        addEventListeners();
                        await applyFiltersAndDisplay();

                    } catch (error) {
                        console.error("Initialization failed:", error);
                        alert(`Application failed to initialize: ${error.message}. Please check console.`);
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                init();

            });
            
        });
    </script>
</body>

</html>


