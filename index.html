<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Analytics Map</title>
    <link rel="stylesheet" href="https://js.arcgis.com/4.30/esri/themes/light/main.css">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.21/jspdf.plugin.autotable.min.js"></script>

    <script>
        var dojoConfig = {
            async: true,
            packages: [{
                name: "app",
                location: window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/app"
            }]
        };
    </script>
    <script src="https://js.arcgis.com/4.30/"></script>

    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            height: 100%;
            width: 100%;
            overflow: hidden;
            /* Prevent body scrollbars */
        }

        /* Main container uses flex column layout */
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            background: #f5f5f5;
        }

        /* Header remains fixed height */
        #header {
            flex: 0 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px 20px;
            background-color: #ffffff;
            border-bottom: 1px solid #ccc;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 1;
        }

        /* Map View takes up remaining flexible space */
        #viewDiv {
            flex: 1 1 auto;
            position: relative;
            /* Set a minimum height to ensure the map has enough space for UI elements like the filter panel, preventing overlap on short browser windows. */
            min-height: 320px;
            width: 100%;
        }

        /* Features Div (Table Container) at the bottom */
        #featuresDiv {
            /* Changed flex-shrink from 0 to 1. This allows the table panel to shrink if the browser window becomes too short, yielding space to the map view above. */
            flex: 0 1 45%;
            background-color: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            /* Important for child scroll container */
            border-top: 1px solid #ccc;
            width: 100%;
        }

        /* Table content area scrolls if needed */
        #featuresContentDiv {
            flex: 1 1 auto;
            box-sizing: border-box;
            overflow: auto;
            /* THIS IS THE SCROLL CONTAINER FOR THE TABLE */
            background: #ffffff;
            /* Tells the scroll container to leave space at the top for the sticky header */
            /* Adjust this value based on the actual height of your header row */
            scroll-padding-top: 40px;
        }

        /* Use separate border model for better sticky compatibility */
        .attribute-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
            table-layout: fixed;
            background-color: #ffffff;
            border: 1px solid #ddd;
            /* Border on table itself */
        }


        /* --- Sticky Header CSS (Applied to TH) --- */
        .attribute-table thead th {
            /* Positioning */
            position: sticky;
            top: 0;
            /* Stick to the top of the scroll container (#featuresContentDiv) */
            z-index: 2;
            /* Needs to be above tbody rows (default 0/auto) */

            /* Appearance */
            background-color: #4b8fcf;
            /* Crucial for opacity */
            color: #fff;
            text-align: left;
            font-weight: bold;
            padding: 8px 10px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            box-sizing: border-box;
            vertical-align: middle;

            /* Borders */
            border-top: 1px solid #ccc;
            border-left: 1px solid #ccc;
            border-bottom: 2px solid #ccc;
            /* Distinct bottom border */
        }

        /* Adjust border overrides as needed */
        .attribute-table thead tr:first-child th {
            border-top: none;
            /* Remove top border on the very first row of headers */
        }

        .attribute-table thead th:first-child {
            border-left: none;
            /* Remove left border on the first header cell */
            padding-left: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th:last-child {
            padding-right: 10px;
            /* Keep padding consistent */
        }

        .attribute-table thead th .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
            color: #eee;
        }

        /* --- End Sticky Header CSS --- */


        /* --- Table Body Cells --- */
        .attribute-table tbody td {
            padding: 8px 8px;
            box-sizing: border-box;
            vertical-align: middle;
            word-wrap: break-word;

            /* Borders */
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
            z-index: 1;
            /* Lower z-index than sticky headers */
        }

        .attribute-table tbody td:first-child {
            border-left: none;
            /* Remove left border on first body cell */
            padding-left: 10px;
        }

        .attribute-table tbody td:last-child {
            padding-right: 10px;
        }

        /* --- End Table Body Cells --- */


        /* Background styles */
        .attribute-table tbody tr:nth-child(even) td {
            background-color: #f9f9f9;
        }

        .attribute-table tbody tr:nth-child(odd) td {
            background-color: #ffffff;
        }

        .attribute-table tbody tr:hover td {
            background-color: #e8f0fe;
        }

        /* 'No features' row styling */
        .attribute-table .no-features-row td {
            text-align: center;
            font-style: italic;
            color: #666;
            background-color: #fff !important;
            border-top: 1px solid #ddd;
            border-left: 1px solid #ddd;
        }

        .attribute-table .no-features-row td:first-child:last-child {
            border-left: none;
        }

        #filterDiv,
        #reportingDiv {
            background-color: #ffffff;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            border: 1px solid #ccc;
            margin: 10px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            z-index: 50;
            /* Ensure they are above sticky headers */
        }

        #filterDiv {
            width: 270px;
        }

        #filterControls label {
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
        }

        #filterControls select,
        #filterControls input {
            width: 100%;
            margin-top: 3px;
            margin-bottom: 12px;
            padding: 6px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }

        #filterControls select[multiple] {
            height: auto;
        }

        #reportingDiv button {
            padding: 8px 15px;
            margin-left: 10px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            background: linear-gradient(to bottom, #f7f7f7, #e2e2e2);
            transition: background 0.2s, border-color 0.2s;
        }

        #reportingDiv select {
            padding: 8px 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
        }

        #reportingDiv button:hover {
            background: linear-gradient(to bottom, #f0f0f0, #d9d9d9);
            border-color: #999;
        }

        #reportingDiv button:active {
            background: linear-gradient(to bottom, #d9d9d9, #c2c2c2);
            border-color: #777;
        }

        #loadingSpinner {
            position: absolute;
            top: 50%;
            left: 50%;
            z-index: 1000;
            display: none;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: translate(-50%, -50%) rotate(0deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(360deg);
            }
        }

        #filterStatus {
            margin-top: 10px;
            color: #555;
            font-size: 12px;
            line-height: 1.4;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        #filterStatus strong {
            display: block;
            margin-bottom: 4px;
        }
    </style>
</head>

<body>
    <div id="app-container">
        <header id="header">
            <div>City of Walnut Creek</div>
            <div>Traffic Analytics Map</div>
        </header>

        <div id="viewDiv">
            <div id="loadingSpinner"></div>
        </div>

        <div id="featuresDiv">
            <!-- This div handles the scrolling -->
            <div id="featuresContentDiv">
                <table class="attribute-table" id="attributeTable">
                    <thead></thead> <!-- Headers added dynamically -->
                    <tbody></tbody> <!-- Data added dynamically -->
                </table>
            </div>
        </div>

        <!-- Templates for UI elements -->
        <div id="filterDivTemplate" style="display: none;">
            <div id="filterControls"></div>
            <div id="filterStatus">
                <strong>Filter Behavior:</strong>
                If features are selected (highlighted cyan on map), filters apply only to the selection. Otherwise,
                filters apply globally.<br>
                Clicking empty map space unselects all features. Filters hide non-matching features/data.
            </div>
        </div>

        <div id="reportingDivTemplate" style="display: none;">
            <select id="reportFormat" aria-label="Select Report Format">
                <option value="pdf">PDF</option>
                <option value="csv">CSV</option>
            </select>
            <button id="generateReportBtn" aria-label="Generate Report">Generate Report</button>
            <button id="printMapBtn" aria-label="Export Map">Export Map PDF</button>
        </div>

    </div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // --- Constants ---
            const DATA_TYPE_FIELD = "Data_Type";
            const YEAR_FIELD = "Year";
            const PERIOD_FIELD = "Period";
            const MAJOR_STREETS_FIELD = "Major_Streets";
            const MINOR_STREETS_FIELD = "Minor_Streets";
            const STREET_FILTER_DEBOUNCE_MS = 300;

            const VIEW_DIV_ID = "viewDiv";
            const FILTER_DIV_ID = "filterDiv";
            const REPORTING_DIV_ID = "reportingDiv";
            const ATTRIBUTE_TABLE_ID = "attributeTable";
            const LOADING_SPINNER_ID = "loadingSpinner";
            const FILTER_CONTROLS_ID = "filterControls";
            const DATA_TYPE_FILTER_ID = "dataTypeFilter";
            const YEAR_FILTER_ID = "yearFilter";
            const PERIOD_FILTER_ID = "periodFilter";
            const STREET_FILTER_ID = "streetFilter";
            const GENERATE_REPORT_BTN_ID = "generateReportBtn";
            const PRINT_MAP_BTN_ID = "printMapBtn";
            const REPORT_FORMAT_ID = "reportFormat";

            // --- State Variables ---
            let map, view;
            let allLayers = []; // Will hold FeatureLayers from the WebMap
            let highlightHandles = {};
            let allYears = new Set();
            let streetList = [];
            let currentDataType = "All";
            let currentYears = [];
            let currentPeriod = "All";
            let currentStreet = "";
            let selectedFeatures = [];
            let filteredAndVisibleFeatures = [];
            let relatedDataCache = {};
            let currentTableHeaders = [];
            let currentTableData = [];
            let originalViewpoint = null;
            let streetFilterTimeout = null;

            // --- ArcGIS Modules ---
            require([
                "esri/WebMap",
                "esri/views/MapView",
                "esri/layers/FeatureLayer",
                "esri/Graphic",
                "esri/rest/support/Query",
                "esri/rest/support/RelationshipQuery",
                "esri/layers/support/FeatureFilter",
                "esri/geometry/Extent",
                "esri/core/reactiveUtils"
            ], function (
                WebMap, MapView, FeatureLayer, Graphic, Query, RelationshipQuery, FeatureFilter, Extent,
                reactiveUtils
            ) {

                // ===========================================================
                // FUNCTION DEFINITIONS
                // ===========================================================

                function addUiElements() {
                    const filterDivTemplate = document.getElementById('filterDivTemplate');
                    const reportingDivTemplate = document.getElementById('reportingDivTemplate');
                    if (!filterDivTemplate || !reportingDivTemplate) { console.error("UI template elements not found!"); return; }
                    const filterDiv = filterDivTemplate.cloneNode(true);
                    filterDiv.id = FILTER_DIV_ID;
                    filterDiv.style.display = 'block';
                    view.ui.add(filterDiv, "top-right");
                    const reportingDiv = reportingDivTemplate.cloneNode(true);
                    reportingDiv.id = REPORTING_DIV_ID;
                    reportingDiv.style.display = 'flex';
                    reportingDiv.style.alignItems = 'center';
                    view.ui.add(reportingDiv, "top-left");
                }

                async function populateStreetList(spatialLayers) {
                    const streetSet = new Set();
                    const hasMajor = spatialLayers.some(l => l.fields?.some(f => f.name === MAJOR_STREETS_FIELD));
                    const hasMinor = spatialLayers.some(l => l.fields?.some(f => f.name === MINOR_STREETS_FIELD));
                    const fieldsToQuery = [];
                    if (hasMajor) fieldsToQuery.push(MAJOR_STREETS_FIELD);
                    if (hasMinor) fieldsToQuery.push(MINOR_STREETS_FIELD);

                    if (fieldsToQuery.length === 0) {
                        console.warn("Neither Major_Streets nor Minor_Streets field found in any loaded FeatureLayer. Cannot populate street list.");
                        streetList = [];
                        return;
                    }

                    console.log("Querying fields for street list:", fieldsToQuery);

                    const query = new Query({
                        where: "1=1",
                        returnDistinctValues: true,
                        outFields: fieldsToQuery,
                        returnGeometry: false
                    });

                    const queryPromises = spatialLayers.map(layer => {
                        const layerHasField = fieldsToQuery.some(fld => layer.fields?.some(f => f.name === fld));
                        if (!layerHasField) {
                            return Promise.resolve(); // Resolve immediately if layer lacks fields
                        }

                        return layer.queryFeatures(query)
                            .then(result => {
                                result.features.forEach(feature => {
                                    fieldsToQuery.forEach(fld => {
                                        if (feature.attributes && feature.attributes.hasOwnProperty(fld)) {
                                            const streetName = feature.attributes[fld];
                                            if (streetName && typeof streetName === 'string' && streetName.trim()) {
                                                streetSet.add(streetName.trim());
                                            }
                                        }
                                    });
                                });
                            }).catch(error => console.warn(`Error querying streets from layer ${layer.title || layer.id}:`, error));
                    });

                    await Promise.all(queryPromises);
                    streetList = Array.from(streetSet).sort();
                    console.log(`Populated street list with ${streetList.length} unique names.`);
                }

                async function populateYearsFromRelatedData(spatialLayer) {
                    console.log(`Attempting to populate years from relationships of layer: ${spatialLayer?.title ?? 'undefined'}`);
                    if (!spatialLayer || !spatialLayer.relationships || spatialLayer.relationships.length === 0) {
                        console.log(`Layer ${spatialLayer?.title ?? 'N/A'} has no relationships defined or is not valid.`);
                        return;
                    }
                    if (!YEAR_FIELD) {
                        console.warn("YEAR_FIELD constant is not defined. Cannot query for years.");
                        return;
                    }

                    const objectIdField = spatialLayer.objectIdField;
                    if (!objectIdField) {
                        console.error(`Layer ${spatialLayer.title || spatialLayer.id} does not have a valid objectIdField.`);
                        return;
                    }

                    const parentQuery = new Query({
                        where: "1=1",
                        returnGeometry: false,
                        outFields: [objectIdField],
                        num: 1000
                    });

                    let parentOids = [];
                    try {
                        const parentResult = await spatialLayer.queryFeatures(parentQuery);
                        parentOids = parentResult.features.map(f => f.attributes[objectIdField]);
                        if (parentOids.length === 0) {
                            console.log("No parent features found, cannot query related data.");
                            return;
                        }
                        if (parentResult.exceededTransferLimit) {
                            console.warn(`Parent feature query exceeded transfer limit for layer ${spatialLayer.title || spatialLayer.id}. Year list might be incomplete.`);
                        }
                    } catch (error) {
                        console.error(`Error querying parent features for layer ${spatialLayer.title || spatialLayer.id}:`, error);
                        return;
                    }

                    const relationshipPromises = [];

                    for (const rel of spatialLayer.relationships) {
                        let relatedTableHasYearField = false;
                        try {
                            const relatedTable = map.allTables.find(t => t.layerId === rel.relatedTableId) || map.allLayers.find(l => l.layerId === rel.relatedTableId);
                            if (relatedTable) {
                                if (!relatedTable.loaded) await relatedTable.load();
                                relatedTableHasYearField = relatedTable.fields?.some(f => f.name === YEAR_FIELD);
                            } else {
                                console.warn(`Could not find related table/layer with ID ${rel.relatedTableId} in the map.`);
                            }
                        } catch (loadError) {
                            console.warn(`Error loading related table ${rel.relatedTableId} to check fields:`, loadError);
                        }

                        if (!relatedTableHasYearField) {
                            console.log(`Skipping relationship query for Rel ID ${rel.id} as related table does not contain the field '${YEAR_FIELD}'.`);
                            continue;
                        }

                        const relQuery = new RelationshipQuery({
                            relationshipId: rel.id,
                            objectIds: parentOids,
                            outFields: [YEAR_FIELD],
                            returnGeometry: false
                        });

                        relationshipPromises.push(
                            spatialLayer.queryRelatedFeatures(relQuery)
                                .then(relatedResults => {
                                    for (const parentOid in relatedResults) {
                                        const relatedFeatures = relatedResults[parentOid]?.features ?? [];
                                        relatedFeatures.forEach(relatedFeature => {
                                            if (relatedFeature.attributes && relatedFeature.attributes.hasOwnProperty(YEAR_FIELD)) {
                                                const year = relatedFeature.attributes[YEAR_FIELD];
                                                if (year !== null && year !== undefined && String(year).trim() !== '') {
                                                    allYears.add(String(year));
                                                }
                                            }
                                        });
                                    }
                                })
                                .catch(error => console.warn(`Error querying relationship ID ${rel.id} for layer ${spatialLayer.title || spatialLayer.id}:`, error))
                        );
                    }

                    await Promise.all(relationshipPromises);
                    console.log(`Finished querying relationships for layer ${spatialLayer.title || spatialLayer.id}. Total unique years found: ${allYears.size}`);
                }

                function createFilterElements() {
                    const filterControlsDiv = document.getElementById(FILTER_CONTROLS_ID);
                    if (!filterControlsDiv) { console.error(`Element ID '${FILTER_CONTROLS_ID}' not found.`); return; }
                    filterControlsDiv.innerHTML = '';

                    // Data Type Filter
                    const dataTypes = ["All", "Bikes", "Intersection Info", "PHF", "Pedestrian", "Heavy Vehicles", "Turning Movement"];
                    filterControlsDiv.innerHTML += `<label for="${DATA_TYPE_FILTER_ID}">Data Type:</label><select id="${DATA_TYPE_FILTER_ID}">${dataTypes.map(type => `<option value="${type}">${type}</option>`).join('')}</select>`;

                    // Year Filter (Multiple Select)
                    const sortedYears = Array.from(allYears).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
                    if (sortedYears.length === 0) {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year:</label><select id="${YEAR_FILTER_ID}" disabled><option value="All">No Years Found</option></select>`;
                    } else {
                        filterControlsDiv.innerHTML += `<label for="${YEAR_FILTER_ID}">Year (Ctrl+Click):</label><select id="${YEAR_FILTER_ID}" multiple size="5"><option value="All" selected>All Years</option>${sortedYears.map(year => `<option value="${year}">${year}</option>`).join('')}</select>`;
                    }

                    // Period Filter
                    const periods = ["All", "AM", "MID", "PM"];
                    filterControlsDiv.innerHTML += `<label for="${PERIOD_FILTER_ID}">Period:</label><select id="${PERIOD_FILTER_ID}">${periods.map(period => `<option value="${period}">${period}</option>`).join('')}</select>`;

                    // Street Name Filter (Autocomplete)
                    filterControlsDiv.innerHTML += `<label for="${STREET_FILTER_ID}">Street Name:</label><input type="text" id="${STREET_FILTER_ID}" placeholder="Type street name...">`;
                }

                function initializeStreetAutocomplete() {
                    const streetInput = $(`#${STREET_FILTER_ID}`);
                    if (streetInput.length) {
                        streetInput.autocomplete({
                            source: streetList,
                            minLength: 0,
                            select: function (event, ui) {
                                $(this).val(ui.item.value);
                                applyFiltersAndDisplay();
                                return false;
                            },
                            change: function (event, ui) {
                                if (!ui.item) {
                                    applyFiltersAndDisplay();
                                }
                            }
                        }).focus(function () {
                            if (!$(this).val()) {
                                $(this).autocomplete("search", "");
                            }
                        });
                    } else {
                        console.error("Street filter input element not found for autocomplete.");
                    }
                }

                function addEventListeners() {
                    const filterControls = document.getElementById(FILTER_CONTROLS_ID);
                    const reportingControls = document.getElementById(REPORTING_DIV_ID);
                    const attributeTableHead = document.getElementById(ATTRIBUTE_TABLE_ID)?.querySelector('thead');

                    filterControls?.addEventListener('change', (event) => {
                        if (event.target?.tagName === 'SELECT') {
                            if (event.target.id === YEAR_FILTER_ID) {
                                const selectElement = event.target;
                                const selectedOptions = Array.from(selectElement.selectedOptions).map(opt => opt.value);
                                const allOption = selectElement.querySelector('option[value="All"]');

                                if (selectedOptions.includes("All") && selectedOptions.length > 1) {
                                    selectElement.querySelectorAll('option:not([value="All"])').forEach(opt => opt.selected = false);
                                    if (allOption) allOption.selected = true;
                                } else if (!selectedOptions.includes("All") && selectedOptions.length > 0 && allOption?.selected) {
                                    allOption.selected = false;
                                } else if (selectedOptions.length === 0 && allOption) {
                                    allOption.selected = true;
                                }
                            }
                            applyFiltersAndDisplay();
                        }
                    });

                    filterControls?.addEventListener('input', (event) => {
                        if (event.target?.id === STREET_FILTER_ID) {
                            clearTimeout(streetFilterTimeout);
                            streetFilterTimeout = setTimeout(applyFiltersAndDisplay, STREET_FILTER_DEBOUNCE_MS);
                        }
                    });

                    view.on("click", handleMapClick);

                    reportingControls?.addEventListener('click', (event) => {
                        if (event.target?.id === GENERATE_REPORT_BTN_ID) generateReport();
                        else if (event.target?.id === PRINT_MAP_BTN_ID) exportMapAsPDF();
                    });

                    attributeTableHead?.addEventListener('click', (event) => {
                        const headerCell = event.target.closest('th');
                        if (headerCell) {
                            const colIndex = Array.from(headerCell.parentNode.children).indexOf(headerCell);
                            sortTable(document.getElementById(ATTRIBUTE_TABLE_ID), colIndex, headerCell);
                        }
                    });
                }

                async function applyFiltersAndDisplay() {
                    showLoadingSpinner();
                    console.log("Applying filters...");

                    const dataTypeSelect = document.getElementById(DATA_TYPE_FILTER_ID);
                    const yearSelect = document.getElementById(YEAR_FILTER_ID);
                    const periodSelect = document.getElementById(PERIOD_FILTER_ID);
                    const streetInput = document.getElementById(STREET_FILTER_ID);

                    currentDataType = dataTypeSelect?.value ?? "All";
                    currentPeriod = periodSelect?.value ?? "All";
                    currentStreet = streetInput?.value.trim() ?? "";

                    currentYears = yearSelect ? Array.from(yearSelect.selectedOptions).map(opt => opt.value) : [];
                    if (currentYears.includes("All") || currentYears.length === 0) {
                        currentYears = [];
                    } else {
                        currentYears = currentYears.filter(y => y !== "All");
                    }

                    const escapedStreet = currentStreet.replace(/'/g, "''");
                    let definitionExpression = "1=1";
                    if (currentStreet && MAJOR_STREETS_FIELD && MINOR_STREETS_FIELD) {
                        const hasMajor = allLayers.some(l => l.fields?.some(f => f.name === MAJOR_STREETS_FIELD));
                        const hasMinor = allLayers.some(l => l.fields?.some(f => f.name === MINOR_STREETS_FIELD));
                        const conditions = [];
                        if (hasMajor) conditions.push(`${MAJOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (hasMinor) conditions.push(`${MINOR_STREETS_FIELD} LIKE '%${escapedStreet}%'`);
                        if (conditions.length > 0) {
                            definitionExpression = `(${conditions.join(' OR ')})`;
                        }
                    }

                    allLayers.forEach(layer => {
                        if (layer.definitionExpression !== definitionExpression) {
                            layer.definitionExpression = definitionExpression;
                        }
                    });

                    let baseFeaturesToFilter = [];
                    const isFilteringSelection = selectedFeatures.length > 0;

                    if (isFilteringSelection) {
                        baseFeaturesToFilter = selectedFeatures;
                        await clearAllLayerViewFilters();
                    } else {
                        baseFeaturesToFilter = await queryAllVisibleFeaturesAcrossLayers(allLayers);
                    }

                    relatedDataCache = await fetchRelatedDataForFeatures(baseFeaturesToFilter);
                    filteredAndVisibleFeatures = clientSideFilterFeatures(baseFeaturesToFilter, relatedDataCache, currentYears, currentPeriod, currentDataType);
                    await updateMapViewBasedOnFilters(isFilteringSelection, filteredAndVisibleFeatures);
                    displayAttributes(filteredAndVisibleFeatures, relatedDataCache);
                    hideLoadingSpinner();
                }

                function clientSideFilterFeatures(features, relatedDataMap, filterYears, filterPeriod, filterDataType) {
                    if (filterYears.length === 0 && filterPeriod === "All" && filterDataType === "All") {
                        return features;
                    }

                    return features.filter(f => {
                        const oidField = f.layer?.objectIdField;
                        if (!oidField) return false;
                        const oid = f.attributes[oidField];
                        const relatedRecs = relatedDataMap[oid] || [];

                        if (relatedRecs.some(relAttrs => doesRecordMatchFilters(relAttrs, filterYears, filterPeriod, filterDataType))) {
                            return true;
                        }

                        const mainMatches = doesRecordMatchFilters(f.attributes, filterYears, filterPeriod, filterDataType);
                        if (mainMatches) {
                            const mainCanMatchDataType = filterDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD));
                            const mainCanMatchYear = filterYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD));
                            const mainCanMatchPeriod = filterPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD));
                            if (mainCanMatchDataType && mainCanMatchYear && mainCanMatchPeriod) {
                                return true;
                            }
                        }
                        return false;
                    });
                }

                function doesRecordMatchFilters(attrs, filterYears, filterPeriod, filterDataType) {
                    if (!attrs) return false;

                    if (filterDataType !== "All" && (!attrs.hasOwnProperty(DATA_TYPE_FIELD) || attrs[DATA_TYPE_FIELD] !== filterDataType)) {
                        return false;
                    }
                    if (filterYears.length > 0 && (!attrs.hasOwnProperty(YEAR_FIELD) || !filterYears.includes(String(attrs[YEAR_FIELD] ?? '')))) {
                        return false;
                    }
                    if (filterPeriod !== "All" && (!attrs.hasOwnProperty(PERIOD_FIELD) || attrs[PERIOD_FIELD] !== filterPeriod)) {
                        return false;
                    }
                    return true;
                }

                async function fetchRelatedDataForFeatures(features) {
                    const relatedDataMap = {};
                    if (!features || features.length === 0) return relatedDataMap;

                    const featuresByLayer = features.reduce((acc, f) => {
                        if (!f.layer || !f.layer.id || !f.layer.objectIdField) {
                            console.warn("Feature missing layer information, skipping for related data fetch:", f.attributes);
                            return acc;
                        }
                        const layerId = f.layer.id;
                        const oid = f.attributes[f.layer.objectIdField];
                        if (oid === null || oid === undefined) return acc;
                        if (!acc[layerId]) {
                            acc[layerId] = { layer: f.layer, objectIds: new Set() };
                        }
                        acc[layerId].objectIds.add(oid);
                        return acc;
                    }, {});

                    const fetchPromises = Object.values(featuresByLayer).map(async ({ layer, objectIds }) => {
                        if (!layer.relationships || layer.relationships.length === 0) return;
                        const oids = Array.from(objectIds);
                        if (oids.length === 0) return;

                        const relPromises = layer.relationships.map(async rel => {
                            const relQuery = new RelationshipQuery({
                                relationshipId: rel.id,
                                objectIds: oids,
                                outFields: ["*"],
                                returnGeometry: false,
                            });
                            try {
                                const result = await layer.queryRelatedFeatures(relQuery);
                                for (const parentOId in result) {
                                    const relatedFeatures = result[parentOId]?.features ?? [];
                                    if (relatedFeatures.length > 0) {
                                        const numericParentOid = Number(parentOId);
                                        if (!relatedDataMap[numericParentOid]) relatedDataMap[numericParentOid] = [];
                                        relatedDataMap[numericParentOid].push(...relatedFeatures.map(feat => feat.attributes));
                                    }
                                }
                            } catch (error) {
                                console.warn(`Relationship query error (Rel ID: ${rel.id}, Layer: ${layer.title || layer.id}):`, error);
                            }
                        });
                        await Promise.all(relPromises);
                    });

                    await Promise.all(fetchPromises);
                    return relatedDataMap;
                }

                async function updateMapViewBasedOnFilters(isFilteringSelection, featuresToShow) {
                    clearAllHighlights();

                    const oidsToShowByLayer = featuresToShow.reduce((acc, f) => {
                        if (f.layer && f.layer.id && f.layer.objectIdField) {
                            const layerId = f.layer.id;
                            const oid = f.attributes[f.layer.objectIdField];
                            if (oid !== null && oid !== undefined) {
                                if (!acc[layerId]) acc[layerId] = new Set();
                                acc[layerId].add(oid);
                            }
                        }
                        return acc;
                    }, {});

                    if (isFilteringSelection) {
                        await clearAllLayerViewFilters();
                        const hlPromises = Object.entries(oidsToShowByLayer).map(async ([layerId, oidsSet]) => {
                            const layer = allLayers.find(l => l.id === layerId);
                            if (!layer || oidsSet.size === 0) return;
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (lv) highlightHandles[layerId] = lv.highlight(Array.from(oidsSet));
                            } catch (error) { console.warn(`Highlight error on layer ${layerId}:`, error); }
                        });
                        await Promise.all(hlPromises);
                    } else {
                        const filterPromises = allLayers.map(async (layer) => {
                            try {
                                const lv = await view.whenLayerView(layer);
                                if (!lv) return;
                                const layerOIDsSet = oidsToShowByLayer[layer.id];
                                const objectIdsForFilter = layerOIDsSet && layerOIDsSet.size > 0 ? Array.from(layerOIDsSet) : [-1];
                                lv.filter = new FeatureFilter({ objectIds: objectIdsForFilter });
                            } catch (error) {
                                console.warn(`LayerView filter error on layer ${layer.id}:`, error);
                            }
                        });
                        await Promise.all(filterPromises);
                    }
                }

                function clearAllHighlights() {
                    Object.values(highlightHandles).forEach(handle => handle?.remove());
                    highlightHandles = {};
                }

                async function clearAllLayerViewFilters() {
                    const clearPromises = allLayers.map(async (layer) => {
                        try {
                            const lv = await view.whenLayerView(layer);
                            if (lv) lv.filter = null;
                        } catch (error) {
                            console.warn(`Clear LayerView filter error on layer ${layer.id}:`, error);
                        }
                    });
                    await Promise.all(clearPromises);
                }

                async function queryAllVisibleFeaturesAcrossLayers(layers) {
                    let allFeatures = [];
                    const queryPromises = layers.map(async (layer) => {
                        if (!layer.visible || layer.type !== 'feature') return;
                        const query = layer.createQuery();
                        query.where = layer.definitionExpression || "1=1";
                        query.outFields = ["*"];
                        query.returnGeometry = true;
                        try {
                            const result = await layer.queryFeatures(query);
                            result.features.forEach(f => f.layer = layer);
                            allFeatures.push(...result.features);
                        } catch (error) {
                            console.warn(`Query error on layer ${layer.title || layer.id}:`, error);
                        }
                    });
                    await Promise.all(queryPromises);
                    return allFeatures;
                }

                function displayAttributes(features, relatedDataMap) {
                    const attributeTable = document.getElementById(ATTRIBUTE_TABLE_ID);
                    const thead = attributeTable?.querySelector("thead");
                    const tbody = attributeTable?.querySelector("tbody");
                    if (!attributeTable || !thead || !tbody) return;

                    thead.innerHTML = "";
                    tbody.innerHTML = "";
                    currentTableHeaders = [];
                    currentTableData = [];

                    if (!features || features.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No features match filters/selection.</td></tr>`;
                        return;
                    }

                    const headersSet = new Set();
                    const tableRowsData = [];
                    const columnValues = {};

                    features.forEach(f => {
                        const oidField = f.layer?.objectIdField;
                        if (!oidField) return;
                        const oid = f.attributes[oidField];
                        const related = relatedDataMap[oid] || [];

                        const matchingRelated = related.filter(rec => doesRecordMatchFilters(rec, currentYears, currentPeriod, currentDataType));
                        const mainMatches = doesRecordMatchFilters(f.attributes, currentYears, currentPeriod, currentDataType);
                        const mainCanMatchFilters = (currentDataType === "All" || (f.attributes && f.attributes.hasOwnProperty(DATA_TYPE_FIELD))) &&
                            (currentYears.length === 0 || (f.attributes && f.attributes.hasOwnProperty(YEAR_FIELD))) &&
                            (currentPeriod === "All" || (f.attributes && f.attributes.hasOwnProperty(PERIOD_FIELD)));

                        if (matchingRelated.length > 0) {
                            matchingRelated.forEach(relAttrs => {
                                const rowData = { ...f.attributes, ...relAttrs };
                                tableRowsData.push(rowData);
                                Object.keys(rowData).forEach(attr => {
                                    headersSet.add(attr);
                                    if (!columnValues[attr]) columnValues[attr] = new Set();
                                    columnValues[attr].add(rowData[attr] ?? null);
                                });
                            });
                        } else if (mainMatches && mainCanMatchFilters) {
                            const rowData = { ...f.attributes };
                            tableRowsData.push(rowData);
                            Object.keys(rowData).forEach(attr => {
                                headersSet.add(attr);
                                if (!columnValues[attr]) columnValues[attr] = new Set();
                                columnValues[attr].add(rowData[attr] ?? null);
                            });
                        }
                    });

                    if (tableRowsData.length === 0) {
                        tbody.innerHTML = `<tr class="no-features-row"><td colspan="1">No data records meet the current filter criteria (Data Type, Year, Period).</td></tr>`;
                        return;
                    }

                    const fieldsToExclude = [
                        "OBJECTID", "Shape", "SHAPE_Length", "SHAPE_Area", "Intersection_IDs",
                        "LocationID", "Intersection_ID", "Longitude", "Latitude",
                        "PopupInfo", "Names", "Traffic_DataCollection_Date", "City", "State",
                        "Intersection_Type", "Leg_Type", "OBJECTID_1", "ParentGlobalID", "GlobalID",
                        "Shape__Area", "Shape__Length", "Major_Street", "Minor_Street", "PEAK_ID"
                    ];

                    let headersToDisplay = Array.from(headersSet).filter(attr => {
                        if (fieldsToExclude.includes(attr)) return false;
                        const vals = columnValues[attr];
                        return vals && Array.from(vals).some(v => v !== null && v !== undefined && String(v).trim() !== '');
                    });

                    const preferredOrder = ["Name", MAJOR_STREETS_FIELD, MINOR_STREETS_FIELD, DATA_TYPE_FIELD, YEAR_FIELD, PERIOD_FIELD, "TurningMovement_Sum"].filter(Boolean);
                    headersToDisplay.sort((a, b) => {
                        const idxA = preferredOrder.indexOf(a);
                        const idxB = preferredOrder.indexOf(b);
                        if (idxA !== -1 && idxB !== -1) return idxA - idxB;
                        if (idxA !== -1) return -1;
                        if (idxB !== -1) return 1;
                        return a.localeCompare(b);
                    });

                    // Group and sort directional movement columns according to user feedback
                    const directionalOrder = [
                        "EBL", "EBT", "EBR",
                        "WBL", "WBT", "WBR",
                        "NBL", "NBT", "NBR",
                        "SBL", "SBT", "SBR",
                        // Also include other potential directional totals in a logical order
                        "EB", "WB", "NB", "SB",
                        "E", "W", "N", "S"
                    ];

                    // Extract all directional columns that are present in the data
                    const existingDirCols = headersToDisplay.filter(h => directionalOrder.includes(h));

                    // Sort these extracted columns based on the predefined directionalOrder
                    existingDirCols.sort((a, b) => {
                        return directionalOrder.indexOf(a) - directionalOrder.indexOf(b);
                    });

                    // Remove the directional columns from the main list to re-insert them in the correct order
                    headersToDisplay = headersToDisplay.filter(h => !directionalOrder.includes(h));

                    // Determine the insertion point (e.g., right after 'Period')
                    let insertIndex = headersToDisplay.indexOf(PERIOD_FIELD);
                    // Insert after 'Period', or at the end if 'Period' is not found
                    insertIndex = (insertIndex !== -1) ? insertIndex + 1 : headersToDisplay.length;

                    headersToDisplay.splice(insertIndex, 0, ...existingDirCols);

                    currentTableHeaders = headersToDisplay;
                    currentTableData = tableRowsData;

                    const noDataRow = tbody.querySelector('.no-features-row td');
                    if (noDataRow) noDataRow.colSpan = headersToDisplay.length || 1;

                    const headerRow = document.createElement("tr");
                    headersToDisplay.forEach((headerText) => {
                        const th = document.createElement('th');
                        th.title = `Sort by ${headerText}`;
                        th.textContent = headerText;
                        const span = document.createElement('span');
                        span.className = 'sort-indicator';
                        span.textContent = ' ';
                        th.appendChild(span);
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    tableRowsData.forEach(rowData => {
                        const row = document.createElement("tr");
                        headersToDisplay.forEach(header => {
                            const cell = document.createElement("td");
                            let displayValue = rowData[header] ?? '';
                            if (typeof displayValue === 'number' && !Number.isInteger(displayValue)) {
                                displayValue = displayValue.toFixed(2);
                            }
                            cell.textContent = displayValue;
                            row.appendChild(cell);
                        });
                        tbody.appendChild(row);
                    });
                }

                function handleMapClick(event) {
                    view.hitTest(event).then(response => {
                        const result = response.results?.find(r =>
                            r.graphic?.layer?.type === "feature" &&
                            allLayers.some(opLayer => opLayer.id === r.graphic.layer.id)
                        );
                        if (result) {
                            toggleFeatureSelection(result.graphic);
                        } else {
                            if (selectedFeatures.length > 0) {
                                selectedFeatures = [];
                                applyFiltersAndDisplay();
                            }
                        }
                    }).catch(error => console.error("HitTest error:", error));
                }

                function toggleFeatureSelection(feature) {
                    if (!feature?.layer || !feature.layer.objectIdField) return;
                    const oidField = feature.layer.objectIdField;
                    const oid = feature.attributes[oidField];
                    const layerId = feature.layer.id;
                    const idx = selectedFeatures.findIndex(f => f.layer.id === layerId && f.attributes[oidField] === oid);

                    if (idx > -1) {
                        selectedFeatures.splice(idx, 1);
                    } else {
                        selectedFeatures.push(feature);
                    }
                    applyFiltersAndDisplay();
                }

                function sortTable(table, colIndex, headerCell) {
                    const tbody = table?.tBodies[0];
                    if (!tbody || !headerCell || colIndex < 0 || colIndex >= headerCell.parentNode.children.length) return;

                    const rows = Array.from(tbody.rows);
                    const newDirection = (headerCell.dataset.sort === 'asc') ? 'desc' : 'asc';
                    headerCell.dataset.sort = newDirection;
                    const isAsc = newDirection === 'asc';

                    rows.sort((a, b) => {
                        const aText = a.cells[colIndex]?.textContent.trim() || '';
                        const bText = b.cells[colIndex]?.textContent.trim() || '';
                        if (aText === '') return 1;
                        if (bText === '') return -1;
                        const aNum = Number(aText.replace(/,/g, ''));
                        const bNum = Number(bText.replace(/,/g, ''));
                        let comparisonResult;
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            comparisonResult = aNum - bNum;
                        } else {
                            comparisonResult = aText.localeCompare(bText, undefined, { sensitivity: 'base', numeric: true });
                        }
                        return isAsc ? comparisonResult : -comparisonResult;
                    });

                    rows.forEach(row => tbody.appendChild(row));
                    updateSortIndicators(table, colIndex, newDirection);
                }

                function updateSortIndicators(table, sortedColIndex, direction) {
                    const headers = table?.tHead?.rows[0]?.cells;
                    if (!headers) return;
                    for (let i = 0; i < headers.length; i++) {
                        const indicator = headers[i].querySelector(".sort-indicator");
                        if (indicator) {
                            if (i === sortedColIndex) {
                                indicator.textContent = direction === 'asc' ? ' ' : ' ';
                            } else {
                                indicator.textContent = ' ';
                                headers[i].dataset.sort = 'none';
                            }
                        }
                    }
                }

                function generatePDFReport() {
                    if (!window.jspdf || (!window.jspdf.autoTable && (!window.jspdf.jsPDF?.API?.autoTable))) {
                        alert("PDF generation library not loaded correctly. Please check console.");
                        return;
                    }

                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate PDF report.");
                        return;
                    }

                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF({ orientation: 'landscape', unit: 'pt' });

                    doc.setFontSize(18);
                    doc.text("Traffic Analytics Report", 40, 50);
                    doc.setFontSize(10);
                    doc.setTextColor(100);
                    doc.text(`Generated: ${new Date().toLocaleString()}`, 40, 65);
                    doc.text(`Filters: Type=${currentDataType}, Year(s)=${currentYears.join(',') || 'All'}, Period=${currentPeriod}, Street=${currentStreet || 'None'}`, 40, 78);

                    const head = [currentTableHeaders];
                    const body = currentTableData.map(row => currentTableHeaders.map(header => String(row[header] ?? '')));

                    doc.autoTable({
                        head: head,
                        body: body,
                        startY: 90,
                        theme: 'striped',
                        styles: { fontSize: 7, cellPadding: 2, overflow: 'linebreak' },
                        headStyles: { fillColor: [75, 143, 207], textColor: 255, fontStyle: 'bold' },
                        margin: { top: 40, right: 40, bottom: 40, left: 40 },
                        didDrawPage: (data) => doc.text('Page ' + doc.internal.getNumberOfPages(), data.settings.margin.left, doc.internal.pageSize.height - 15)
                    });

                    doc.save("traffic_analytics_report.pdf");
                }

                function generateCSVReport() {
                    if (currentTableData.length === 0 || currentTableHeaders.length === 0) {
                        alert("No data in table to generate CSV report.");
                        return;
                    }
                    const escapeCSV = (val) => {
                        const str = String(val ?? '');
                        return str.includes(',') || str.includes('\n') || str.includes('"') ? `"${str.replace(/"/g, '""')}"` : str;
                    };
                    let csv = currentTableHeaders.map(escapeCSV).join(",") + "\n";
                    currentTableData.forEach(row => {
                        csv += currentTableHeaders.map(h => escapeCSV(row[h])).join(",") + "\n";
                    });
                    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
                    const link = document.createElement("a");
                    link.href = URL.createObjectURL(blob);
                    link.download = "traffic_analytics_report.csv";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }

                function generateReport() {
                    const format = document.getElementById(REPORT_FORMAT_ID)?.value ?? 'pdf';
                    if (format === "pdf") generatePDFReport();
                    else if (format === "csv") generateCSVReport();
                }

                async function exportMapAsPDF() {
                    showLoadingSpinner();
                    const currentVP = view.viewpoint.clone();
                    try {
                        let targetExtent = null;
                        if (selectedFeatures.length > 0) {
                            selectedFeatures.forEach(f => {
                                const featExtent = f.geometry?.extent;
                                if (featExtent) {
                                    if (!targetExtent) targetExtent = featExtent.clone();
                                    else targetExtent = targetExtent.union(featExtent);
                                }
                            });
                            if (targetExtent) await view.goTo(targetExtent.expand(1.3));
                        }

                        await new Promise(resolve => setTimeout(resolve, 1000));
                        const screenshot = await view.takeScreenshot({ width: 1600, height: 1000, format: 'png' });
                        if (targetExtent) await view.goTo(currentVP);

                        if (!window.jspdf) throw new Error("jsPDF library not found.");
                        const { jsPDF } = window.jspdf;
                        const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'letter' });
                        const pageW = doc.internal.pageSize.getWidth();
                        const pageH = doc.internal.pageSize.getHeight();
                        const margin = 40;
                        doc.setFontSize(18);
                        doc.text("City of Walnut Creek - Traffic Map", margin, margin + 10);
                        doc.setFontSize(10);
                        doc.setTextColor(100);
                        doc.text(`Exported: ${new Date().toLocaleString()}`, margin, margin + 25);
                        const availW = pageW - 2 * margin;
                        const availH = pageH - (margin + 40) - margin;
                        const imgProps = doc.getImageProperties(screenshot.dataUrl);
                        const imgRatio = imgProps.width / imgProps.height;
                        let imgW = availW, imgH = imgW / imgRatio;
                        if (imgH > availH) { imgH = availH; imgW = imgH * imgRatio; }
                        doc.addImage(screenshot.dataUrl, "PNG", margin + (availW - imgW) / 2, margin + 40, imgW, imgH);
                        doc.save("traffic_map_export.pdf");
                    } catch (error) {
                        console.error("Error during map export:", error);
                        alert(`Failed to export map: ${error.message}`);
                        await view.goTo(currentVP).catch(() => { });
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                function showLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'block';
                }

                function hideLoadingSpinner() {
                    const spinner = document.getElementById(LOADING_SPINNER_ID);
                    if (spinner) spinner.style.display = 'none';
                }

                // ===========================================================
                // INITIALIZATION
                // ===========================================================
                async function init() {
                    showLoadingSpinner();
                    try {
                        map = new WebMap({ portalItem: { id: "e22b69d781254a3bbbf5d2310ba75315" } });
                        view = new MapView({
                            container: VIEW_DIV_ID,
                            map: map,
                            highlightOptions: { color: [0, 255, 255, 1], haloOpacity: 0.9, fillOpacity: 0.3 }
                        });
                        await view.when();
                        await map.load();

                        if (map.loadStatus === 'failed') {
                            throw new Error(map.loadError?.message || 'Unknown WebMap loading error');
                        }

                        originalViewpoint = view.viewpoint.clone();
                        addUiElements();
                        allLayers = map.layers.filter(layer => layer.type === "feature").toArray();

                        if (allLayers.length === 0) {
                            throw new Error("No FeatureLayers found in the Web Map. Application cannot function.");
                        }

                        await view.when(() => Promise.all(allLayers.map(layer => view.whenLayerView(layer))));

                        // Use the first layer that has relationships to populate years
                        const layerForYears = allLayers.find(l => l.relationships?.length > 0) || allLayers[0];

                        await Promise.all([
                            populateStreetList(allLayers),
                            populateYearsFromRelatedData(layerForYears)
                        ]);

                        createFilterElements();
                        initializeStreetAutocomplete();
                        addEventListeners();
                        await applyFiltersAndDisplay();

                    } catch (error) {
                        console.error("Initialization failed:", error);
                        alert(`Application failed to initialize: ${error.message}. Please check console.`);
                    } finally {
                        hideLoadingSpinner();
                    }
                }

                init();

            });
        });
    </script>
</body>

</html>